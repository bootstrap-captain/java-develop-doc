# 基本理念

- 取决于同类问题的更小子集
- 最终缩减到无需递归
- 空间换时间：用时更快，但占用空间大

```bash
# 1. 确定能否使用递归求解
# 2. 推到出递归关系，递归的结束条件
# 3. 内层函数的调用结束后，外层函数才能执行完毕
```

```java
public void loop(ListNode node) {
    if (node == null) {                         // 1. 结束条件
        return;
    }
    System.out.println("before:"+node.val); // 处理
    loop(node.next);                           // 2. 内层处理完毕后，才会处理外层
    System.out.println("after:"+node.val); // 处理
}
```

- 假设数据是1-2-3-null
- 从外层函数进入到内层函数，内层函数执行完毕后，外层逐渐退出
- 在递的过程中，外层函数内的局部变量已经方法参数并没消失，归的时候还能用到

![image-20231123151424607](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231123151424607.png)

# 例子

## 阶乘

```java

```

## 2. 二分查找

```java
public int search(int[] arr, int target) {
    return searchFun(arr, target, 0, arr.length - 1);
}

private int searchFun(int[] arr, int target, int left, int right) {
    if (left > right) {
        return -1;
    }
    int middle = (left + right) / 2;

    if (target < arr[middle]) {
        return searchFun(arr, target, left, middle - 1);
    } else if (target > arr[middle]) {
        return searchFun(arr, target, middle + 1, right);
    } else {
        return middle;
    }
}
```

## 3. 链表遍历

 