# 二叉树

## 1. 基本概念

```bash
# 二叉树
- 每个节点，最多只存在两个子节点

# 根节点
- 二叉树的起始节点

# 叶子节点
- 没有子节点的节点

# 满二叉树
- 每个节点都有两个叶子节点

# 完全二叉树
- 其余层都必须填满，最后一层可填满可不填满
- 最后一层：必须从左向右填充
- 堆的实现就是

# 实现方式
- 数组
- TreeNode
```

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 1. 广度优先(层序遍历)

### 1.1 队列实现

```bash
# 思路
- 根结点入队
- 头弹出，处理当前节点，然后将当前节点的左右孩子依次入队
- 直到队列为空
```

![image-20231014115013816](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014115013816.png)

#### 基础版

- 只是简单打印

```java
public void easy(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        TreeNode el = queue.poll();
        System.out.println(el);
        if (el.left!=null){
            queue.offer(el.left);
        }
        if (el.right!=null){
            queue.offer(el.right);
        }
    }
}
```

#### 层序遍历-102

- 按照数据所在层，进行划分处理

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root==null){
            return result;
        }
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        int currentLayer = 1; // 当前层节点数
        while (!queue.isEmpty()) {
            List<Integer> subResult = new ArrayList<>();
            int nextLayer = 0;
            for (int i = 0; i < currentLayer; i++) { // 添加几次
                TreeNode el = queue.poll();
                subResult.add(el.val);
                if (el.left != null) {
                    queue.offer(el.left);
                    nextLayer++;
                }
                if (el.right != null) {
                    queue.offer(el.right);
                    nextLayer++;
                }
            }
            result.add(subResult);
            currentLayer = nextLayer;
        }
        return result;
    }
```

#### 层序遍历-107

- 按从叶子节点所在层到根节点所在的层，逐层从左向右遍历
- 和上题思路一样，只是在最终result.add(subResult)时，变成result.add(0,subResult)

#### Z字层序遍历-103

```bash
# 思路： 奇数层从左到右，偶数层从右到左，和上面处理思路比较像
```

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);

    int layerNodeSize = 1;
    boolean flag = true;
    while (!queue.isEmpty()) {
        List<Integer> subResult = new ArrayList<>();
        int nextLayerNodeSize = 0;
        for (int i = 0; i < layerNodeSize; i++) {
            TreeNode poll = queue.poll();
            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerNodeSize++;
            }
            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerNodeSize++;
            }
            if (flag) {
                subResult.add(poll.val);
            } else {
                subResult.add(0, poll.val);
            }
        }
        result.add(subResult);
        layerNodeSize = nextLayerNodeSize;
        flag = !flag;
    }
    return result;
}
```



## 2. 深度优先-递归

```bash
# 前序遍历：  中左右
- 1， 2， 4， 7，8， 3， 5， 9， a， 6， b

# 中序遍历：  左中右
- 7， 4， 8， 2， 1， 9， 5， a, 3, 6, b

# 后序遍历：  左右中
- 7, 8, 4, 2, 9, a, 5, b, 6, 3
```

![image-20231001161115309](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231001161115309.png)

```java
class Solution {

  static TreeNode root = new TreeNode(1,
          new TreeNode(2, new TreeNode(4), null),
          new TreeNode(3, new TreeNode(5), new TreeNode(6)));


  /*前序遍历： 中左右*/
  public void preOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      System.out.println(root.val);
      preOrder(root.left);
      preOrder(root.right);
  }

  /*中序遍历: 左中右*/
  public void inOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      inOrder(root.left);
      System.out.println(root.val);
      inOrder(root.right);
  }

  /*后序遍历： 左右中*/
  public void postOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      postOrder(root.left);
      postOrder(root.right);
      System.out.println(root.val);
  }
}
```

```java
class Solution {

    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), null),
            new TreeNode(3, new TreeNode(5), new TreeNode(6)));

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        preOrder(root, result);
        return result;
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        inOrder(root, result);
        return result;
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postOrder(root, result);
        return result;
    }


    /*前序遍历： 中左右*/
    public void preOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        result.add(root.val);
        preOrder(root.left, result);
        preOrder(root.right, result);
    }

    /*中序遍历: 左中右*/
    public void inOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        inOrder(root.left, result);
        result.add(root.val);
        inOrder(root.right, result);
    }

    /*后序遍历： 左右中*/
    public void postOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        postOrder(root.left, result);
        postOrder(root.right, result);
        result.add(root.val);
    }
}
```

## 3. 深度优先-栈

```java
class StackSolution {
    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), null),
            new TreeNode(3, new TreeNode(5), new TreeNode(6)));


    /*前，中序遍历*/
    public void preorderTraversal(TreeNode root) {
        List<Integer> preResult = new ArrayList<>();  //  前序遍历：中左右 去时记录
        List<Integer> inResult = new ArrayList<>();   // 中序遍历：左中右 回时遍历

        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                preResult.add(cur.val); // 前序遍历
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode pop = path.pop();
                inResult.add(pop.val); // 中序遍历
                cur = pop.right;
            }
        }
    }

    /*后序遍历: 左右中*/
    public void postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        TreeNode recentPop = null;

        while (cur != null || !path.isEmpty()) {
            if (cur != null) {           // 左子树已经处理完了
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode peek = path.peek();
                if (peek.right == null || peek.right == recentPop) { // 右子树处理完了
                    recentPop = path.pop();
                    result.add(recentPop.val);
                } else { // 右子树不为null
                    cur = peek.right;
                }
            }
        }
    }
}
```

```java
class StackSolution {
    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), new TreeNode(5)),
            new TreeNode(3, new TreeNode(6), new TreeNode(7)));


    /*后序遍历: 左右中*/
    public void postorderTraversal(TreeNode root) {
        List<Integer> pre = new ArrayList<>();     // 前序遍历：中左右 去时记录
        List<Integer> in = new ArrayList<>();      // 中序遍历：左中右 回时遍历
        List<Integer> post = new ArrayList<>();    // 后序遍历：左中右 回时遍历
        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        TreeNode pop = null;

        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                path.push(cur);
                // 待处理左子树
                pre.add(cur.val);
                cur = cur.left;
            } else {
                TreeNode peek = path.peek();

                if (peek.right == null) {   // 没有右子树
                    in.add(peek.val);
                    pop = path.pop();
                    post.add(pop.val);
                } else if (peek.right == pop) {   // 右子树处理完成
                    pop = path.pop();
                    post.add(pop.val);
                } else { // 待处理右子树
                    in.add(peek.val);
                    cur = peek.right;
                }
            }
        }
    }
}
```

## 4. 最大深度

- 从根节点出发，最远子结点和根节点的结点总数

### 4.1 递归

```java
public int calculateDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(calculateDepth(root.left), calculateDepth(root.right)) + 1;
}
```

## 3. leetcode

### 对称二叉树

```java
// 思路： 判断左右两个结点是否一样
public boolean checkSymmetricTree(TreeNode root) {
    if (root==null){
        return true;
    }
    return check(root.left, root.right);
}

public boolean check(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }

    if (left == null || right == null) {
        return false;
    }

    if (left.val != right.val) {
        return false;
    }

    return check(left.left, right.right) && check(left.right, right.left);
}
```

### 翻转二叉树

- 二叉树的左右孩子进行变换

```java
/*二叉树翻转*/
public TreeNode mirrorTree(TreeNode root) {
    mirror(root);
    return root;
}

private void mirror(TreeNode root) {
    if (root == null) {
        return;
    }

    // 交换当前层
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
    // 继续翻转左右子树
    mirror(root.left);
    mirror(root.right);
}
```

# 二叉搜索树

- 树节点增加key属性，用来比较谁大谁小，key不可以重复
- 对于所有树节点，它的key比左子树的key都大，同时也比右子树的key都小
- LeetCode中，只包含一个属性，既表示key，也表示value

```java
class BSTreeNode {
    Object val;
    int key;
    BSTreeNode left;
    BSTreeNode right;

    public BSTreeNode(int key) {
        this.key = key;
    }

    public BSTreeNode(Object val, int key) {
        this.val = val;
        this.key = key;
    }

    public BSTreeNode(Object val, int key, BSTreeNode left, BSTreeNode right) {
        this.val = val;
        this.key = key;
        this.left = left;
        this.right = right;
    }
}
```

## 1. 常见方法

- 类定义

```java
class BSTree {

    static BSTreeNode root; // 根结点

    /**
     *          4
     *        /    |
     *       2       6
     *      / \    /  \
     *     1   3   5   7
     */
    static {
        BSTreeNode first = new BSTreeNode("一号", 1);
        BSTreeNode third = new BSTreeNode("三号", 3);
        BSTreeNode fifth = new BSTreeNode("五号", 5);
        BSTreeNode seven = new BSTreeNode("七号", 7);

        BSTreeNode second = new BSTreeNode("二号", 2, first, third);
        BSTreeNode sixth = new BSTreeNode("六号", 6, fifth, seven);
        root = new BSTreeNode("四号", 4, second, sixth);
    }
}
```



### 1.1 根据key查找

```java
/*方式一：递归根据key来查找*/
public Object get1(int key) {
    return doGet(root, key);
}

private Object doGet(BSTreeNode node, int key) {
    if (node == null) {
        return null;
    }

    if (key < node.key) {              // 左子树
        return doGet(node.left, key);
    } else if (key > node.key) {       // 右子树
        return doGet(node.right, key);
    } else {
        return node.val;                // 中间值
    }
}

/*方式二：非递归*/
public Object get2(int key) {
    BSTreeNode node = root;
    while (node != null) {
        if (key < node.key) {
            node = node.left;
        } else if (key > node.key) {
            node = node.right;
        } else {
            return node.val;
        }
    }
    return null;
}
```

### 1.2 最小/大key对应的值

- 最小是找左边，最大是找右边

```java
/*方式一：最小key对应的值， 递归*/
public Object min01() {
    return doMin(root);
}

private Object doMin(BSTreeNode node) {
    if (node == null) {
        return null;
    }

    if (node.left == null) {
        return node.val;
    }

    return doMin(node.left);
}


/*方式二：最小key对应的值， 非递归*/
public Object min02() {
    if (root == null) {
        return null;
    }

    BSTreeNode node = root;
    while (node.left != null) {
        node = node.left;
    }

    return node.val;
}
```

### 1.3 put方法

- key如果存在，则更新，key不存在，新增

```java
/*key存在，则更新， key不存在，则插入*/
  public void put(int key, Object val) {
      if (root == null) {
          root = new BSTreeNode(val, key);
      }

      BSTreeNode node = root;
      BSTreeNode parent = null;
      while (node != null) {
          parent = node; // node为空时上一次节点

          if (key < node.key) {
              node = node.left;
          } else if (key > node.key) {
              node = node.right;
          } else { // key存在, 跟新
              node.val = val;
              return;
          }
      }

      BSTreeNode newNode = new BSTreeNode(val, key);
      if (key < parent.key) {
          parent.left = newNode;
      } else {
          parent.right = newNode;
      }
  }
```

### 1.4 前任后任

### 1.5 删除

```bash
# 1. 删除节点没有left，将right给parent
# 2. 删除节点没有right，将left给parent
# 3. 删除节点没有left 和 right，直接将null给parent
# 4. 删除节点的左右都是有元素的
```

```java
/**
     * @param key: 待删除节点的key
     * @return： 已删除节点的value
     */
    public Object delete(int key) {
        // 1. 找到目标结点
        BSTreeNode target = root;
        BSTreeNode parent = null;   // parent节点
        while (target != null) {
            if (key < target.key) {
                parent = target;
                target = target.left;
            } else if (key > target.key) {
                parent = target;
                target = target.right;
            } else {
                break;
            }
        }

        if (target == null) {
            return null; // 没找到目标结点
        }


        if (target.left == null) {      /*情况1: 节点只有right*/
            shift(parent, target, target.right);
        } else if (target.right == null) {  /*情况2: 节点只有left.      1和2可以覆盖到叶子节点*/
            shift(parent, target, target.left);
        } else { // 情况4: 左右都不为null
            // 暂时不做处理
        }
        return target.val;
    }

    /**
     * @param parent:  被删除节点的parent
     * @param deleted： 被删除结点
     * @param child：   被删除结点的子
     */
    private void shift(BSTreeNode parent, BSTreeNode deleted, BSTreeNode child) {
        if (parent == null) {
            root = child;
        } else if (deleted == parent.left) {
            parent.left = child;
        } else {
            parent.right = child;
        }
    }
```



# AVL树

- 一个二叉树，如果一个节点的right和left，高度差超过1，则此节点失衡，需要旋转
- 一个二叉树，在增加和删除时，就会可能导致失衡
- 在插入和删除时，通过旋转，始终让二叉搜索树保持平衡，就称为自平衡的二叉搜索树
- AVL是自平衡二叉搜索树的实现之一

```java
class AVLNode {
    int key;
    Object val;
    int height = 1;
    AVLNode left;
    AVLNode right;

    public AVLNode(int key, Object val) {
        this.key = key;
        this.val = val;
    }

    public AVLNode(int key) {
        this.key = key;
    }

    public AVLNode(int key, Object val, int height, AVLNode left, AVLNode right) {
        this.key = key;
        this.val = val;
        this.height = height;
        this.left = left;
        this.right = right;
    }

    public int getHeight(AVLNode node) {
        return node == null ? 0 : node.height;
    }

    public void updateHeight() {
        
    }
}
```

# 红黑树

# B树

