# 栈

- 只能从数据结构的一端进行操作，先进后出

![image-20231016113311031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016113311031.png)

```java
package com.citi.stack;

public interface MyStack {
    boolean push(int val);

    int pop();

    int peek();

    boolean isEmpty();

    boolean isFull();
}
```

## 1. 链表实现

- 单向带哨兵链表，头插头出

![image-20231016115640568](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016115640568.png)

```java
package com.citi.stack;

import java.util.NoSuchElementException;

public class LinkedListStack implements MyStack {
    class Node {
        int val;
        Node next;

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    Node sentinel = new Node(-999, null);
    int size;
    int capacity;

    public LinkedListStack(int capacity) {
        this.capacity = capacity;
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        sentinel.next = new Node(val, sentinel.next);
        size++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        Node removed = sentinel.next;
        sentinel.next = removed.next;
        size--;
        return removed.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return sentinel.next.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

## 2. 数组实现

![image-20231202101646696](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231202101646696.png)

```java
package com.citi.stack;

import java.util.NoSuchElementException;

public class ArrayStack implements MyStack {
    int[] arr;

    int top = 0;

    public ArrayStack(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        arr[top] = val;
        top++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        int result = arr[top - 1];
        arr[top - 1] = -999;
        top--;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return arr[top - 1];
    }

    @Override
    public boolean isEmpty() {
        return top == 0;
    }

    @Override
    public boolean isFull() {
        return top == arr.length;
    }
}
```



## 3. JDK实现

### 3.1 LinkedList

### 3.2 ArrayDeque

# Leetcode

## 😎 [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

### 栈

- 遍历字符串，如果左边符号，则入栈另一半字符；
- 如果右边，则出栈并比较

```java
public boolean isValid(String s) {
    LinkedList<Character> stack = new LinkedList<>();
    char[] chs = s.toCharArray();

    if (chs.length % 2 != 0) {
        return false;
    }
    for (char ch : chs) {
        if (ch == '{') {
            stack.push('}');
        } else if (ch == '[') {
            stack.push(']');
        } else if (ch == '(') {
            stack.push(')');
        } else {
            if (stack.isEmpty()) {
                return false;
            }
            if (stack.pop()!=ch){
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

## 逆波兰表达式

### 😡[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

- <font color=orange>后缀表达式</font>：运算符号在数字的后面，这样就不用考虑优先级问题
- JVM的运算指令就是这么玩的

#### 栈

- 碰见符号就把前面两个数字弹出栈
- 运算完成后重新入栈

```java
public int evalRPN(String[] tokens) {
      LinkedList<Integer> stack = new LinkedList<>();
      for (String token : tokens) {
          // 处理具体逻辑
          Integer second;
          Integer first;
          switch (token) {
              case "+":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first + second);
                  break;
              case "-":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first - second);
                  break;
              case "*":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first * second);
                  break;
              case "/":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first / second);
                  break;
              default:
                  stack.push(Integer.valueOf((token)));
          }
      }
      return stack.pop();
  }
```

### 😡中缀转后缀-无括号

- 给一个中缀表达式，将其转换为后缀表达式

![image-20231202132427456](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231202132427456.png)

```java
/*中缀表达式转后缀*/
public String convert(String str) {
    LinkedList<Character> stack = new LinkedList<>();
    StringBuffer sb = new StringBuffer();
    char[] chs = str.toCharArray();

    for (char ch : chs) {
        if (priority(ch) == -1) {  // 1. 不是运算符，则直接拼接
            sb.append(ch);
        } else {                   // 2. 是运算符
            if (stack.isEmpty()) {
                stack.push(ch);           // 2.1 栈如果为空，则直接添加
            } else {                      // 2.2 栈不空，判断
                if (priority(ch) <= priority(stack.peek())) {
                    while (!stack.isEmpty() && stack.peek() >= priority(ch)) {
                        sb.append(stack.pop());
                    }
                }
                stack.push(ch);
            }
        }
    }
    //3. 处理完成后，把栈里的元素依次出栈拼接
    while (!stack.isEmpty()) {
        sb.append(stack.pop());
    }
    return sb.toString();
}

private int priority(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 0;
        case '*':
        case '/':
            return 1;
        default:
            return -1;
    }
}
```

## 😎[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

- 出的时候，先把当前的outStack中出完，再去倒手

![image-20231018120502207](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231018120502207.png)

```java
import java.util.LinkedList;
import java.util.NoSuchElementException;

class MyQueue {

    LinkedList<Integer> inStack = new LinkedList<>();
    LinkedList<Integer> outStack = new LinkedList<>();

    int size = 0;


    public MyQueue() {
    }

    public void push(int x) {
        inStack.push(x);
        size++;
    }

    public int pop() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }

        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        size--;
        return outStack.pop();
    }

    public int peek() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }

        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.peek();
    }

    public boolean empty() {
        return size == 0;
    }
}
```

## 😎[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

![image-20231202135602075](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231202135602075.png)

```java
import java.util.LinkedList;
import java.util.NoSuchElementException;

class MyStack {

    LinkedList<Integer> queue = new LinkedList<>();

    public MyStack() {
    }

    public void push(int x) {
        queue.push(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.push(queue.pop());
        }
    }

    public int pop() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return queue.pop();
    }

    public int top() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return queue.peek();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```
