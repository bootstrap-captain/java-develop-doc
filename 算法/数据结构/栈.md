# 栈

- 只能从数据结构的一端进行操作，先进后出

![image-20231016113311031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016113311031.png)

```java
interface Stack {
    /*加数据*/
    boolean push(int val);
    /*弹出数据*/
    int pop();
    /*不弹出数据*/
    int peek();
    boolean isEmpty();
    boolean isFull();
}
```

## 1. 实现方式

### 1.1 链表实现

![image-20231016115640568](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016115640568.png)

```java
class LinkedListStack implements Stack {

    private int capacity;

    private int size;

    private Node sentinel = new Node(Integer.MIN_VALUE, null);

    public LinkedListStack(int capacity) {
        this.capacity = capacity;
    }

    static class Node {
        int val;
        Node next;

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        sentinel.next = new Node(val, sentinel.next);
        size++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int val = sentinel.next.val;
        sentinel.next = sentinel.next.next;
        size--;
        return val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.next.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size >= capacity;
    }
}
```

### 1.2 数组实现

```java
/*
 *  底          顶
 *  0   1   2   3
 *  a   b   c   d
 *
 *  top一开始为0，表示为空
 *  top增长到4(数组长度)，表示为满
 * */
class ArrayStack implements Stack {

    private int capacity;

    private int[] arr;

    private int top;

    public ArrayStack(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        arr[top] = val;
        top++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        top--;
        int result = arr[top];
        arr[top] = Integer.MAX_VALUE;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[top - 1];
    }

    @Override
    public boolean isEmpty() {
        return top == 0;
    }

    @Override
    public boolean isFull() {
        return top == capacity;
    }
}
```

### 1.3 JDK实现

- LinkedList

## 2. leetcode

### 2.1 有效的括号-20

```bash
# 输入： ()[]{}     输出：true
# 输入： {[}        输出：false
0. 长度为奇数，直接返回错误
1. 遇见左括号，则在栈中添加右括号
2. 遇见右括号，如果和栈顶元素相同，则弹出(空元素)；    如果不同，则直接返回错误
3. 最后栈的长度要为空
```

```java
 public boolean isValid(String s) {
        LinkedList<Character> list = new LinkedList();
        char[] charArray = s.toCharArray();
        if (charArray.length % 2 != 0) {
            return false;
        }

        for (char ch : charArray) {
            if (ch == '{') {
                list.push('}');
            } else if (ch == '[') {
                list.push(']');
            } else if (ch == '(') {
                list.push(')');
            } else if (list.isEmpty() || ch != list.pop()) {
                return false;
            }
        }
        return list.isEmpty();
    }
```

### 2.2 比较含退格的元素-844

### 

```bash
# 比较两个字符串是否相等， # 代表回退删除一个空格
```

```java
public boolean backspaceCompare(String s, String t) {
        LinkedList<Character> first = processStr(s);
        LinkedList<Character> second = processStr(t);
        if (first.size() != second.size()) {
            return false;
        }
        while (first.size() != 0) {
            Character firstEl = first.pop();
            Character secondEl = second.pop();
            if (!firstEl.equals(secondEl)) {
                return false;
            }
        }
        return true;
    }

    private LinkedList<Character> processStr(String s) {
        LinkedList<Character> list = new LinkedList<>();
        for (char ch : s.toCharArray()) {
            if (ch == '#') {
                if (!list.isEmpty()) {
                    list.pop();
                }
            } else {
                list.push(ch);
            }
        }
        return list;
    }
```

### 2.3 逆波兰表达式

#### 后缀表达式求值-150

- 运算符号在数字的后面，这样就不用考虑优先级问题

```bash
# 1. 碰见符号就把前面两个数字弹出栈
# 2. 运算完成后重新入栈

# 输入：tokens = ["2","1","+","3","*"]， 输出：9
```

```java
public int evalRPN(String[] tokens) {
      LinkedList<Integer> list = new LinkedList();
      List<String> calToken = new ArrayList<>();
      calToken.add("+");
      calToken.add("-");
      calToken.add("*");
      calToken.add("/");
      for (String token : tokens) {
          if (calToken.contains(token)) {
              Integer second = list.pop();
              Integer first = list.pop();
              int result = calculate(first, second, token);
              list.push(result);
          } else {
              list.push(Integer.valueOf(token));
          }
      }
      return list.pop();
  }

  private int calculate(int first, int second, String token) {
      switch (token) {
          case "+":
              return first + second;
          case "-":
              return first - second;
          case "*":
              return first * second;
          case "/":
              return first / second;
          default:
              throw new IllegalArgumentException();
      }
  }
```

#### 中缀表达式转后缀

### 2.4 双栈模拟队列-232

- 出的时候，先把当前的outStack中出完，再去倒手

![image-20231018120502207](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231018120502207.png)

```java
class MyQueue {
    LinkedList<Integer> inStack = new LinkedList<>();
    LinkedList<Integer> outStack = new LinkedList<>();

    public MyQueue() {
    }

    public void push(int x) {
        inStack.push(x);
    }

    public int pop() {
        if (empty()) {
            return Integer.MIN_VALUE;
        }

        if (!outStack.isEmpty()) {
            return outStack.pop();
        }

        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
        return outStack.pop();
    }

    public int peek() {
        if (empty()) {
            return Integer.MIN_VALUE;
        }

        if (!outStack.isEmpty()) {
            return outStack.peek();
        }

        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
        return outStack.peek();
    }

    public boolean empty() {
        return inStack.size() == 0 && outStack.size() == 0;
    }
}
```

### 2.5 单队列模拟栈-225

```bash
# 1. 反转队列: 队列中添加元素时候，先判断是否为空
- 为空，  offer添加
- 不会空， 先offer添加，然后把其他的元素先出队列，再重新进
```

![image-20231018123135569](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231018123135569.png)

```java
class MyStack {

    private Queue<Integer> queue = new ArrayDeque();

    public MyStack() {
    }

    public void push(int x) {
        queue.offer(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.offer(queue.poll());
        }
    }

    public int pop() {
        return queue.poll();
    }

    public int top() {
        return queue.peek();
    }

    public boolean empty() {
        return queue.size()==0;
    }
}
```
