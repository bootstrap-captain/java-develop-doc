# 堆

- 方式二：可以用数组来进行存储

## 1. 大顶堆/小顶堆

```bash
# 大顶堆： 任意节点都小于其父节点
# 小顶堆： 任意节点都大与其父节点
- 左节点和右节点关系不定

# 索引原则：索引0开始存储，i表示索引
- 节点i的父节点：       floor((i-1)/2)      当i大于0时
- 节点i的左子节点为：    2i+1                结果不能大于size
- 节点i的右子节点为：    2i+2                结果不能大于size
```

![image-20231023190718489](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023190718489.png)

## 2. MaxHeap

```java
package com.citi.heap;

public interface MaxHeap {
    /*头尾交换，并下潜*/
    int poll();

    void down(int parent);

    /*尾部添加：并上浮*/
    boolean offer(int data);

    void up(int child);

    boolean isFull();

    boolean isEmpty();
}
```

### 2.1 offer

```bash
# 威廉姆斯算法
- 入堆新元素，加入到数组末尾
- 不断比较新加元素与其父节点的值
    - 父节点更小，则父节点向下移动，继续向上找parent
    - 直到父节点值更大
```

![image-20231023172249031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023172249031.png)

### 2.2 poll

```bash
# poll： 删除堆顶处的元素
- 堆顶元素 和最后一个元素交换
- 删除最后一个元素
- 对堆顶元素进行下潜

# 下潜： 比左右孩子最大的小
- 比较当前节点的值和左右孩子的值
- 如果当前节点的值比左右孩子最大的小，则交换
```

### 2.3 heapify

```bash
# 方式一：威廉姆斯算法，旧数组，一个个offer进去

# 方式二：弗洛伊德算法):  对既有数组进行重排，
- 找到最后一个非叶子节点
- 从后向前，对每个节点执行下潜（比较左右值）

    # 非叶子节点
   - 没有任何一个左孩子或者右孩子
   - 最后一个元素的父节点
```

![image-20231023152506251](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023152506251.png)

```java
package com.citi.heap;

public class ArrayMaxHeap implements MaxHeap {

    private int[] arr;
    private int size;

    private int capacity;

    public ArrayMaxHeap(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    /*现有数组构建:*/
    public ArrayMaxHeap(int[] input, int capacity) {
        this(capacity);
        if (input.length <= capacity) {
            size = input.length;
            System.arraycopy(arr, 0, input, 0, input.length);
            heapfiy(arr);
        } else {
            size = arr.length;
            System.arraycopy(arr, 0, input, 0, capacity);
            heapfiy(arr);
        }
    }

    private void heapfiy(int[] arr) {
        int lastIndex = size / 2 - 1;
        for (int i = lastIndex; i >= 0; i--) {
            down(i);
        }
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int res = arr[0];

        swap(0, size - 1);
        arr[size - 1] = Integer.MIN_VALUE;
        down(0);
        size--;
        return res;
    }

    @Override
    public void down(int parent) {
        int left = 2 * parent + 1;
        int right = 2 * parent + 2;
        int max = parent;
        if (left < size && arr[left] > arr[max]) {
            max = left;
        }
        if (right < size && arr[right] > arr[max]) {
            max = right;
        }
        if (parent != max) {
            swap(parent, max);
            down(max);
        }
    }

    @Override
    public boolean offer(int data) {
        if (isFull()) {
            return false;
        }

        arr[size] = data;
        up(size);
        size++;
        return true;
    }

    @Override
    public void up(int child) {
        int val = arr[child];
        int parent = (child - 1) / 2;
        while (arr[parent] < val && child > 0) {
            arr[child] = arr[parent];
            child = parent;
            parent = (child - 1) / 2;
        }
        arr[child] = val;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 3. JDK-PriorityQueue

```java
PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> (b - a));      // 大顶堆
PriorityQueue<Integer> min = new PriorityQueue<>((a, b) -> (a - b));      // 小顶堆
```



## 4. LeetCode

### ❤️[数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

```bash
# 小顶堆(堆底元素就是第k大的)
# 方法类似大顶堆
- 1. 将前k个元素加入到数组中，并heapify成小顶堆
- 2. 后续数组元素依次入和堆顶元素比较
    - 2.1 如果比堆顶大，则替换堆顶元素，并下潜
    - 2.2 如果比堆顶小或等，则什么也不做
- 3. 返回堆顶元素 
```

![image-20231026112424150](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231026112424150.png)

```java
// JDK提供的小顶堆
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> stack = new PriorityQueue<>(k, Comparator.comparingInt(a -> a));
    for (int i = 0; i < k; i++) {
        stack.add(nums[i]);
    }

    for (int i = k; i < nums.length; i++) {
        if (nums[i] > stack.peek()) {
            stack.poll();
            stack.add(nums[i]);
        }
    }
    return stack.peek();
}
```

### 4.2 数据流中的第K大元素 - 321

```bash
# 给定整数数组 nums 和整数 k，返回数组中第k个最大的元素
# 可以给数组不断添加新的元素，依然返回第K个最大的元素
#  数组初始可能为null，数据可能为负数
# 题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素

# 解题思路类似上面
- 1.构建大小为k的小顶堆: 数据为Integer.MIN_VALUE
- 2.逐个添加顶部元素，并进行下潜
```

```java
class KthLargest {

    private MinHeap minHeap;

    public KthLargest(int k, int[] nums) {
        minHeap = new MinHeap(k);
        for (int i = 0; i < nums.length; i++) {
            minHeap.add(nums[i]);
        }
    }

    public int add(int val) {
        minHeap.add(val);
        return minHeap.arr[0];
    }
}

class MinHeap {
    int[] arr;
    int size;
    int capacity;

    public MinHeap(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
        Arrays.fill(arr, Integer.MIN_VALUE);
        size = capacity;
    }

    public void add(int data) {
        if (data > arr[0]) {
            arr[0] = data;
            down(0);
        }
    }

    private void down(int parent) {
        int left = parent * 2 + 1;
        int right = parent * 2 + 2;
        int min = parent;
        if (left < size && arr[left] < arr[min]) {
            min = left;
        }
        if (right < size && arr[right] < arr[min]) {
            min = right;
        }
        if (min != parent) {
            swap(min, parent);
            down(min);
        }
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 4.3 数据流的中位数

```bash
输入： 2,3,4,     输出：3
输入：1，2，3，4， 输出：2.5

# 思路：构建一个大顶堆，一个小顶堆，确保大顶堆的堆顶元素小于小顶堆的堆顶元素
# add
- 两边个数一样时，左边个数加一
- 两边个数不一样时，右边加一
# add规则
- 左边添加时，把新元素添加在右，弹出右边堆顶元素加入左边
- 右边逻辑类似
```

![image-20231029104600488](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029104600488.png)

```java
class MedianFinder {

    PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> (b - a));
    PriorityQueue<Integer> min = new PriorityQueue<>((a, b) -> (a - b));

    public MedianFinder() {
    }

    public void addNum(int num) {
        if (max.size() == min.size()) {
            // 添加到大顶堆
            min.add(num); // 添加后还是有序的堆
            Integer data = min.poll();
            max.add(data);
        } else {
            // 添加到小顶堆
            max.add(num);
            Integer data = max.poll();
            min.add(data);
        }
    }

    public double findMedian() {
        if (max.size() == min.size()) {
            return (max.peek() + min.peek()) / 2.0;
        } else {
            return max.peek();
        }
    }
}
```



## 