# 单向链表

```java
class Node{
    int val;
    Node next;

    public Node(int val, Node next) {
        this.val = val;
        this.next = next;
    }
}
```

```java
interface SingleListInter {
    void addFirst(int val);

    void loop(Consumer<Integer> consumer);

    void addLast(int val);

    int get(int index);

    void removeFirst();

    void remove(int index);

    void insert(int index, int val);
}
```

### 1.1 无哨兵

- head永远指向头元素，不要变动
- 会有很多判空的处理

![image-20231004155002630](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004155002630.png)

```java
class SingledList implements SingleListInter {
    Node head;

    @Override
    public void addFirst(int val) {
        head = new Node(val, head); // head为空/不空简化后的代码
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        Node pointer = head;  // 移动pointer而不是head
        while (pointer != null) {
            consumer.accept(pointer.val);
            pointer = pointer.next;
        }
    }

    @Override
    public void addLast(int val) {
        Node last = findLast();
        if (last == null) {
            addFirst(val);
        } else {
            last.next = new Node(val, null);
        }
    }

    @Override
    public int get(int index) {
        Node node = getNode(index);
        if (node == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return node.val;
    }

    @Override
    public void removeFirst() {
        if (head == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        head = head.next; // 前面一个元素，自动被垃圾回收掉
    }

    @Override
    public void remove(int index) {
        if (index == 0) {
            removeFirst();
        }
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node removed = prev.next;
        if (removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = removed.next;
    }

    @Override
    public void insert(int index, int val) {
        if (index == 0) {
            addFirst(val);
            return;
        }

        Node prev = getNode(index - 1); // 找前一个节点
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        prev.next = new Node(val, prev.next);
    }


    private Node findLast() {
        if (head == null) {
            return null;
        }
        Node pointer = head;
        while (pointer.next != null) {
            pointer = pointer.next;
        }
        return pointer;
    }

    private Node getNode(int index) {
        Node pointer = head;
        int currentIndex = -1;
        while (pointer != null) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

### 1.2 带哨兵

- dummy元素充当首元素，避免了一些判空处理

![image-20231004182312899](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004182312899.png)

```java
class SingledDummyList implements SingleListInter {
    Node dummy = new Node(Integer.MIN_VALUE, null);
    Node head = dummy;

    @Override
    public void addFirst(int val) {
        head.next = new Node(val, head.next);
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        Node pointer = head.next;
        while (pointer != null) {
            consumer.accept(pointer.val);
            pointer = pointer.next;
        }
    }

    @Override
    public void addLast(int val) {
        Node last = findLast();
        last.next = new Node(val, null);
    }

    @Override
    public int get(int index) {
        Node node = getNode(index);
        if (node == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return node.val;
    }

    @Override
    public void removeFirst() {
        if (dummy.next == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        dummy.next = dummy.next.next;
    }

    @Override
    public void remove(int index) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node removed = prev.next;
        if (removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = removed.next;
    }

    @Override
    public void insert(int index, int val) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = new Node(val, prev.next);
    }

    private Node findLast() {
        Node pointer = head;
        while (pointer.next != null) {
            pointer = pointer.next;
        }
        return pointer;
    }

    private Node getNode(int index) {
        Node pointer = head;
        int currentIndex = -2;
        while (pointer != null) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

## 2. 双向链表

- 带头哨兵和尾哨兵的双向链表

![image-20231004191925877](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004191925877.png)



```java
class Node {
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

```java
/*主要好处：可以逆序遍历，快速找到最后的结点*/
class DoublyLinkedList {
    Node head;
    Node tail;

    public DoublyLinkedList() {
        head = new Node(Integer.MIN_VALUE, null, null);
        tail = new Node(Integer.MIN_VALUE, null, null);
        head.next = tail;
        tail.prev = head;
    }

    public void addFirst(int val) {
        insert(0, val);
    }

    public void insert(int index, int val) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = prev.next;

        /*新节点*/
        Node inserted = new Node(val, prev, next);
        prev.next = inserted;
        next.prev = inserted;
    }

    public void remove(int index) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        Node removed = prev.next;
        if (removed == tail) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    public void addLast(int val) {
        Node prev = tail.prev;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;

        inserted.next = tail;
        tail.prev = inserted;
    }

    public void removeLast() {
        Node removed = tail.prev;
        if (removed == head) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = removed.prev;
        prev.next = tail;
        tail.prev = prev;
    }

    private Node getNode(int index) {
        int currentIndex = -2; // head节点的索引是-1
        Node pointer = head;
        while (pointer != tail) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

## 3. 双向环形链表

- 只有一个头哨兵

![image-20231005150947772](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231005150947772.png)

```java
class Node{
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

```java
class CrossDoublyLinkedList {
    Node sentinel;

    /*一开始的时候，哨兵结点的prev和next都指向本身自己*/
    public CrossDoublyLinkedList() {
        sentinel = new Node(Integer.MIN_VALUE, null, null);
        sentinel.prev = sentinel;
        sentinel.next = sentinel;
    }

    public void addFirst(int val) {
        Node prev = sentinel;
        Node next = sentinel.next;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;
        inserted.next = next;
        next.prev = inserted;
    }

    public void addLast(int val) {
        Node last = sentinel.prev;
        Node inserted = new Node(val, null, null);

        inserted.next = sentinel;
        sentinel.prev = inserted;
        last.next = inserted;
        inserted.prev = last;
    }

    public void removeFirst() {
        Node removed = sentinel.next;
        if (removed == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        sentinel.next = next;
        next.prev = sentinel;
    }

    public void removeLast() {
        Node last = sentinel.prev;
        if (last == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = last.prev;
        prev.next = sentinel;
        sentinel.prev = prev;
    }

    public void removeByVal(int val) {
        Node removed = findByVal(val);
        if (removed == null) {
            throw new IllegalArgumentException("No Target Found");
        }

        Node prev = removed.prev;
        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    private Node findByVal(int val) {
        Node pointer = sentinel.next;
        while (pointer != sentinel) {
            if (val == pointer.val) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }

}
```

- 默认每个题目中都是给一个head，可以在方法里面添加哨兵

# Easy

# Medium

# Hard



### 4.2 删除节点

#### ByValue



```bash
# 输入: head = [4,5,1,9], val = 5            输出: [4,1,9]
# 输入: head = [4,5,1,9], val = 1            输出: [4,5,9]
# 可能重复值

# 思路
- 前置结点和当前结点
```

```java
public ListNode deleteNode(ListNode head, int val) {
    // 添加一个头结点，后续省略很多判空处理，后续都用sentinel来处理
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head); 
    ListNode prev = sentinel;
    ListNode current = prev.next;
    while (current != null) {
        if (current.val == val) {
            prev.next = current.next;
        } else {
            prev = prev.next;
        }
        current = current.next;
    }
    return sentinel.next;
}
```

#### 倒数第N个

```bash
# 输入：head = [1,2,3,4,5], n = 2
# 输出：[1,2,3,5]
```

##### 正序遍历

```bash
# 一共需要遍历三次
- 1. 第一次遍历，得到链表总长length
- 2. 被删除索引 index = length-num
- 3. 删除指定索引的元素, sentinel的索引是-1
```

```java
 public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
        // 得到总size
        int length = getLength(sentinel);
        // 得到目标索引
        int targetIndex = length - n;
        // 前一个元素
        ListNode prev = getNode(sentinel, targetIndex - 1);
        // 后一个元素
        ListNode removed = getNode(sentinel, targetIndex);
        if (prev == null || removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        prev.next = removed.next;
        return sentinel.next;
    }

    private int getLength(ListNode sentinel) {
        ListNode pointer = sentinel.next;
        int length = 0;
        while (pointer != null) {
            length++;
            pointer = pointer.next;
        }
        return length;
    }

    private ListNode getNode(ListNode sentinel, int targetIndex) {
        int index = -2;
        ListNode pointer = sentinel;
        while (pointer != null) {
            index++;
            if (targetIndex == index) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
```

##### 快慢指针

![image-20231008115435110](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231008115435110.png)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode fast = sentinel;
    ListNode slow = sentinel;
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }

    while (fast.next != null) {
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;
    return sentinel.next;
}
```

#### 有序去重

- 重复元素保留一个

##### pre+current

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode pre = sentinel;
    ListNode current = sentinel.next;
    while (current != null) {
        if (pre.val == current.val) {
            pre.next = current.next;
        } else {
            pre = pre.next;
        }
        current = current.next;
    }
    return sentinel.next;
}
```

#### 有序去重

- 重复元素删除

##### p1+p2+p3

![image-20231009110239365](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231009110239365.png)

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode p1 = sentinel;
    ListNode p2 = p1.next;
    ListNode p3 = p2.next;

    while (p3 != null) {
        if (p3.val != p2.val) {
            p1 = p2;
            p2 = p3;
            p3 = p3.next;
        } else {
            while (p3 != null && p3.val == p2.val) {
                p3 = p3.next;
            }
            p1.next = p3;
            p2 = p3;
            if (p3 != null) {
                p3 = p3.next;
            }
        }
    }
    return sentinel.next;
}
```

### 4.4 中间结点

```bash
# 输入：head = [1,2,3,4,5]，   输出：[3,4,5]
# 输入：head = [1,2,3,4,5,6]   输出：[4,5,6]
```

#### 两次遍历

```bash
# 思路：
- 1. 遍历一次，得到链表长度，得到中间索引
- 2. 第二次遍历，根据索引获取到指定索引位置
```

#### 快慢指针

- 慢指针每次移动一个，快指针每次移动2个
- 快指针指向null时，慢指针的当前位置

![image-20231009154523418](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231009154523418.png)

```java
    public ListNode middleNode(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
        ListNode fast = sentinel;
        ListNode slow = sentinel;
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
            if (fast != null){
                fast = fast.next;
            }
        }
        return slow;
    }
```
