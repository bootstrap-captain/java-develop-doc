# 单向链表

- 数组各元素是连续存储的，链表不是

## 1. ListNode

```java
public class ListNode {
    int val;
    ListNode next;

    public ListNode(int val) {
        this.val = val;
    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

```java
public interface SingleListInter {
    void addFirst(int val);

    void addLast(int val);

    void loop(Consumer<Integer> consumer);

    int get(int index);

    void remove(int index);

    void insert(int index, int val);
}
```

## 2. 不带哨兵

![image-20231123132950873](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231123132950873.png)

```java
package com.citi.node;

import java.util.function.Consumer;

public class SingleListNoDummy implements SingleListInter {
    ListNode head = null;

    @Override
    public void addFirst(int val) {
        head = new ListNode(val, head);
    }

    @Override
    public void addLast(int val) {
        ListNode last = getLast();
        if (last == null) {
            addFirst(val);
            return;
        }
        last.next = new ListNode(val);
    }

    private ListNode getLast() {
        if (head == null) {
            return null;
        } // 要单独考虑head为空的情况
        ListNode p = head;
        while (p.next != null) {
            p = p.next;
        }
        return p;
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        ListNode p = head;
        while (p != null) {
            consumer.accept(p.val);
            p = p.next;
        }
    }

    @Override
    public int get(int index) {
        ListNode node = getByIndex(index);
        if (node == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        return node.val;
    }

    private ListNode getByIndex(int index) {
        int curIndex = 0;
        ListNode p = head;
        while (p != null) {
            if (index == curIndex) {
                return p;
            }
            curIndex++;
            p = p.next;
        }

        return null;
    }

    @Override
    public void remove(int index) {

    }

    /*找上一个结点*/
    @Override
    public void insert(int index, int val) {
        if (index == 0) {
            addFirst(val);
            return;
        }
        ListNode prev = getByIndex(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        prev.next = new ListNode(val, prev.next);
    }
}
```

## 3. 哨兵实现

- dummy元素充当哨兵节点，方便链表为空的情况
- 有些场景指针可以从sentinel移动，有些可以从sentinel.next移动

![image-20231004182312899](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004182312899.png)

```java
public class SingleList implements SingleListInter {
    ListNode sentinel = new ListNode(-888, null);

    @Override
    public void addFirst(int val) {
        sentinel.next = new ListNode(val, sentinel.next);
    }

    @Override
    public void addLast(int val) {
        ListNode last = findLastNode();
        last.next = new ListNode(val);
    }

   // 哨兵可能作为lastNode
    private ListNode findLastNode() {
        ListNode p = sentinel;
        while (p.next != null) {
            p = p.next;
        }
        return p;
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        ListNode p = sentinel.next;
        while (p != null) {
            consumer.accept(p.val);
            p = p.next;
        }
    }

    @Override
    public int get(int index) {
        ListNode result = getNode(index);
        if (result == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        return result.val;
    }

    /*-1能够拿到哨兵节点*/
    private ListNode getNode(int index) {
        ListNode p = sentinel;
        int idx = -1;
        while (p != null) {
            if (index == idx) {
                return p;
            }
            p = p.next;
            idx++;
        }
        return null;
    }

    @Override
    public void remove(int index) {
        ListNode preNode = getNode(index - 1);
        ListNode removedNode = getNode(index);
        if (preNode == null || removedNode == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        preNode.next = removedNode.next;
    }

    @Override
    public void insert(int index, int val) {
        ListNode preNode = getNode(index - 1);
        if (preNode == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        ListNode inserted = new ListNode(val, preNode.next);
        preNode.next = inserted;
    }
}
```

## 4. 性能

```bash
# 时间复杂度
# 随机访问
- 根据index查找  O(n)

# 插入
- 插入本身的是 O(1),  但是首先要根据index遍历找到插入位置，也就是O(n)
- 总体就是O(n)
    # 起始位置：O(1)
    # 结束为止：如果已知尾结点，是O(1), 否则就是O(n)
    # 中间位置： O(n)+O(1)=O(n)
```



# 双向链表

- 带头哨兵和尾哨兵的双向链表

![image-20231004191925877](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004191925877.png)

## 1. ListNode

- 主要好处：可以逆序遍历，快速找到最后的结点

```java
class Node {
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

## 2. 双向链表

```java
class DoublyLinkedList {
    Node head;
    Node tail;

    public DoublyLinkedList() {
        head = new Node(Integer.MIN_VALUE, null, null);
        tail = new Node(Integer.MIN_VALUE, null, null);
        head.next = tail;
        tail.prev = head;
    }

    public void addFirst(int val) {
        insert(0, val);
    }

    public void insert(int index, int val) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = prev.next;

        /*新节点*/
        Node inserted = new Node(val, prev, next);
        prev.next = inserted;
        next.prev = inserted;
    }

    public void remove(int index) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        Node removed = prev.next;
        if (removed == tail) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    public void addLast(int val) {
        Node prev = tail.prev;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;

        inserted.next = tail;
        tail.prev = inserted;
    }

    public void removeLast() {
        Node removed = tail.prev;
        if (removed == head) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = removed.prev;
        prev.next = tail;
        tail.prev = prev;
    }

    private Node getNode(int index) {
        int currentIndex = -2; // head节点的索引是-1
        Node pointer = head;
        while (pointer != tail) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

## 3. 环形链表

- 只有一个头哨兵

![image-20231005150947772](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231005150947772.png)

```java
class Node{
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

```java
class CrossDoublyLinkedList {
    Node sentinel;

    /*一开始的时候，哨兵结点的prev和next都指向本身自己*/
    public CrossDoublyLinkedList() {
        sentinel = new Node(Integer.MIN_VALUE, null, null);
        sentinel.prev = sentinel;
        sentinel.next = sentinel;
    }

    public void addFirst(int val) {
        Node prev = sentinel;
        Node next = sentinel.next;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;
        inserted.next = next;
        next.prev = inserted;
    }

    public void addLast(int val) {
        Node last = sentinel.prev;
        Node inserted = new Node(val, null, null);

        inserted.next = sentinel;
        sentinel.prev = inserted;
        last.next = inserted;
        inserted.prev = last;
    }

    public void removeFirst() {
        Node removed = sentinel.next;
        if (removed == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        sentinel.next = next;
        next.prev = sentinel;
    }

    public void removeLast() {
        Node last = sentinel.prev;
        if (last == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = last.prev;
        prev.next = sentinel;
        sentinel.prev = prev;
    }

    public void removeByVal(int val) {
        Node removed = findByVal(val);
        if (removed == null) {
            throw new IllegalArgumentException("No Target Found");
        }

        Node prev = removed.prev;
        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    private Node findByVal(int val) {
        Node pointer = sentinel.next;
        while (pointer != sentinel) {
            if (val == pointer.val) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }

}
```

# LeetCode

- 默认每个题目中都是给一个head，可以在方法里面添加哨兵

## 😎 链表遍历

### 迭代

```java
public void loop(ListNode head) {
    ListNode sentinel = new ListNode(-999, head);
    ListNode p = sentinel.next;
    while (p != null) {
        System.out.println(p.val);
        p = p.next;
    }
}
```

### 递归

```java
public void loop(ListNode head) {
    if (head == null) {
        return;
    }
    System.out.println(head.val);
    loop(head.next);
}
```

![image-20231125185211680](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231125185211680.png)



## 反转链表

### 😎[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

#### 迭代+新链表值

- 取出旧链表的每个节点的值，头插到新链表
- 原来链表不动

```java
public ListNode reverseList(ListNode head) {
    ListNode resultSentinel = new ListNode(-999, null);
    ListNode sentinel = new ListNode(-999, head);
    ListNode p = sentinel.next;
    while (p != null) {
        resultSentinel.next = new ListNode(p.val, resultSentinel.next);
        p = p.next;
    }
    return resultSentinel.next;
}
```

#### 迭代+新链表节点

- 原来链表每次移除头元素，头插到新链表
- 操作完成后，旧链表旧没有数据了
- 不会创造新的节点

```java
public ListNode reverseList(ListNode head) {
    ListNode resultSentinel = new ListNode(-999, null);

    while (head != null) {
        ListNode el = head;
        el.next = null;
      
        head = head.next;     // 旧链表后移

        el.next = resultSentinel.next;
        resultSentinel.next = el;
    }
    return resultSentinel.next;
}
```

#### 迭代+冒泡

```bash
# 步骤
1. 得到head的下一个元素
2. 将下一个元素从链表中删除(head的next指向下下一个)
3. 删除元素节点先孤立起来，next指向sentinel的next
4. sentinel的next指向删除元素
```

![image-20231125174046699](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231125174046699.png)

```java
public ListNode reverseList(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode sentinel = new ListNode(-999, head);
    while (head.next != null) {
        ListNode rise = head.next;
        head.next = head.next.next;

        rise.next = null;
        rise.next = sentinel.next;
        sentinel.next = rise;
    }
    return sentinel.next;
}
```

#### 递归

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head; 
    }
    ListNode last = reverseList(head.next);
    head.next.next = head;  // 逆转指针
    head.next = null;     // 断环
    return last;
}
```

![image-20231126115717309](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231126115717309.png)



## 合并链表

### 😎[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

#### 迭代+新链表

- 比较两个链表，谁小就把谁的值给新链表，新链表指针和小的链表指针后移

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode sentinel = new ListNode(-999, null);
    ListNode p = sentinel;
    while (list1 != null && list2 != null) {
        if (list1.val < list2.val) {
            p.next = new ListNode(list1.val);
            list1 = list1.next;
        } else {
            p.next = new ListNode(list2.val);
            list2 = list2.next;
        }
        p = p.next;
    }

    p.next = (list1 == null) ? list2 : list1;
    return sentinel.next;
}
```

#### 递归

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

    if (list1 == null) {
        return list2;
    }
    if (list2 == null) {
        return list1;
    }

    ListNode result = null;
    if (list1.val < list2.val) {
        result = list1;
        list1 = list1.next;
    } else {
        result = list2;
        list2 = list2.next;
    }
    result.next = mergeTwoLists(list1, list2);
    return result;
}
```

### ❤️[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

#### 递归

- 将K个链表，通过降级成2个链表
- 然后进行2个链表的合并

## 删除元素

### 😎[203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)-ByValue

#### 迭代

```java
public ListNode removeElements(ListNode head, int val) {
    ListNode sentinel = new ListNode(-888, head);
    ListNode prev = sentinel;
    ListNode p = sentinel.next;
    while (p != null) {
        if (p.val != val) {
            prev = p;
        } else {
            prev.next = p.next;
        }
        p = p.next;
    }
    return sentinel.next;
}
```

#### 递归

```java
public ListNode removeElements(ListNode head, int val) {
    if (head == null) {
        return null;
    }

    if (head.val == val) {
        return removeElements(head.next, val);
    } else {
        head.next = removeElements(head.next, val);
        return head;
    }
}
```

### 😡[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

#### 正序遍历

- 第一次遍历，得到要删除的结点的索引
- 第二次遍历，删除指定的结点

```java
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int length = getLength(head);
        int targetIndex = length - n; // 待删除元素的索引, 需要找到该元素的上一个
        // 找到待删除元素的上一个节点
        ListNode sentinel = new ListNode(-999, head);
        ListNode p = sentinel;
        int idx = -1;
        while (p != null) {
            if (idx == targetIndex - 1) {
                p.next = p.next.next;
            }
            p = p.next;
            idx++;
        }
        return sentinel.next;
    }

    private int getLength(ListNode head) {
        ListNode p = head;
        int length = 0;
        while (p != null) {
            length++;
            p = p.next;
        }
        return length;
    }
```

#### 快慢指针

![image-20231008115435110](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231008115435110.png)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode sentinel = new ListNode(-999, head);
    ListNode fast = sentinel;
    ListNode slow = sentinel;
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }

    while (fast.next != null) {
        slow = slow.next;
        fast = fast.next;
    }

    slow.next = slow.next.next;
    return sentinel.next;
}
```

### 😎[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

#### 迭代

- prev和cur指针
- 重复元素保留的是第一个

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode sentinel = new ListNode(-999, head);
    ListNode prev = sentinel;
    ListNode cur = sentinel.next;

    while (cur != null) {
        if (cur.val != prev.val) {
            prev = prev.next;
        } else {
            prev.next = cur.next;
        }
        cur = cur.next;
    }
    return sentinel.next;
}
```

#### 递归

- 重复元素保留的是最后一个

```bash
# 思路
*--1--3--3--3---4
- 从头开始处理
- 如果head和下一个重复，则返回head.next的递归处理结果
- 如果head和下一个不重复，则head.ext指向下一个的递归处理结果
```

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    if (head.val == head.next.val) {
        return deleteDuplicates(head.next);
    } else {
        head.next = deleteDuplicates(head.next);
        return head;
    }
}
```

### 😡[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

#### 迭代

- prev节点，cur节点，base节点

```bash
# 思路

s, 1, 1, 
```



#### 递归

- 找下一个不重复的元素并返回

![image-20231127115216911](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231127115216911.png)

```bash
# 如果当前节点和下一个节点值相同，
- 则一直找一个不同的节点，以不同的那个节点为结果，继续递归
# 如果不同
- 返回节点本身，并指针指向下一个节点的递归结果   
```

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    if (head.val == head.next.val) {
        ListNode dif = head.next.next;
        while (dif != null) {
            if (dif.val != head.val) {
                break;
            }
            dif = dif.next;
        }
        return deleteDuplicates(dif);
    } else {
        head.next = deleteDuplicates(head.next);
        return head;
    }
}
```



## 查找

### 😎[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

#### 两次迭代

- 第一遍找到中间索引: length/2
- 第二次找到中间结点

```java
public ListNode middleNode(ListNode head) {
      int length = getLength(head);
      int middleIndex = length / 2;

      ListNode sentinel = new ListNode(-999, head);
      ListNode p = sentinel;
      int idx = -1;
      while (p != null) {
          if (idx == middleIndex) {
              return p;
          }
          idx++;
          p = p.next;
      }
      return null;
  }

  private int getLength(ListNode head) {
      int length = 0;
      ListNode p = head;
      while (p != null) {
          length++;
          p = p.next;
      }
      return length;
  }
```

#### 快慢指针

- 慢指针每次移动一个，快指针每次移动2个
- 从头结点开始

![image-20231128204443257](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231128204443257.png)

```java
public ListNode middleNode(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
```

###  😎 [倒数第K个](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

#### 快慢指针

```java
public ListNode trainingPlan(ListNode head, int cnt) {
    ListNode fast = head;
    ListNode slow = head;
    for (int i = 0; i < cnt; i++) {
        fast = fast.next;
    }
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
```



## 😎[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

### 链表全部反转 + 比较

- 旧链表反转得到新的链表
- 新旧比较

```java
public boolean isPalindrome(ListNode head) {
    ListNode after = reverse(head);
    while (after != null) {
        if (after.val != head.val) {
            return false;
        }
        after = after.next;
        head = head.next;
    }
    return true;
}

ListNode reverse(ListNode head) {
    ListNode after = new ListNode(-999);
    while (head != null) {
        after.next = new ListNode(head.val, after.next);
        head = head.next;
    }
    return after.next;
}
```

### 中间节点 + 后段链表反转 + 比较

- 第一次迭代：快慢指针：找到中间节点
- 第二次迭代：构建新链表进行链表反转

```java
public boolean isPalindrome(ListNode head) {
    ListNode reverse = reverse(middle(head));
    while (reverse != null) {
        if (head.val!= reverse.val){
            return false;
        }
        head = head.next;
        reverse = reverse.next;
    }
    return true;
}

private ListNode middle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

private ListNode reverse(ListNode head) {
    ListNode sentinel = new ListNode(-999);
    while (head != null) {
        sentinel.next = new ListNode(head.val, sentinel.next);
        head = head.next;
    }
    return sentinel.next;
}
```

### 中间节点 + 前段链表反转 + 比较

- 快慢指针查找中间节点的时候，就顺便把前半段链表反转，这样节省一次循环时间
- 注意节点个数为奇数和偶数时候的区别

```java
public boolean isPalindrome(ListNode head) {
    ListNode reverse = new ListNode(-999); // reverse的结果
    ListNode fast = head;
    ListNode slow = head;
    // 区分奇数和偶数
    while (fast != null && fast.next != null) {
        reverse.next = new ListNode(slow.val, reverse.next); //反转链表
        slow = slow.next;
        fast = fast.next.next;
        // 区分奇数和偶数的区别
        if (fast != null && fast.next == null) {//奇数
            slow = slow.next;// 移动一下
        }
    }

    ListNode p = reverse.next;
    while (p != null) {
        if (slow.val != p.val) {
            return false;
        }
        slow = slow.next;
        p = p.next;
    }
    return true;
}
```



## 链表判环

![image-20231128210507790](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231128210507790.png)

### 😎[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

- 快慢指针
- 如果fast能追上slow，则说明有环

```java
public boolean hasCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow) {
            return true;
        }
    }
    return false;
}
```

### 😡[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

- 第一次相遇后，慢指针回到起点，快指针保持不变
- 快慢指针，每次走一个
- 再次相遇时，就是环的入口

```java
public ListNode detectCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    boolean flag = false; // 环标识
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow) {
            flag = true;
            slow = head;
            break;
        }
    }

    if (flag) {
        // 有环逻辑
        while (fast != slow) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;

    } else {
        return null;
    }
}
```

## 😎[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

### Hash

- 链表节点存入Hash中，然后判断

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    Set<ListNode> hash = new HashSet<>();
    ListNode pA = headA;
    while (pA != null) {
        hash.add(pA);
        pA = pA.next;
    }

    ListNode pB = headB;
    while (pB != null) {
        if (!hash.add(pB)) {
            return pB;
        }
        pB = pB.next;
    }

    return null;
}
```

