数组各元素是连续存储的，链表不是

------

# 单向链表

## 1. ListNode

```java
public class ListNode {
    int val;
    ListNode next;

    public ListNode(int val) {
        this.val = val;
    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

```java
public interface SingleListInter {
    void addFirst(int val);

    void addLast(int val);

    void loop(Consumer<Integer> consumer);

    int get(int index);

    void remove(int index);

    void insert(int index, int val);
}
```

## 2. 不带哨兵

![image-20231123132950873](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231123132950873.png)

```java
package com.citi.node;

import java.util.function.Consumer;

public class SingleListNoDummy implements SingleListInter {
    ListNode head = null;

    @Override
    public void addFirst(int val) {
        head = new ListNode(val, head);
    }

    @Override
    public void addLast(int val) {
        ListNode last = getLast();
        if (last == null) {
            addFirst(val);
            return;
        }
        last.next = new ListNode(val);
    }

    private ListNode getLast() {
        if (head == null) {
            return null;
        } // 要单独考虑head为空的情况
        ListNode p = head;
        while (p.next != null) {
            p = p.next;
        }
        return p;
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        ListNode p = head;
        while (p != null) {
            consumer.accept(p.val);
            p = p.next;
        }
    }

    @Override
    public int get(int index) {
        ListNode node = getByIndex(index);
        if (node == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        return node.val;
    }

    private ListNode getByIndex(int index) {
        int curIndex = 0;
        ListNode p = head;
        while (p != null) {
            if (index == curIndex) {
                return p;
            }
            curIndex++;
            p = p.next;
        }

        return null;
    }

    @Override
    public void remove(int index) {

    }

    /*找上一个结点*/
    @Override
    public void insert(int index, int val) {
        if (index == 0) {
            addFirst(val);
            return;
        }
        ListNode prev = getByIndex(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        prev.next = new ListNode(val, prev.next);
    }
}
```

## 3. 哨兵实现

- dummy元素充当哨兵节点，方便链表为空的情况
- 有些场景指针可以从sentinel移动，有些可以从sentinel.next移动

![image-20231004182312899](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004182312899.png)

```java
public class SingleList implements SingleListInter {
    ListNode sentinel = new ListNode(-888, null);

    @Override
    public void addFirst(int val) {
        sentinel.next = new ListNode(val, sentinel.next);
    }

    @Override
    public void addLast(int val) {
        ListNode last = findLastNode();
        last.next = new ListNode(val);
    }

   // 哨兵可能作为lastNode
    private ListNode findLastNode() {
        ListNode p = sentinel;
        while (p.next != null) {
            p = p.next;
        }
        return p;
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        ListNode p = sentinel.next;
        while (p != null) {
            consumer.accept(p.val);
            p = p.next;
        }
    }

    @Override
    public int get(int index) {
        ListNode result = getNode(index);
        if (result == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        return result.val;
    }

    /*-1能够拿到哨兵节点*/
    private ListNode getNode(int index) {
        ListNode p = sentinel;
        int idx = -1;
        while (p != null) {
            if (index == idx) {
                return p;
            }
            p = p.next;
            idx++;
        }
        return null;
    }

    @Override
    public void remove(int index) {
        ListNode preNode = getNode(index - 1);
        ListNode removedNode = getNode(index);
        if (preNode == null || removedNode == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        preNode.next = removedNode.next;
    }

    @Override
    public void insert(int index, int val) {
        ListNode preNode = getNode(index - 1);
        if (preNode == null) {
            throw new IllegalArgumentException("Wrong Index");
        }
        ListNode inserted = new ListNode(val, preNode.next);
        preNode.next = inserted;
    }
}
```

## 4. 性能

```bash
# 时间复杂度
# 随机访问
- 根据index查找  O(n)

# 插入
- 插入本身的是 O(1),  但是首先要根据index遍历找到插入位置，也就是O(n)
- 总体就是O(n)
    # 起始位置：O(1)
    # 结束为止：如果已知尾结点，是O(1), 否则就是O(n)
    # 中间位置： O(n)+O(1)=O(n)
```



# 双向链表

- 带头哨兵和尾哨兵的双向链表

![image-20231004191925877](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004191925877.png)

## 1. ListNode

- 主要好处：可以逆序遍历，快速找到最后的结点

```java
class Node {
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

## 2. 双向链表

```java
class DoublyLinkedList {
    Node head;
    Node tail;

    public DoublyLinkedList() {
        head = new Node(Integer.MIN_VALUE, null, null);
        tail = new Node(Integer.MIN_VALUE, null, null);
        head.next = tail;
        tail.prev = head;
    }

    public void addFirst(int val) {
        insert(0, val);
    }

    public void insert(int index, int val) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = prev.next;

        /*新节点*/
        Node inserted = new Node(val, prev, next);
        prev.next = inserted;
        next.prev = inserted;
    }

    public void remove(int index) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        Node removed = prev.next;
        if (removed == tail) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    public void addLast(int val) {
        Node prev = tail.prev;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;

        inserted.next = tail;
        tail.prev = inserted;
    }

    public void removeLast() {
        Node removed = tail.prev;
        if (removed == head) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = removed.prev;
        prev.next = tail;
        tail.prev = prev;
    }

    private Node getNode(int index) {
        int currentIndex = -2; // head节点的索引是-1
        Node pointer = head;
        while (pointer != tail) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

## 3. 环形链表

- 只有一个头哨兵

![image-20231005150947772](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231005150947772.png)

```java
class Node{
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

```java
class CrossDoublyLinkedList {
    Node sentinel;

    /*一开始的时候，哨兵结点的prev和next都指向本身自己*/
    public CrossDoublyLinkedList() {
        sentinel = new Node(Integer.MIN_VALUE, null, null);
        sentinel.prev = sentinel;
        sentinel.next = sentinel;
    }

    public void addFirst(int val) {
        Node prev = sentinel;
        Node next = sentinel.next;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;
        inserted.next = next;
        next.prev = inserted;
    }

    public void addLast(int val) {
        Node last = sentinel.prev;
        Node inserted = new Node(val, null, null);

        inserted.next = sentinel;
        sentinel.prev = inserted;
        last.next = inserted;
        inserted.prev = last;
    }

    public void removeFirst() {
        Node removed = sentinel.next;
        if (removed == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        sentinel.next = next;
        next.prev = sentinel;
    }

    public void removeLast() {
        Node last = sentinel.prev;
        if (last == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = last.prev;
        prev.next = sentinel;
        sentinel.prev = prev;
    }

    public void removeByVal(int val) {
        Node removed = findByVal(val);
        if (removed == null) {
            throw new IllegalArgumentException("No Target Found");
        }

        Node prev = removed.prev;
        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    private Node findByVal(int val) {
        Node pointer = sentinel.next;
        while (pointer != sentinel) {
            if (val == pointer.val) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }

}
```

# LeetCode

- 默认每个题目中都是给一个head，可以在方法里面添加哨兵

## 😎 链表遍历

### 迭代

```java
public void loop(ListNode head) {
    ListNode sentinel = new ListNode(-999, head);
    ListNode p = sentinel.next;
    while (p != null) {
        System.out.println(p.val);
        p = p.next;
    }
}
```

### 递归

```java
public void loop(ListNode head) {
    if (head == null) {
        return;
    }
    System.out.println(head.val);
    loop(head.next);
}
```

![image-20231125185211680](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231125185211680.png)



## 反转链表

### 😎[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

#### 迭代+新链表值

- 取出旧链表的每个节点的值，头插到新链表
- 原来链表不动

```java
public ListNode reverseList(ListNode head) {
    ListNode resultSentinel = new ListNode(-999, null);
    ListNode sentinel = new ListNode(-999, head);
    ListNode p = sentinel.next;
    while (p != null) {
        resultSentinel.next = new ListNode(p.val, resultSentinel.next);
        p = p.next;
    }
    return resultSentinel.next;
}
```

#### 迭代+新链表节点

- 原来链表每次移除头元素，头插到新链表
- 操作完成后，旧链表旧没有数据了
- 不会创造新的节点

```java
public ListNode reverseList(ListNode head) {
    ListNode resultSentinel = new ListNode(-999, null);

    while (head != null) {
        ListNode el = head;
        el.next = null;
      
        head = head.next;     // 旧链表后移

        el.next = resultSentinel.next;
        resultSentinel.next = el;
    }
    return resultSentinel.next;
}
```

#### 迭代+冒泡

```bash
# 步骤
1. 得到head的下一个元素
2. 将下一个元素从链表中删除(head的next指向下下一个)
3. 删除元素节点先孤立起来，next指向sentinel的next
4. sentinel的next指向删除元素
```

![image-20231125174046699](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231125174046699.png)

```java
public ListNode reverseList(ListNode head) {
    if (head == null) {
        return null;
    }
    ListNode sentinel = new ListNode(-999, head);
    while (head.next != null) {
        ListNode rise = head.next;
        head.next = head.next.next;

        rise.next = null;
        rise.next = sentinel.next;
        sentinel.next = rise;
    }
    return sentinel.next;
}
```

#### 递归

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head; 
    }
    ListNode last = reverseList(head.next);
    head.next.next = head;  // 逆转指针
    head.next = null;     // 断环
    return last;
}
```

![image-20231126115717309](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231126115717309.png)



## 😎[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

### 迭代 + 新链表

- 比较两个链表，谁小就把谁的值给新链表，新链表指针和小的链表指针后移

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode sentinel = new ListNode(-888);
    ListNode p = sentinel;
    ListNode p1 = list1;
    ListNode p2 = list2;

    while (p1 != null && p2 != null) {
        if (p1.val < p2.val) {
            p.next = new ListNode(p1.val);
            p1 = p1.next;
        } else {
            p.next = new ListNode(p2.val);
            p2 = p2.next;
        }
        p = p.next;
    }
    p.next = p1 == null ? p2 : p1;
    return sentinel.next;
}
```

### 递归-TODO



## 删除元素

### 😎[203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)-ByValue

#### 迭代

```java
public ListNode removeElements(ListNode head, int val) {
    ListNode sentinel = new ListNode(-888, head);
    ListNode prev = sentinel;
    ListNode p = sentinel.next;
    while (p != null) {
        if (p.val != val) {
            prev = p;
        } else {
            prev.next = p.next;
        }
        p = p.next;
    }
    return sentinel.next;
}
```

#### 递归

```java
public ListNode removeElements(ListNode head, int val) {
    if (head == null) {
        return null;
    }

    if (head.val == val) {
        return removeElements(head.next, val);
    } else {
        head.next = removeElements(head.next, val);
        return head;
    }
}
```



### 😎[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

#### 迭代



## 

```java
public ListNode removeElements(ListNode head, int val) {
    ListNode sentinel = new ListNode(-888, head);
    ListNode p = sentinel.next;
    ListNode prev = sentinel;

    while (p != null) {
        if (p.val == val) {
            prev.next = p.next; // 相等时不移动prev
        } else {
            prev = p; // 不等时移动prev
        }
        p = p.next;
    }
    return sentinel.next;
}
```

## 😡[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

### 正序遍历

- 第一次遍历，得到要删除的结点的索引
- 第二次遍历，删除指定的结点

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode sentinel = new ListNode(-888, head);
    int length = 0;
    ListNode p = sentinel.next;
    /*1. 第一次遍历，计算长度*/
    while (p != null) {
        length++;
        p = p.next;
    }
    int removedIndex = length - n;
    /*2. 第二次遍历，删除指定索引的元素, removedIndex-1*/
    ListNode removedNode = getByIndex(removedIndex, sentinel);
    ListNode prevNode = getByIndex(removedIndex - 1, sentinel);
    prevNode.next = removedNode.next;
    return sentinel.next;
}

private ListNode getByIndex(int index, ListNode sentinel) {
    int idx = -1;
    ListNode p = sentinel;
    while (p != null) {
        if (idx == index) {
            return p;
        }
        idx++;
        p = p.next;
    }
    return null;
}
```

### 快慢指针

![image-20231008115435110](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231008115435110.png)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode sentinel = new ListNode(-888, head);
    ListNode slow = sentinel;
    ListNode fast = sentinel;
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }
    while (fast.next != null) {
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;
    return sentinel.next;
}
```



## 😎[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

### 两次迭代

- 第一遍找到中间索引
- 第二次找到中间结点

```java
public ListNode middleNode(ListNode head) {
    /*第一次遍历：找到中间索引*/
    ListNode sentinel = new ListNode(-999, head);
    ListNode p = sentinel.next;
    int index = -1;
    while (p != null) {
        index++;
        p = p.next;
    }

    int middleIndex = (index + 1) / 2;

    /*第二次遍历*/
    ListNode p1 = sentinel.next;
    int idx = -1;
    while (p1 != null) {
        idx++;
        if (idx == middleIndex) {
            return p1;
        }
        p1 = p1.next;
    }
    return null;
}
```

### 快慢指针

- 慢指针每次移动一个，快指针每次移动2个
- 快指针指向null时，慢指针的当前位置

![image-20231009154523418](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231009154523418.png)

```java
public ListNode middleNode(ListNode head) {
    ListNode sentinel = new ListNode(-999, head);
    ListNode slow = sentinel;
    ListNode fast = sentinel;
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
        if (fast != null) {
            fast = fast.next;
        }
    }
    return slow;
}
```



## 其他题目

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode fast = sentinel;
    ListNode slow = sentinel;
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }

    while (fast.next != null) {
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;
    return sentinel.next;
}
```

#### 有序去重

- 重复元素保留一个

##### pre+current

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode pre = sentinel;
    ListNode current = sentinel.next;
    while (current != null) {
        if (pre.val == current.val) {
            pre.next = current.next;
        } else {
            pre = pre.next;
        }
        current = current.next;
    }
    return sentinel.next;
}
```

#### 有序去重

- 重复元素删除

##### p1+p2+p3

![image-20231009110239365](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231009110239365.png)

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode p1 = sentinel;
    ListNode p2 = p1.next;
    ListNode p3 = p2.next;

    while (p3 != null) {
        if (p3.val != p2.val) {
            p1 = p2;
            p2 = p3;
            p3 = p3.next;
        } else {
            while (p3 != null && p3.val == p2.val) {
                p3 = p3.next;
            }
            p1.next = p3;
            p2 = p3;
            if (p3 != null) {
                p3 = p3.next;
            }
        }
    }
    return sentinel.next;
}
```











```java
    public ListNode middleNode(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
        ListNode fast = sentinel;
        ListNode slow = sentinel;
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
            if (fast != null){
                fast = fast.next;
            }
        }
        return slow;
    }
```
