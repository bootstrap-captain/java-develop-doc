# æ•°æ®ç»“æ„

- å †æ˜¯ä¸€ç§ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œå¯ä»¥é€šè¿‡æ•°ç»„çš„æ–¹å¼å®ç°

## 1. å¤§é¡¶å †/å°é¡¶å †

- å°é¡¶å †å’Œå¤§é¡¶å †åŸºæœ¬é€»è¾‘ç±»ä¼¼
- ä¸‹é¢ä»¥<font color=orange>å¤§é¡¶å †</font>ä½œä¸ºç¤ºä¾‹

```bash
# å¤§é¡¶å †ï¼š ä»»æ„èŠ‚ç‚¹éƒ½å°äºå…¶çˆ¶èŠ‚ç‚¹
# å°é¡¶å †ï¼š ä»»æ„èŠ‚ç‚¹éƒ½å¤§äºå…¶çˆ¶èŠ‚ç‚¹
- å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹å…³ç³»ä¸å®š

# ç´¢å¼•åŸåˆ™ï¼šç´¢å¼•0å¼€å§‹å­˜å‚¨ï¼Œiè¡¨ç¤ºç´¢å¼•
- èŠ‚ç‚¹içš„çˆ¶èŠ‚ç‚¹ï¼š       floor((i-1)/2)      å½“iå¤§äº0æ—¶
- èŠ‚ç‚¹içš„å·¦å­èŠ‚ç‚¹ä¸ºï¼š    2i+1                ç»“æœä¸èƒ½å¤§äºsize
- èŠ‚ç‚¹içš„å³å­èŠ‚ç‚¹ä¸ºï¼š    2i+2                ç»“æœä¸èƒ½å¤§äºsize
```

![image-20231023190718489](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023190718489.png)

### 1.1 offer

```bash
# offerï¼š æ–°å…ƒç´ ï¼ŒåŠ å…¥åˆ°æ•°ç»„æœ«å°¾(sizeå±æ€§)

# upï¼šä¸æ–­æ¯”è¾ƒæ–°åŠ å…ƒç´ ä¸å…¶çˆ¶èŠ‚ç‚¹çš„å€¼
- çˆ¶èŠ‚ç‚¹æ›´å°ï¼Œåˆ™äº¤æ¢çˆ¶å­èŠ‚ç‚¹ï¼Œç»§ç»­å‘ä¸Šæ‰¾parent
- ç›´åˆ°çˆ¶èŠ‚ç‚¹å€¼æ›´å¤§
```

![image-20231208105006994](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231208105006994.png)

### 1.2 poll

```bash
# pollï¼š åˆ é™¤å †é¡¶å¤„çš„å…ƒç´ 
- 1. å †é¡¶å…ƒç´  å’Œæœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢
- 2. åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ 
- 3. å¯¹å †é¡¶å…ƒç´ è¿›è¡Œä¸‹æ½œ

# ä¸‹æ½œï¼š æ¯”å·¦å³å­©å­æœ€å¤§çš„å°
- æ¯”è¾ƒå½“å‰èŠ‚ç‚¹çš„å€¼å’Œå·¦å³å­©å­çš„å€¼
- å¦‚æœå½“å‰èŠ‚ç‚¹çš„å€¼æ¯”å·¦å³å­©å­æœ€å¤§çš„å°ï¼Œåˆ™äº¤æ¢
```

### 1.3 heapify

- å¯¹ä¸€ä¸ªéšæœºæ•°ç»„è¿›è¡Œå †åŒ–

```bash
# å¯¹ç°æœ‰æ•°ç»„è¿›è¡Œé‡æ’
- æ‰¾åˆ°æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹
- ä»åå‘å‰ï¼Œå¯¹æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œä¸‹æ½œï¼ˆæ¯”è¾ƒå·¦å³å€¼ï¼‰

# éå¶å­èŠ‚ç‚¹
- æ²¡æœ‰ä»»ä½•ä¸€ä¸ªå·¦å­©å­æˆ–è€…å³å­©å­
- æœ€åä¸€ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹
```

![image-20231023152506251](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023152506251.png)

```java
package com.citi.stack;

public class MaxHeap {
    int[] arr;
    int size;

    public MaxHeap(int[] arr) {
        this.arr = arr;
        this.size = arr.length;
        heapfiy();
    }

    private void heapfiy() {
        // æœ€åä¸€ä¸ªéå¶å­ç»“ç‚¹
        int nonLeafIndex = (size / 2) - 1;
        for (int i = nonLeafIndex; i >= 0; i--) {
            downRecur(i);
        }
    }

    /*down-é€’å½’å®ç°*/
    private void downRecur(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        int maxIndex = parentIndex;
        // å¤§é¡¶å †å’Œå°é¡¶å †çš„å®ç°ï¼šåªéœ€è¦æ”¹å˜ç¬¦å·å³å¯
        if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
            maxIndex = leftChildIndex;
        }

        if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
            maxIndex = rightChildIndex;
        }

        // é€’å½’ç»“æŸæ¡ä»¶
        if (parentIndex != maxIndex) {
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            downRecur(parentIndex);
        }
    }

    /*down-è¿­ä»£å®ç°*/
    private void downIterator(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        while (true) {
            int maxIndex = parentIndex;
            if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
                maxIndex = leftChildIndex;
            }

            if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
                maxIndex = rightChildIndex;
            }

            if (maxIndex == parentIndex) { // ç»ˆæ­¢
                break;
            }
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            leftChildIndex = parentIndex * 2 + 1;
            rightChildIndex = parentIndex * 2 + 2;
        }
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 2. æ•°ç»„å®ç°

- ä¸‹æ½œæ“ä½œï¼Œå¯ä»¥é€šè¿‡è¿­ä»£å’Œé€’å½’ä¸¤ç§å®ç°

```java
abstract class AbstractHeap {
    int[] arr;
    int size;

    public abstract boolean offer(int val);

    public abstract int poll();

    public abstract int peek();

    public boolean isFull() {
        return size == arr.length;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    protected void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 2.1 MaxHeap

```java
class MaxHeap extends AbstractHeap {

    public MaxHeap(int capacity) {
        this.arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[size] = val;
        upIter(size);
        size++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        int result = arr[0];
        swap(0, size - 1);
        size--;
        downIter(0);
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return arr[0];
    }

    /*ä¸Šæµ®é€’å½’å®ç°*/
    private void upRecur(int childIndex) {
        int parentIndex = (childIndex - 1) / 2;
        if (arr[childIndex] > arr[parentIndex]) {
            swap(childIndex, parentIndex);
            childIndex = parentIndex;
            upRecur(childIndex);
        }
    }

    /*ä¸Šæµ®è¿­ä»£å®ç°*/
    private void upIter(int childIndex) {
        // parentIndexæœ€ç»ˆå¯èƒ½å’ŒchildIndexéƒ½èµ°åˆ°0å¹¶ä¸”ç›¸ç­‰
        int parentIndex = (childIndex - 1) / 2;
        while (arr[childIndex] > arr[parentIndex]) {
            swap(parentIndex, childIndex);
            childIndex = parentIndex;
            parentIndex = (childIndex - 1) / 2;
        }
    }

    /*ä¸‹æ½œé€’å½’å®ç°*/
    private void downRecur(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        int maxIndex = parentIndex;

        if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
            maxIndex = leftChildIndex;
        }
        if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
            maxIndex = rightChildIndex;
        }

        /*é€’å½’æ¡ä»¶ï¼šåæ–¹å‘*/
        if (maxIndex != parentIndex) {
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            downRecur(parentIndex);
        }
    }

    /*ä¸‹æ½œè¿­ä»£å®ç°*/
    private void downIter(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;

        while (true) {
            int maxIndex = parentIndex;
            if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
                maxIndex = leftChildIndex;
            }
            if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
                maxIndex = rightChildIndex;
            }

            if (maxIndex == parentIndex) {
                break;
            }

            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            leftChildIndex = parentIndex * 2 + 1;
            rightChildIndex = parentIndex * 2 + 2;
        }
    }
}
```

### 2.2 MinHeap

- é€»è¾‘åŸºæœ¬ç›¸åŒ

```java
class MinHeap extends AbstractHeap {
    public MinHeap(int capacity) {
        this.arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[size] = val;
        upIter(size);
        size++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        int result = arr[0];
        swap(0, size - 1);
        size--;
        downIter(0);
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return arr[0];
    }

    /*ä¸Šæµ®é€’å½’å®ç°*/
    private void upRecur(int childIndex) {
        int parentIndex = (childIndex - 1) / 2;
        if (arr[childIndex] < arr[parentIndex]) {
            swap(childIndex, parentIndex);
            childIndex = parentIndex;
            upRecur(childIndex);
        }
    }

    /*ä¸Šæµ®è¿­ä»£å®ç°*/
    private void upIter(int childIndex) {
        // parentIndexæœ€ç»ˆå¯èƒ½å’ŒchildIndexéƒ½èµ°åˆ°0å¹¶ä¸”ç›¸ç­‰
        int parentIndex = (childIndex - 1) / 2;
        while (arr[childIndex] < arr[parentIndex]) {
            swap(parentIndex, childIndex);
            childIndex = parentIndex;
            parentIndex = (childIndex - 1) / 2;
        }
    }

    /*ä¸‹æ½œé€’å½’å®ç°*/
    private void downRecur(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        int minIndex = parentIndex;

        if (leftChildIndex < size && arr[leftChildIndex] < arr[minIndex]) {
            minIndex = leftChildIndex;
        }
        if (rightChildIndex < size && arr[rightChildIndex] < arr[minIndex]) {
            minIndex = rightChildIndex;
        }

        if (minIndex != parentIndex) {
            swap(parentIndex, minIndex);
            parentIndex = minIndex;
            downRecur(parentIndex);
        }
    }

    /*ä¸‹æ½œè¿­ä»£å®ç°*/
    private void downIter(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;

        while (true) {
            int minIndex = parentIndex;
            if (leftChildIndex < size && arr[leftChildIndex] < arr[minIndex]) {
                minIndex = leftChildIndex;
            }
            if (rightChildIndex < size && arr[rightChildIndex] < arr[minIndex]) {
                minIndex = rightChildIndex;
            }

            if (minIndex == parentIndex) {
                break;
            }

            swap(parentIndex, minIndex);
            parentIndex = minIndex;
            leftChildIndex = parentIndex * 2 + 1;
            rightChildIndex = parentIndex * 2 + 2;
        }
    }
}
```

## 3. JDK-PriorityQueue

### 3.1 JDK

- é»˜è®¤æ¯”è¾ƒå™¨ï¼šå°é¡¶å †

```java
PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> (b - a));      // å¤§é¡¶å †
PriorityQueue<Integer> min = new PriorityQueue<>((a, b) -> (a - b));      // å°é¡¶å †

PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>((a, b) -> a.val - b.val); // å¤§é¡¶å †
PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>((a, b) -> a.val - b.val); // å°é¡¶å †
```

```java
/*å»ºç«‹æ¯”è¾ƒè§„åˆ™*/
PriorityQueue<Map.Entry<String, Integer>> minHeap =
        new PriorityQueue<>(new Comparator<Map.Entry<String, Integer>>() {
            @Override
            public int compare(Map.Entry<String, Integer> a, Map.Entry<String, Integer> b) {
                if (!a.getValue().equals(b.getValue())) {
                    return a.getValue() - b.getValue();
                } else {
                    // æŒ‰ç…§å­—å…¸è¡¨
                    return a.getKey().charAt(0) - b.getKey().charAt(0);
                }
            }
        });
```



### 3.2 è‡ªå®šä¹‰

```java
class ErickHeap {
    int[] arr;
    boolean isMinHeap;

    int size;

    /*é»˜è®¤æ„å»ºå°é¡¶å †*/
    public ErickHeap(int capacity, boolean isMinHeap) {
        this.isMinHeap = isMinHeap;
        arr = new int[capacity];
    }

    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[size] = val;
        up(size);
        size++;
        return true;
    }

    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        int result = arr[0];
        swap(0, size - 1);
        down(); // downçš„æ—¶å€™æ³¨æ„ï¼šsizeå½“å‰è¿˜æ²¡å‡
        size--;
        return result;
    }

    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return arr[0];
    }

    public boolean isFull() {
        return size == arr.length;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    /*å †åº•å…ƒç´ ä¸Šæµ®*/
    private void up(int childIndex) {
        int parentIndex = (childIndex - 1) / 2; // parentIndexå¯èƒ½å’ŒchildIndexéƒ½å˜ä¸º0
        if (isMinHeap) {
            while (arr[childIndex] < arr[parentIndex]) {
                swap(parentIndex, childIndex);
                childIndex = parentIndex;
                parentIndex = (childIndex - 1) / 2;
            }
        } else {
            while (arr[childIndex] > arr[parentIndex]) {
                swap(parentIndex, childIndex);
                childIndex = parentIndex;
                parentIndex = (childIndex - 1) / 2;
            }
        }
    }

    /*å †é¡¶å…ƒç´ ä¸‹æ½œ*/
    private void down() {
        int parentIndex = 0;
        int leftIndex = parentIndex * 2 + 1;
        int rightIndex = parentIndex * 2 + 2;
        if (isMinHeap) {
            while (true) {
                int minIndex = parentIndex;
                if (leftIndex < size - 1 && arr[leftIndex] < arr[minIndex]) {
                    minIndex = leftIndex;
                }
                if (rightIndex < size - 1 && arr[rightIndex] < arr[minIndex]) {
                    minIndex = rightIndex;
                }
                if (minIndex == parentIndex) {
                    break;
                }
                swap(parentIndex, minIndex);
                parentIndex = minIndex;
                leftIndex = parentIndex * 2 + 1;
                rightIndex = parentIndex * 2 + 2;
            }
        } else {
            while (true) {
                int maxIndex = parentIndex;
                if (leftIndex < size-1 && arr[leftIndex] > arr[maxIndex]) {
                    maxIndex = leftIndex;
                }
                if (rightIndex < size-1 && arr[rightIndex] > arr[maxIndex]) {
                    maxIndex = rightIndex;
                }
                if (maxIndex == parentIndex) {
                    break;
                }
                swap(parentIndex, maxIndex);
                parentIndex = maxIndex;
                leftIndex = parentIndex * 2 + 1;
                rightIndex = parentIndex * 2 + 2;
            }
        }
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```



# Ké—®é¢˜

- å‡¡æ˜¯æ¶‰åŠåˆ°æŒ‰ç…§æŸç§è§„åˆ™æ±‚ç¬¬Kçš„é—®é¢˜ï¼Œéƒ½å¯ä»¥è€ƒè™‘å †

## TOP-K

- å°é¡¶å †

```bash
- 1.æ„å»ºå¤§å°ä¸ºkçš„å°é¡¶å †
- 2.å †æ»¡åï¼Œæ–°å…ƒç´ å¦‚æœæ¯”å †é¡¶å¤§ï¼Œå¼¹å‡ºå †é¡¶ï¼Œå¹¶æ·»åŠ æ–°å…ƒç´ 

# å †é¡¶å…ƒç´ ï¼šå †ä¸­æœ€å°çš„ï¼Œå³ç¬¬Kå¤§çš„
```

### âœ… [703. æ•°æ®æµä¸­çš„ç¬¬ K å¤§å…ƒç´ ](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)

```java
class KthLargest {

    private PriorityQueue<Integer> minHeap = new PriorityQueue<>();

    private int capacity;

    public KthLargest(int k, int[] nums) {
        this.capacity = k;
        for (int i = 0; i < nums.length; i++) {
            add(nums[i]);
        }
    }

    public int add(int val) {
        if (minHeap.size() < capacity) {
            minHeap.offer(val);
        } else {
            if (val > minHeap.peek()) {
                minHeap.poll();
                minHeap.offer(val);
            }
        }

        return minHeap.peek();
    }
}
```

### ğŸ˜ [215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

```java
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    for (int i = 0; i < k; i++) {
        minHeap.offer(nums[i]);
    }

    for (int i = k; i < nums.length; i++) {
        if (nums[i] > minHeap.peek()) {
            minHeap.poll();
            minHeap.offer(nums[i]);
        }
    }

    return minHeap.peek();
}
```

### ğŸ˜ [2583. äºŒå‰æ ‘ä¸­çš„ç¬¬ K å¤§å±‚å’Œ](https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/)

- å…ˆæ±‚å‡ºå±‚åºçš„å’Œï¼Œç„¶ååˆ©ç”¨å°é¡¶å †è¿›è¡Œæ’åº

```java
public long kthLargestLevelSum(TreeNode root, int k) {
    List<Long> layerSums = getLayerSums(root, k);
    if (k > layerSums.size()) {
        return -1L;
    }
    return getMaxK(layerSums, k);
}

/*BFS: è·å–æ¯å±‚å’Œ*/
private List<Long> getLayerSums(TreeNode root, int k) {
    List<Long> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    int currentLayerSize = 1;

    while (!queue.isEmpty()) {
        int nextLayerResult = 0;
        long sum = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            sum += poll.val;

            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerResult++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerResult++;
            }
        }
        currentLayerSize = nextLayerResult;
        result.add(sum);
    }
    return result;
}

private long getMaxK(List<Long> sums, int k) {
    PriorityQueue<Long> minHeap = new PriorityQueue<>();
    /*å‘æ”¾Kä¸ªå…ƒç´ è¿›å»*/
    for (int i = 0; i < k; i++) {
        minHeap.offer(sums.get(i));
    }

    for (int i = k; i < sums.size(); i++) {
        if (sums.get(i) > minHeap.peek()) {
            minHeap.poll();
            minHeap.offer(sums.get(i));
        }
    }
    return minHeap.peek();
}
```

### ğŸ˜ [347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/)

- éå†æ•´ä¸ªæ•°ç»„ï¼Œæ•°å­—ä½œä¸ºkeyï¼Œé¢‘æ¬¡ä½œä¸ºvalueï¼ŒåŠ å…¥åˆ°hashä¸­

```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> hash = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];
        if (!hash.containsKey(num)) {
            hash.put(num, 1);
        } else {
            hash.put(num, hash.get(num) + 1);
        }
    }

    PriorityQueue<Map.Entry<Integer, Integer>> minHeap =
            new PriorityQueue<>(new Comparator<Map.Entry<Integer, Integer>>() {
                @Override
                public int compare(Map.Entry<Integer, Integer> a, Map.Entry<Integer, Integer> b) {
                    return a.getValue() - b.getValue();
                }
            });

    for (Map.Entry<Integer, Integer> entry : hash.entrySet()) {
        minHeap.offer(entry);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
    }

    int[] result = new int[minHeap.size()];
    int idx = 0;
    while (!minHeap.isEmpty()) {
        result[idx] = minHeap.poll().getKey();
        idx++;
    }
    return result;
}
```

### ğŸ˜ [692. å‰Kä¸ªé«˜é¢‘å•è¯](https://leetcode.cn/problems/top-k-frequent-words/)

```java
public List<String> topKFrequent(String[] words, int k) {
    Map<String, Integer> hash = new HashMap<>();

    for (int i = 0; i < words.length; i++) {
        String word = words[i];
        if (!hash.containsKey(word)) {
            hash.put(word, 1);
        } else {
            hash.put(word, hash.get(word) + 1);
        }
    }

    /*å»ºç«‹æ¯”è¾ƒè§„åˆ™*/
    PriorityQueue<Map.Entry<String, Integer>> minHeap =
            new PriorityQueue<>(new Comparator<Map.Entry<String, Integer>>() {
                @Override
                public int compare(Map.Entry<String, Integer> a, Map.Entry<String, Integer> b) {
                    if (!a.getValue().equals(b.getValue())) { // å€¼ä¸åŒï¼Œåˆ™æŒ‰ç…§å€¼è¿”å›
                        return a.getValue() - b.getValue();
                    } else {
                        // æŒ‰ç…§å­—å…¸è¡¨, å€ŸåŠ©String
                        return b.getKey().compareTo(a.getKey());
                    }
                }
            });

    /*åŠ å…¥åˆ°minHeapä¸­*/
    for (Map.Entry<String, Integer> entry : hash.entrySet()) {
        minHeap.offer(entry);
        if (minHeap.size() > k) {
            minHeap.poll();
        }
    }

    /*å †å†…å…ƒç´ å°±æ˜¯topK*/
    List<String> result = new ArrayList<>();
    while (!minHeap.isEmpty()) {
        result.add(0, minHeap.poll().getKey());
    }
    return result;
}
```

## BOTTOM-K

- å¤§é¡¶å †

### ğŸ˜ [973. æœ€æ¥è¿‘åŸç‚¹çš„ K ä¸ªç‚¹](https://leetcode.cn/problems/k-closest-points-to-origin/)

```java
public int[][] kClosest(int[][] points, int k) {
    PriorityQueue<int[]> maxHeap = new PriorityQueue<>(new Comparator<int[]>() {
        @Override
        public int compare(int[] a, int[] b) {
            if (getDistance(a) > getDistance(b)) {
                return -1;
            } else {
                return 1;
            }
        }
    });

    for (int i = 0; i < points.length; i++) {
        maxHeap.offer(points[i]);
        if (maxHeap.size() > k) {
            maxHeap.poll();
        }
    }

    int[][] result = new int[maxHeap.size()][2];
    int idx = 0;
    while (!maxHeap.isEmpty()) {
        result[idx] = maxHeap.poll();
        idx++;
    }

    return result;
}

private double getDistance(int[] point) {
    return Math.sqrt(Math.pow(point[0], 2) + Math.pow(point[1], 2));
}
```

## ğŸ˜ [264. ä¸‘æ•° II](https://leetcode.cn/problems/ugly-number-ii/)

### å°é¡¶å † + Hash

```bash
# æ€è·¯
- æ¯æ¬¡pollå‡ºçš„å…ƒç´ ï¼Œå°±æ˜¯å½“å‰æœ€å°çš„ï¼Œä¸€å…±poll næ¬¡ï¼Œå°±æ˜¯ç¬¬nä¸ªä¸‘æ•°
- æ¯æ¬¡pollçš„æ—¶å€™ï¼Œå°†2*pollï¼Œ3*pollï¼Œ5*pollåŠ å…¥åˆ°å°é¡¶å †ä¸­ï¼Œ æ·»åŠ æ—¶è¦ç”¨hashæ¥è¿›è¡Œå»é‡,é¿å…å †ä¸­å‡ºç°é‡å¤å…ƒç´ 

# ç¼ºç‚¹
- å°é¡¶å †ä¸­ä¼šç»´æŠ¤å¤šä½™è¦æ±‚nçš„ä¸‘æ•°
```

```java
public int nthUglyNumber(int n) {
    Set<Long> hash = new HashSet<>();
    PriorityQueue<Long> minHeap = new PriorityQueue<>();
    minHeap.offer(1L);
    hash.add(1L);

    long result = 0;
    for (int i = 0; i < n; i++) {
        result = minHeap.poll();
        if (hash.add(result * 2)) {
            minHeap.offer(result * 2);
        }

        if (hash.add(result * 3)) {
            minHeap.offer(result * 3);
        }

        if (hash.add(result * 5)) {
            minHeap.offer(result * 5);
        }
    }
    return (int) result;
}
```



# å¤§é¡¶å †

## ğŸ˜ [451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº](https://leetcode.cn/problems/sort-characters-by-frequency/)

```java
public String frequencySort(String s) {
    char[] chs = s.toCharArray();
    Map<Character, Integer> hash = new HashMap<>();


    for (int i = 0; i < chs.length; i++) {
        char ch = chs[i];
        if (!hash.containsKey(ch)) {
            hash.put(ch, 1);
        } else {
            hash.put(ch, hash.get(ch) + 1);
        }
    }

    PriorityQueue<Map.Entry<Character, Integer>> minHeap =
            new PriorityQueue<>((a, b) -> (b.getValue() - a.getValue()));

    for (Map.Entry<Character, Integer> entry : hash.entrySet()) {
        minHeap.offer(entry);
    }

    StringBuilder sb = new StringBuilder();
    while (!minHeap.isEmpty()) {
        Map.Entry<Character, Integer> poll = minHeap.poll();
        for (int i = 0; i < poll.getValue(); i++) {
            sb.append(poll.getKey());
        }
    }
    return sb.toString();
}
```

# ğŸ›³ [295. æ•°æ®æµçš„ä¸­ä½æ•°](https://leetcode.cn/problems/find-median-from-data-stream/)

## å¤§é¡¶å † + å°é¡¶å †

```bash
# æ€è·¯ï¼šæ„å»ºä¸€ä¸ªå¤§é¡¶å †ï¼Œä¸€ä¸ªå°é¡¶å †ï¼Œå¤§é¡¶å †çš„å †é¡¶å…ƒç´ å°äºå°é¡¶å †çš„å †é¡¶å…ƒç´ 
      -- å¤§é¡¶å †æ•°æ®ï¼šä¸­ä½æ•°çš„å‰åŠéƒ¨åˆ†
      -- å°é¡¶å †æ•°æ®ï¼šä¸­ä½æ•°çš„ååŠéƒ¨åˆ†
# add
- ä¸¤è¾¹ä¸ªæ•°ä¸€æ ·æ—¶ï¼Œå·¦è¾¹ä¸ªæ•°åŠ ä¸€
- ä¸¤è¾¹ä¸ªæ•°ä¸ä¸€æ ·æ—¶ï¼Œå³è¾¹ä¸ªæ•°åŠ ä¸€

# addè§„åˆ™
- å·¦è¾¹ä¸ªæ•°åŠ ä¸€æ“ä½œï¼šæŠŠæ–°å…ƒç´ æ·»åŠ åœ¨å³ï¼Œå¼¹å‡ºå³è¾¹å †é¡¶å…ƒç´ åŠ å…¥å·¦è¾¹
- å³è¾¹é€»è¾‘ç±»ä¼¼
```

![image-20231029104600488](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029104600488.png)

```java
class MedianFinder {

    private PriorityQueue<Integer> leftMax = new PriorityQueue<>((a, b) -> (b - a));

    private PriorityQueue<Integer> rightMin = new PriorityQueue<>((a, b) -> (a - b));

    public MedianFinder() {
    }

    public void addNum(int num) {
        if (leftMax.size() == rightMin.size()) {
            // å·¦ä¸ªæ•°å¢åŠ é€»è¾‘
            rightMin.offer(num);
            Integer poll = rightMin.poll();
            leftMax.offer(poll);
        } else {
            // å³ä¸ªæ•°å¢åŠ é€»è¾‘
            leftMax.offer(num);
            Integer poll = leftMax.poll();
            rightMin.offer(poll);
        }
    }

    public double findMedian() {
        if (rightMin.size() == leftMax.size()) {
            return (leftMax.peek() + rightMin.peek()) / 2D;
        } else {
            return leftMax.peek();
        }
    }
}
```

