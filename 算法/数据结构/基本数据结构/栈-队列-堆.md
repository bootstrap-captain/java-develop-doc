# 栈

- 只能从数据结构的一端进行操作，先进后出

![image-20231016113311031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016113311031.png)

```java
package com.citi.stack;

public interface MyStack {
    boolean push(int val);

    int pop();

    int peek();

    boolean isEmpty();

    boolean isFull();
}
```

## 1. 链表实现

- 单向带哨兵链表，头插头出

![image-20231016115640568](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016115640568.png)

```java
package com.citi.stack;

import java.util.NoSuchElementException;

public class LinkedListStack implements MyStack {
    class Node {
        int val;
        Node next;

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    Node sentinel = new Node(-999, null);
    int size;
    int capacity;

    public LinkedListStack(int capacity) {
        this.capacity = capacity;
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        sentinel.next = new Node(val, sentinel.next);
        size++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        Node removed = sentinel.next;
        sentinel.next = removed.next;
        size--;
        return removed.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return sentinel.next.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

## 2. 数组实现

![image-20231202101646696](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231202101646696.png)

```java
package com.citi.stack;

import java.util.NoSuchElementException;

public class ArrayStack implements MyStack {
    int[] arr;

    int top = 0;

    public ArrayStack(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        arr[top] = val;
        top++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        int result = arr[top - 1];
        arr[top - 1] = -999;
        top--;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return arr[top - 1];
    }

    @Override
    public boolean isEmpty() {
        return top == 0;
    }

    @Override
    public boolean isFull() {
        return top == arr.length;
    }
}
```

## 3. 栈-队列转换

### 😎[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

- 出的时候，先把当前的outStack中出完，再去倒手

![image-20231018120502207](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231018120502207.png)

```java
import java.util.LinkedList;
import java.util.NoSuchElementException;

class MyQueue {

    LinkedList<Integer> inStack = new LinkedList<>();
    LinkedList<Integer> outStack = new LinkedList<>();

    int size = 0;


    public MyQueue() {
    }

    public void push(int x) {
        inStack.push(x);
        size++;
    }

    public int pop() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }

        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        size--;
        return outStack.pop();
    }

    public int peek() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }

        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.peek();
    }

    public boolean empty() {
        return size == 0;
    }
}
```

### 😎[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

![image-20231202135602075](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231202135602075.png)

```java
import java.util.LinkedList;
import java.util.NoSuchElementException;

class MyStack {

    LinkedList<Integer> queue = new LinkedList<>();

    public MyStack() {
    }

    public void push(int x) {
        queue.push(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.push(queue.pop());
        }
    }

    public int pop() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return queue.pop();
    }

    public int top() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return queue.peek();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

## 😎 [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

### 栈

- 遍历字符串，如果左边符号，则入栈另一半字符；
- 如果右边，则出栈并比较

```java
public boolean isValid(String s) {
    LinkedList<Character> stack = new LinkedList<>();
    char[] chs = s.toCharArray();

    if (chs.length % 2 != 0) {
        return false;
    }
    for (char ch : chs) {
        if (ch == '{') {
            stack.push('}');
        } else if (ch == '[') {
            stack.push(']');
        } else if (ch == '(') {
            stack.push(')');
        } else {
            if (stack.isEmpty()) {
                return false;
            }
            if (stack.pop()!=ch){
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

## 逆波兰表达式

### 😡[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

- <font color=orange>后缀表达式</font>：运算符号在数字的后面，这样就不用考虑优先级问题
- JVM的运算指令就是这么玩的

#### 栈

- 碰见符号就把前面两个数字弹出栈
- 运算完成后重新入栈

```java
public int evalRPN(String[] tokens) {
      LinkedList<Integer> stack = new LinkedList<>();
      for (String token : tokens) {
          // 处理具体逻辑
          Integer second;
          Integer first;
          switch (token) {
              case "+":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first + second);
                  break;
              case "-":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first - second);
                  break;
              case "*":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first * second);
                  break;
              case "/":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first / second);
                  break;
              default:
                  stack.push(Integer.valueOf((token)));
          }
      }
      return stack.pop();
  }
```

### 😡中缀转后缀-无括号

- 给一个中缀表达式，将其转换为后缀表达式

![image-20231202132427456](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231202132427456.png)

```java
/*中缀表达式转后缀*/
public String convert(String str) {
    LinkedList<Character> stack = new LinkedList<>();
    StringBuffer sb = new StringBuffer();
    char[] chs = str.toCharArray();

    for (char ch : chs) {
        if (priority(ch) == -1) {  // 1. 不是运算符，则直接拼接
            sb.append(ch);
        } else {                   // 2. 是运算符
            if (stack.isEmpty()) {
                stack.push(ch);           // 2.1 栈如果为空，则直接添加
            } else {                      // 2.2 栈不空，判断
                if (priority(ch) <= priority(stack.peek())) {
                    while (!stack.isEmpty() && stack.peek() >= priority(ch)) {
                        sb.append(stack.pop());
                    }
                }
                stack.push(ch);
            }
        }
    }
    //3. 处理完成后，把栈里的元素依次出栈拼接
    while (!stack.isEmpty()) {
        sb.append(stack.pop());
    }
    return sb.toString();
}

private int priority(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 0;
        case '*':
        case '/':
            return 1;
        default:
            return -1;
    }
}
```

# 队列

## 1. 普通队列

- 尾进数据，头出数据
- 622题目

```java
package com.citi.queue;

interface MyQueue {

    /*尾插*/
    boolean offer(int val);

    /*头弹，队列为空，队列为空，返回null*/
    int poll();

    /*获取头元素，不弹出来，队列为空，返回null*/
    int peek();

    boolean isEmpty();

    boolean isFull();
}
```

### 链表实现

- 可以使用单向环形带哨兵的链表来实现队列

![image-20231129130253403](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231129130253403.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class LinkedListQueue implements MyQueue {

    class Node {
        int val;
        Node next;

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    Node sentinel = new Node(-999);
    Node head; // head不会移动
    Node tail; // tail移动
    int size = 0;
    int capacity;

    public LinkedListQueue(int capacity) {
        this.capacity = capacity;
        sentinel.next = sentinel;
        head = sentinel;
        tail = sentinel;
    }

    /*尾插*/
    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val);
        inserted.next = sentinel;
        tail.next = inserted;
        tail = tail.next;
        size++;
        return true;
    }

    /*删除sentinel后面的第一个元素: 要考虑只剩下一个节点的情况*/
    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        Node removed = sentinel.next;
        sentinel.next = sentinel.next.next;
        size--;
        // 最后一个元素的时候，考虑下
        if (isEmpty()) {
            tail = sentinel;
        }
        return removed.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return sentinel.next.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        if (size == capacity) {
            return true;
        }
        return false;
    }
}
```

### 环形数组

- 相比普通数组，起点和终点更加自由，不用考虑数据移动
- 环形数组，就是在数组长度固定的情况下，定义一定的可用索引范围，通过覆盖写来进行
- 数组性能更佳
- 可以用三种不同的实现来做
- 下一个索引位置：head = (head +1)%arr.length，每次计算索引，都必须通过这个公式，而不能使用++或者--

#### 空位置

- 空位置是移动的，是head后面的一个元素
- 浪费了一个索引位置来进行判满
- 上一个元素位置 tail = (tail+(arr.length-1))%arr.length, 用来获取尾部元素，防止数组越界

![image-20231205211525773](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231205211525773.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArrayFirstQueue implements MyQueue {

    int[] arr;

    int head = 0;

    int tail = 0;

    public ArrayFirstQueue(int capacity) {
        this.arr = new int[capacity + 1]; // 空位置要保存数据
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length; // tail向后移动一次
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head];
        arr[head] = -999; // 可以不覆盖写
        head = (head + 1) % arr.length;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head];
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    /*tail+1=head*/
    @Override
    public boolean isFull() {
        return head == (tail + 1) % arr.length;
    }
}
```

#### 新增size

- 新增一个size变量，来判断队列是空还是满

![image-20231130103618498](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231130103618498.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArraySecondQueue implements MyQueue {
    int[] arr;

    int size;

    int head = 0;
    int tail = 0;

    public ArraySecondQueue(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        size++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head];
        arr[head] = -999; // 可以不覆盖写
        head = (head + 1) % arr.length;
        size--;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}
```

#### head/tail自增

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算
- 没有size属性

##### 模运算

![image-20231014110521963](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110521963.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArrayThirdQueue implements MyQueue {
    int[] arr;
    int head = 0;
    int tail = 0;

    public ArrayThirdQueue(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[(tail) % arr.length] = val;
        tail++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head % arr.length];
        arr[head % arr.length] = -999; // 可以不覆盖
        head++;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head % arr.length];
    }

    @Override
    public boolean isEmpty() {
        return tail == head;
    }

    @Override
    public boolean isFull() {
        return tail - head == arr.length;
    }
}
```

##### 位运算

- 假如数组的head和tail一直增加，那么当超过int的最大值的时候，计算出来的索引就是负，就会报错
- 当数组长度是2的n次方的时候，计算索引的时候，求模运算可以用位运算来代替

```bash
# 求模运算 vs 按位与
# 前提：除数是 2 的  n  次方

# 结果： head&(arr.length-1)
```

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArrayFourthQueue implements MyQueue{
    int[] arr;
    int head = 0;
    int tail = 0;

    public ArrayFourthQueue(int capacity) {
        arr = new int[capacity];
    }

    /*该用位运算
    1. 可以解决索引超过int范围问题
    2. 位运算更快*/
    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[(tail) & (arr.length - 1)] = val;
        tail++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head & (arr.length - 1)];
        arr[head & (arr.length - 1)] = -999; // 可以不覆盖
        head++;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head & (arr.length - 1)];
    }

    @Override
    public boolean isEmpty() {
        return tail == head;
    }

    /*不用担心越界问题*/
    @Override
    public boolean isFull() {
        return tail - head == arr.length;
    }
}
```

## 2. 双端队列

- 两端都可以进行删除，添加
- Deque: Double Ended Queue
- 641题目

```java
package com.citi.deque;

interface MyDequeue {
    boolean offerFirst(int val);

    boolean offerLast(int val);

    int pollFirst();

    int pollLast();

    int peekFirst();

    int peekLast();

    boolean isEmpty();

    boolean isFull();
}
```

### 链表实现

- 双向环形链表，带头指针

![image-20231203111932930](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231203111932930.png)

```java
import java.util.NoSuchElementException;

public class LinkedDequeue implements MyDequeue {

    Node sentinel = new Node(-999);

    int size;
    int capacity;


    public LinkedDequeue(int capacity) {
        this.capacity = capacity;
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
    }


    @Override
    public boolean offerFirst(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val);
        size++;
        // 插入结点：维护两个指针
        inserted.prev = sentinel;
        inserted.next = sentinel.next;
        // 维护前后
        sentinel.next.prev = inserted;
        sentinel.next = inserted;
        return true;
    }

    @Override
    public boolean offerLast(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val);
        size++;
        // 插入结点：维护两个指针
        inserted.prev = sentinel.prev;
        inserted.next = sentinel;
        // 维护前后
        sentinel.prev.next = inserted;
        sentinel.prev = inserted;
        return true;
    }

    @Override
    public int pollFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        Node removed = sentinel.next;
        // 只需要维护两个指针
        sentinel.next = sentinel.next.next;
        sentinel.next.prev = sentinel;
        size--;
        return removed.val;
    }

    @Override
    public int pollLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        Node removed = sentinel.prev;
        // 只需要维护两个指针
        sentinel.prev.prev.next = sentinel;
        sentinel.prev = sentinel.prev.prev;
        size--;
        return removed.val;
    }

    @Override
    public int peekFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return sentinel.next.val;
    }

    @Override
    public int peekLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return sentinel.prev.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

```java
class Node {
    int val;
    Node prev;
    Node next;

    public Node(int val) {
        this.val = val;
    }

    public Node(Node prev, int val, Node next) {
        this.prev = prev;
        this.val = val;
        this.next = next;
    }
}
```

### 环形数组

#### 空位置

#### 新增size

![image-20231205225124108](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231205225124108.png)

```java
package com.citi.deque;

import java.util.NoSuchElementException;

public class SecondArrayDequeue implements MyDequeue {

    int[] arr;

    int size;

    int head;

    int tail;

    public SecondArrayDequeue(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean offerFirst(int val) {
        if (isFull()) {
            return false;
        }
        // 索引减一的处理
        head = (head + arr.length - 1) % arr.length;
        arr[head] = val;
        size++;
        return true;
    }

    @Override
    public boolean offerLast(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        size++;
        return true;
    }

    @Override
    public int pollFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Dequeue");
        }
        int result = arr[head];
        arr[head] = -999;
        head = (head + 1) % arr.length;
        size--;
        return result;
    }

    @Override
    public int pollLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Dequeue");
        }

        tail = (tail + arr.length - 1) % arr.length; // 减1
        int result = arr[tail];
        arr[tail] = -999;
        size--;
        return result;
    }

    @Override
    public int peekFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Dequeue");
        }
        return arr[(head % arr.length)];
    }

    @Override
    public int peekLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Dequeue");
        }
        return arr[(tail + arr.length - 1) % arr.length];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}
```

#### head/tail自增

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算
- 没有size属性

## 3. 优先级队列

- 数组的对象多了一个优先级的属性
- 入队是尾部插入
- 出队时，优先级高的先出来

```java
public interface PriorityQueue {
    boolean offer(Entry entry);

    Entry poll();

    Entry peek();

    boolean isEmpty();

    boolean isFull();
}
```

```java
class Entry {
    int value;
    int priority;

    public Entry(int value, int priority) {
        this.value = value;
        this.priority = priority;
    }
}
```

### 无序数组--size

![image-20231206131751397](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231206131751397.png)

```java
package com.citi.priorityqueue;

import java.util.NoSuchElementException;

public class ArrayPriorityQueue implements PriorityQueue {

    Entry[] arr;
    int size;

    @Override
    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        arr[size] = entry;
        size++;
        return false;
    }

    @Override
    public Entry poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int targetIndex = selectMaxPriorityIndex();
        Entry removedEntry = arr[targetIndex];
        remove(targetIndex);
        return removedEntry;
    }

    @Override
    public Entry peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int targetIndex = selectMaxPriorityIndex();
        return arr[targetIndex];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }

    /*寻找优先级最高的元素*/
    private int selectMaxPriorityIndex() {
        int maxIndex = -1;
        int priority = Integer.MIN_VALUE;
        for (int i = 0; i < size; i++) {
            Entry entry = arr[i];
            if (entry.priority > priority) {
                maxIndex = i;
            }
        }
        return maxIndex;
    }

    /*删除元素*/
    private void remove(int index) {
        if (index == size - 1) { // 队列最后一个元素
            arr[index] = null;
        } else { // 复制拷贝
            System.arraycopy(arr, index + 1, arr, index, size - 1 + index);
            arr[size - 1] = null;
        }
        size--;
    }
}
```

### 有序数组实现

- 插入时候进行插入排序，弹出时，只需要弹出数尾部的元素

![image-20231022103506620](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231022103506620.png)

```java
class SortedArrayPriorityQueue {
    private Entry[] arr;

    private int capacity;
    private int size;

    public SortedArrayPriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        insert(entry);
        return true;
    }

    /*插入排序*/
    private void insert(Entry entry) {
        int p = size - 1;
        while (p > 0 && arr[p].priority > entry.priority) {
            arr[p + 1] = arr[p];
            p--;
        }
        arr[p + 1] = entry;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        Entry entry = arr[size - 1];
        arr[size - 1] = null;
        return entry;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        return arr[size - 1];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```

### 堆实现

- 基于数组形式的堆实现

# 堆 - 优先队列

- 堆是一种优先级队列，可以通过数组的方式实现

## 1. 大顶堆/小顶堆

- 小顶堆和大顶堆基本逻辑类似
- 下面以<font color=orange>大顶堆</font>作为示例

```bash
# 大顶堆： 任意节点都小于其父节点
# 小顶堆： 任意节点都大与其父节点
- 左节点和右节点关系不定

# 索引原则：索引0开始存储，i表示索引
- 节点i的父节点：       floor((i-1)/2)      当i大于0时
- 节点i的左子节点为：    2i+1                结果不能大于size
- 节点i的右子节点为：    2i+2                结果不能大于size
```

![image-20231023190718489](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023190718489.png)

```java
package com.citi.heap;

public interface MaxHeap {
    /*头尾交换，并下潜*/
    int poll();

    void down(int parent);

    /*尾部添加：并上浮*/
    boolean offer(int data);

    void up(int child);

    boolean isFull();

    boolean isEmpty();
  
    int size();
}
```

### 1.1 offer

```bash
# offer： 新元素，加入到数组末尾(size属性)

# up：不断比较新加元素与其父节点的值
- 父节点更小，则交换父子节点，继续向上找parent
- 直到父节点值更大
```

![image-20231208105006994](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231208105006994.png)

### 1.2 poll

```bash
# poll： 删除堆顶处的元素
- 1. 堆顶元素 和最后一个元素交换
- 2. 删除最后一个元素
- 3. 对堆顶元素进行下潜

# 下潜： 比左右孩子最大的小
- 比较当前节点的值和左右孩子的值
- 如果当前节点的值比左右孩子最大的小，则交换
```

### 1.3 heapify

- 对一个随机数组进行堆化

```bash
# 对现有数组进行重排
- 找到最后一个非叶子节点
- 从后向前，对每个节点执行下潜（比较左右值）

# 非叶子节点
- 没有任何一个左孩子或者右孩子
- 最后一个元素的父节点
```

![image-20231023152506251](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023152506251.png)

```java
package com.citi.stack;

public class MaxHeap {
    int[] arr;
    int size;

    public MaxHeap(int[] arr) {
        this.arr = arr;
        this.size = arr.length;
        heapfiy();
    }

    private void heapfiy() {
        // 最后一个非叶子结点
        int nonLeafIndex = (size / 2) - 1;
        for (int i = nonLeafIndex; i >= 0; i--) {
            downRecur(i);
        }
    }

    /*down-递归实现*/
    private void downRecur(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        int maxIndex = parentIndex;
        // 大顶堆和小顶堆的实现：只需要改变符号即可
        if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
            maxIndex = leftChildIndex;
        }

        if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
            maxIndex = rightChildIndex;
        }

        // 递归结束条件
        if (parentIndex != maxIndex) {
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            downRecur(parentIndex);
        }
    }

    /*down-迭代实现*/
    private void downIterator(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        while (true) {
            int maxIndex = parentIndex;
            if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
                maxIndex = leftChildIndex;
            }

            if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
                maxIndex = rightChildIndex;
            }

            if (maxIndex == parentIndex) { // 终止
                break;
            }
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            leftChildIndex = parentIndex * 2 + 1;
            rightChildIndex = parentIndex * 2 + 2;
        }
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 2. 数组实现

- 下潜操作，可以通过迭代和递归两种实现

```java
abstract class AbstractHeap {
    int[] arr;
    int size;

    public abstract boolean offer(int val);

    public abstract int poll();

    public abstract int peek();

    public boolean isFull() {
        return size == arr.length;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    protected void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 2.1 MaxHeap

```java
class MaxHeap extends AbstractHeap {

    public MaxHeap(int capacity) {
        this.arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[size] = val;
        upIter(size);
        size++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        int result = arr[0];
        swap(0, size - 1);
        size--;
        downIter(0);
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return arr[0];
    }

    /*上浮递归实现*/
    private void upRecur(int childIndex) {
        int parentIndex = (childIndex - 1) / 2;
        if (arr[childIndex] > arr[parentIndex]) {
            swap(childIndex, parentIndex);
            childIndex = parentIndex;
            upRecur(childIndex);
        }
    }

    /*上浮迭代实现*/
    private void upIter(int childIndex) {
        // parentIndex最终可能和childIndex都走到0并且相等
        int parentIndex = (childIndex - 1) / 2;
        while (arr[childIndex] > arr[parentIndex]) {
            swap(parentIndex, childIndex);
            childIndex = parentIndex;
            parentIndex = (childIndex - 1) / 2;
        }
    }

    /*下潜递归实现*/
    private void downRecur(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        int maxIndex = parentIndex;

        if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
            maxIndex = leftChildIndex;
        }
        if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
            maxIndex = rightChildIndex;
        }

        /*递归条件：反方向*/
        if (maxIndex != parentIndex) {
            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            downRecur(parentIndex);
        }
    }

    /*下潜迭代实现*/
    private void downIter(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;

        while (true) {
            int maxIndex = parentIndex;
            if (leftChildIndex < size && arr[leftChildIndex] > arr[maxIndex]) {
                maxIndex = leftChildIndex;
            }
            if (rightChildIndex < size && arr[rightChildIndex] > arr[maxIndex]) {
                maxIndex = rightChildIndex;
            }

            if (maxIndex == parentIndex) {
                break;
            }

            swap(parentIndex, maxIndex);
            parentIndex = maxIndex;
            leftChildIndex = parentIndex * 2 + 1;
            rightChildIndex = parentIndex * 2 + 2;
        }
    }
}
```

### 2.2 MinHeap

- 逻辑基本相同

```java
class MinHeap extends AbstractHeap {
    public MinHeap(int capacity) {
        this.arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[size] = val;
        upIter(size);
        size++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        int result = arr[0];
        swap(0, size - 1);
        size--;
        downIter(0);
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return arr[0];
    }

    /*上浮递归实现*/
    private void upRecur(int childIndex) {
        int parentIndex = (childIndex - 1) / 2;
        if (arr[childIndex] < arr[parentIndex]) {
            swap(childIndex, parentIndex);
            childIndex = parentIndex;
            upRecur(childIndex);
        }
    }

    /*上浮迭代实现*/
    private void upIter(int childIndex) {
        // parentIndex最终可能和childIndex都走到0并且相等
        int parentIndex = (childIndex - 1) / 2;
        while (arr[childIndex] < arr[parentIndex]) {
            swap(parentIndex, childIndex);
            childIndex = parentIndex;
            parentIndex = (childIndex - 1) / 2;
        }
    }

    /*下潜递归实现*/
    private void downRecur(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;
        int minIndex = parentIndex;

        if (leftChildIndex < size && arr[leftChildIndex] < arr[minIndex]) {
            minIndex = leftChildIndex;
        }
        if (rightChildIndex < size && arr[rightChildIndex] < arr[minIndex]) {
            minIndex = rightChildIndex;
        }

        if (minIndex != parentIndex) {
            swap(parentIndex, minIndex);
            parentIndex = minIndex;
            downRecur(parentIndex);
        }
    }

    /*下潜迭代实现*/
    private void downIter(int parentIndex) {
        int leftChildIndex = parentIndex * 2 + 1;
        int rightChildIndex = parentIndex * 2 + 2;

        while (true) {
            int minIndex = parentIndex;
            if (leftChildIndex < size && arr[leftChildIndex] < arr[minIndex]) {
                minIndex = leftChildIndex;
            }
            if (rightChildIndex < size && arr[rightChildIndex] < arr[minIndex]) {
                minIndex = rightChildIndex;
            }

            if (minIndex == parentIndex) {
                break;
            }

            swap(parentIndex, minIndex);
            parentIndex = minIndex;
            leftChildIndex = parentIndex * 2 + 1;
            rightChildIndex = parentIndex * 2 + 2;
        }
    }
}
```



```java
class ErickHeap {
    int[] arr;
    boolean isMinHeap;

    int size;

    /*默认构建小顶堆*/
    public ErickHeap(int capacity, boolean isMinHeap) {
        this.isMinHeap = isMinHeap;
        arr = new int[capacity];
    }

    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[size] = val;
        up(size);
        size++;
        return true;
    }

    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        int result = arr[0];
        swap(0, size - 1);
        down(); // down的时候注意：size当前还没减
        size--;
        return result;
    }

    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return arr[0];
    }

    public boolean isFull() {
        return size == arr.length;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    /*堆底元素上浮*/
    private void up(int childIndex) {
        int parentIndex = (childIndex - 1) / 2; // parentIndex可能和childIndex都变为0
        if (isMinHeap) {
            while (arr[childIndex] < arr[parentIndex]) {
                swap(parentIndex, childIndex);
                childIndex = parentIndex;
                parentIndex = (childIndex - 1) / 2;
            }
        } else {
            while (arr[childIndex] > arr[parentIndex]) {
                swap(parentIndex, childIndex);
                childIndex = parentIndex;
                parentIndex = (childIndex - 1) / 2;
            }
        }
    }

    /*堆顶元素下潜*/
    private void down() {
        int parentIndex = 0;
        int leftIndex = parentIndex * 2 + 1;
        int rightIndex = parentIndex * 2 + 2;
        if (isMinHeap) {
            while (true) {
                int minIndex = parentIndex;
                if (leftIndex < size - 1 && arr[leftIndex] < arr[minIndex]) {
                    minIndex = leftIndex;
                }
                if (rightIndex < size - 1 && arr[rightIndex] < arr[minIndex]) {
                    minIndex = rightIndex;
                }
                if (minIndex == parentIndex) {
                    break;
                }
                swap(parentIndex, minIndex);
                parentIndex = minIndex;
                leftIndex = parentIndex * 2 + 1;
                rightIndex = parentIndex * 2 + 2;
            }
        } else {
            while (true) {
                int maxIndex = parentIndex;
                if (leftIndex < size-1 && arr[leftIndex] > arr[maxIndex]) {
                    maxIndex = leftIndex;
                }
                if (rightIndex < size-1 && arr[rightIndex] > arr[maxIndex]) {
                    maxIndex = rightIndex;
                }
                if (maxIndex == parentIndex) {
                    break;
                }
                swap(parentIndex, maxIndex);
                parentIndex = maxIndex;
                leftIndex = parentIndex * 2 + 1;
                rightIndex = parentIndex * 2 + 2;
            }
        }
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 3. JDK-PriorityQueue

```java
PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> (b - a));      // 大顶堆
PriorityQueue<Integer> min = new PriorityQueue<>((a, b) -> (a - b));      // 小顶堆

PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>((a, b) -> a.val - b.val); // 大顶堆
PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>((a, b) -> a.val - b.val); // 小顶堆
```

## 4. LeetCode

- TOP-K问题，直接先想小顶堆

### 😡 [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

#### Hash + 小顶堆

- 遍历整个数组，数字作为key，频次作为value，假如到hash中
- 然后用小顶堆来处理

```java
public int[] topKFrequent(int[] nums, int k) {
      Map<Integer, Integer> hash = new HashMap<>();
      for (int i = 0; i < nums.length; i++) {
          if (hash.containsKey(nums[i])) {
              hash.put(nums[i], hash.get(nums[i]) + 1);
          } else {
              hash.put(nums[i], 1);
          }
      }

      PriorityQueue<Map.Entry<Integer, Integer>> minHeap = 
              new PriorityQueue<>(k, (a, b) -> (a.getValue() - b.getValue()));

      for (Map.Entry<Integer, Integer> entry : hash.entrySet()) {
          if (minHeap.size() < k) {
              minHeap.offer(entry);
          } else {
              if (minHeap.peek().getValue() < entry.getValue()) {
                  minHeap.poll();
                  minHeap.offer(entry);
              }
          }
      }

      int[] arr = new int[k];
      for (int i = 0; i < arr.length; i++) {
          arr[i] = minHeap.poll().getKey();
      }

      return arr;
  }
```





### 😎[703. 数据流中的第 K 大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)

#### 小顶堆

- 小顶堆(堆底元素就是第k大的)

```bash
- 1.构建大小为k的小顶堆
- 2.堆满后，新元素如果比堆顶小，则忽略，否则弹出堆顶，并添加新元素
```

```java
/*小顶堆*/
class KthLargest {

    private PriorityQueue<Integer> minHeap;

    private int capacity;

    /*把元素通过add方法添加进去即可*/
    public KthLargest(int k, int[] nums) {
        this.capacity = k;
        minHeap = new PriorityQueue<>(k);
        for (int num : nums) {
            add(num);
        }
    }

    /*add时，小顶堆不一定是满的哦*/
    public int add(int val) {
        /*堆满并且新元素比堆顶元素大*/
        if (minHeap.size() == capacity) {
            if (val > minHeap.peek()) {
                minHeap.poll();
                minHeap.offer(val);
            }
        } else {
            minHeap.offer(val);
        }
        return minHeap.peek();
    }
}
```

### 😡[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

#### 小顶堆

```bash
- 1. 将数组元素依次放入堆中，堆满后
    - 1.1 如果新元素比堆顶大，则offer
- 2. 返回堆顶元素 
```

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        /*小顶堆*/
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(3);
        /*offer进去k个元素*/
        for (int i = 0; i < k; i++) {
            minHeap.offer(nums[i]);
        }

        for (int i = k; i < nums.length; i++) {
            if (nums[i] > minHeap.peek()) {
                minHeap.poll();
                minHeap.offer(nums[i]);
            }
        }
        return minHeap.peek();
    }
}
```

### 😡[451. 根据字符出现频率排序](https://leetcode.cn/problems/sort-characters-by-frequency/)

#### Hash + 大顶堆

```java
public String frequencySort(String s) {
      char[] chs = s.toCharArray();
      Map<Character, Integer> hash = new HashMap<>();
      for (int i = 0; i < chs.length; i++) {
          if (hash.containsKey(chs[i])) {
              hash.put(chs[i], hash.get(chs[i]) + 1);
          } else {
              hash.put(chs[i], 1);
          }
      }

      PriorityQueue<Map.Entry<Character, Integer>> maxHep =
              new PriorityQueue<>((a, b) -> (b.getValue() - a.getValue()));

      for (Map.Entry<Character, Integer> entry : hash.entrySet()) {
          maxHep.offer(entry);
      }

      StringBuilder sb = new StringBuilder();
      while (maxHep.size() != 0) {
          Map.Entry<Character, Integer> poll = maxHep.poll();
          Character ch = poll.getKey();
          for (int i = 0; i < poll.getValue(); i++) {
              sb.append(ch);
          }
      }
      return sb.toString();
  }
```



### *️⃣[295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

#### 小顶堆 +大顶堆

```bash
# 思路：构建一个大顶堆，一个小顶堆，确保大顶堆的堆顶元素小于小顶堆的堆顶元素
      -- 大顶堆数据：中位数的前半部分
      -- 小顶堆数据：中位数的后半部分
# add
- 两边个数一样时，左边个数加一
- 两边个数不一样时，右边加一

# add规则
- 左添加时，把新元素添加在右，弹出右边堆顶元素加入左边
- 右边逻辑类似
```

![image-20231029104600488](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029104600488.png)

```java
import java.util.PriorityQueue;

class MedianFinder {

    private PriorityQueue<Integer> leftMax = new PriorityQueue<>((a, b) -> (b - a));
    private PriorityQueue<Integer> rightMin = new PriorityQueue<>((a, b) -> (a - b));

    public MedianFinder() {
    }

    public void addNum(int num) {
        if (leftMax.size() == rightMin.size()) { // 往左边大顶堆中添加数据
            rightMin.offer(num);
            leftMax.offer(rightMin.poll());
        } else {   // 往右边大顶堆中添加数据
            leftMax.offer(num);
            rightMin.offer(leftMax.poll());
        }
    }

    public double findMedian() {
        if (leftMax.size() == rightMin.size()) {
            return (double) (leftMax.peek() + rightMin.peek()) / 2;
        } else {
            return leftMax.peek();
        }
    }
}
```

### *️⃣ [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

#### 小顶堆

- 不用指定队列长度

```java
public ListNode mergeKLists(ListNode[] lists) {
  ListNode sentinel = new ListNode(-999, null);
  // 记录新链表的尾巴
  ListNode p = sentinel;
  PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>((a, b) -> a.val - b.val);
  // 第一次放入
  for (ListNode node : lists) {
      if (node != null) {
          minHeap.offer(node);
      }
  }

  // 当小顶堆有元素时
  while (!minHeap.isEmpty()) {
      ListNode poll = minHeap.poll();
      if (poll.next != null) { // 退出来的元素有后继，后继入队
          minHeap.offer((poll.next));
      }
      // 尾插，并移动结果的尾指针
      p.next = poll;
      poll.next = null;
      p = poll;
  }
  return sentinel.next;
}
```



# JDK-栈-队列(普通,双端)

## 1. LinkedList

- 底层是用链表实现
- 栈，普通队列，双端队列

## 2. ArrayDeque

- 底层用数组实现
- 栈，普通队列，双端队列



