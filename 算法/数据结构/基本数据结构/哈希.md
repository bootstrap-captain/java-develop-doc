# Hash

## 1. æ€æƒ³

![image-20231113094946264](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231113094946264.png)

- æ¯ä¸ªæ•°æ®åˆ†é…ä¸€ä¸ªkeyï¼Œæ”¾å…¥æ•°ç»„è¡¨æ ¼
- keyå’Œè¡¨æ ¼ç´¢å¼•çš„å…³ç³»ï¼Œå¯ä»¥é€šè¿‡keyæ¥å¿«é€ŸæŸ¥æ‰¾æ•°æ®

```bash
# æ•°æ®ç»“æ„
- å»ºç«‹ä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨æ‰€æœ‰çš„æ•°æ®
- æ¯ä¸ªæ•°æ®å®ä½“ï¼ŒåŒ…å«ä¸€ä¸ªkeyå’Œä¸€ä¸ªvalue
- é€šè¿‡keyæ¥æ˜ å°„åˆ°æ•°ç»„ç´¢å¼•ï¼Œç„¶åå°†æ•°æ®å­˜å‚¨åœ¨è¯¥ç´¢å¼•å¤„

# ç†æƒ³æƒ…å†µ
- æ¯ä¸ªæ•°æ®å®ä½“ï¼Œkeyå”¯ä¸€ï¼Œæ•°ç»„è¶³å¤Ÿå¤§ï¼Œèƒ½å­˜æ”¾æ‰€æœ‰æ•°æ®
- æ¯ä¸ªæ•°ç»„åªå­˜æ”¾ä¸€ä¸ªæ•°æ®

  # ä¼˜ç‚¹
  - æ—¶é—´å¤æ‚åº¦ä¸ºO(1)ï¼Œåªéœ€è¦æ ¹æ®keyæ‰¾åˆ°æ•°ç»„ç´¢å¼•ä½ç½®å³å¯
  # ç¼ºç‚¹
  - æ•°ç»„çš„å†…å­˜è¿ç»­ï¼Œå› æ­¤å¤§æ•°ç»„å¯¹å†…å­˜è¦æ±‚è‹›åˆ»

# æ‹‰é“¾æ³•åˆ™
- æœ‰é™é•¿åº¦çš„æ•°ç»„
- å…è®¸keyé‡å¤ï¼Œå…è®¸å¤šä¸ªkeyæ˜ å°„åŒä¸€ä¸ªç´¢å¼•
- ä¸€ä¸ªç´¢å¼•å¤„çš„æ•°æ®ï¼Œé€šè¿‡é“¾è¡¨æ¥è¿æ¥
- æ—¶é—´å¤æ‚åº¦ä¼šå¢åŠ 
```

```bash
# key(hash)
- æ•°æ®çš„keyï¼Œé€šè¿‡æŸç§è§„åˆ™ï¼Œå¯ä»¥æ˜ å°„åˆ°æ•°ç»„çš„æŸä¸ªç´¢å¼•ä¸Š
- å¦‚æœæ•°ç»„æŸä¸ªç´¢å¼•çš„å­˜å‚¨å…ƒç´ è¿‡å¤šï¼Œåˆ™éœ€è¦éå†é“¾è¡¨ï¼Œæ—¶é—´å¤æ‚åº¦å¢åŠ 

# hashç®—æ³•
- åœ¨æ·»åŠ æ•°æ®æ—¶ï¼Œç”¨æˆ·æ²¡åŠæ³•ä¿è¯keyçš„åˆ†æ•£æ€§ï¼Œå› æ­¤ä¸€èˆ¬ä¼šæ ¹æ®å…·ä½“çš„valueï¼Œæ¥ç”Ÿæˆä¸€ä¸ªå”¯ä¸€çš„keyï¼Œå³hash
```

## 2. å“ˆå¸Œç 

### 2.1 å“ˆå¸Œç®—æ³•

- å°†ä»»æ„é•¿åº¦çš„ä»»æ„æ•°æ®ï¼Œé€šè¿‡ç®—æ³•ï¼Œè½¬æ¢ä¸º<font color=orange>å›ºå®šé•¿åº¦æ•°æ®</font>ï¼Œè¿™ä¸ªå›ºå®šé•¿åº¦çš„æ•°æ®å°±æ˜¯hashå€¼
- MD5ï¼ŒSHA1ï¼ŒSHA256ï¼ŒSHA512ï¼Œ CRC32ç­‰
- è®¡ç®—hashå€¼æ—¶ï¼Œè€ƒè™‘åŸå§‹æ•°æ®çš„æ¯ä¸ªå­—èŠ‚ï¼Œä¸€æ—¦æ”¹åŠ¨åŸå§‹æ•°æ®çš„ä»»ä½•ä¸€ä¸ªå­—èŠ‚ï¼Œå¯¹åº”hashå€¼éƒ½ä¼šæœ‰æ˜æ˜¾ä¸åŒ
- æ‘˜å–äº†åŸå§‹æ•°æ®çš„ä¸€äº›ç‰¹å¾ï¼ŒæŸç§ç¨‹åº¦ä¸Šèƒ½ä»£è¡¨åŸå§‹æ•°æ®
- è¢«å¹¿æ³›ç”¨äºæ•°æ®å®Œæ•´æ€§æ ¡éªŒå’ŒåŠ å¯†æ–¹é¢

### 2.2 å®ç°æ–¹å¼

#### Object-hashCode

```java
/*åŒä¸€ä¸ªå¯¹è±¡çš„hashå€¼ç›¸åŒ*/
public void test01() {
    Object obj = new Object();
    for (int i = 0; i < 100; i++) {
        int result = obj.hashCode();
        System.out.println(result); // 757108857
    }
}

/*ä¸åŒå¯¹è±¡çš„hashå€¼ä¸åŒ*/
public void test02() {
    for (int i = 0; i < 100; i++) {
        Object obj = new Object();
        int result = obj.hashCode();
        System.out.println(result);
    }
}
```

#### æƒé‡Hash

- ä¸€ä¸ªå¯¹è±¡é‡Œé¢ï¼Œå¯¹äºä¸åŒçš„å­—æ®µï¼Œç»™äºˆä¸åŒçš„æƒé‡
- ç»éªŒè¡¨æ˜ï¼Œæƒé‡é€‰å–è´¨æ•°31ï¼Œå“ˆå¸Œå†²çªçš„æ¦‚ç‡æ¯”è¾ƒä½

```java
 /**
 * ä¸åŒçš„å­—æ®µï¼Œå…¶hashçš„æƒé‡ä¸åŒ
 * field1*31 + field2*31*31 + field3*31*31*31 +...
 *
 * @param objs
 * @return
 */
public static int getHash(Object... objs) {
    if (objs == null) {
        return 0;
    }

    int result = 1;
    for (Object obj : objs) {
        if (obj == null) {
            result = result * 31;
        } else {
            result = result * 31 + obj.hashCode();
        }
    }
    return result;
}
```

```java
 /**
   * ä¼˜åŒ–ï¼šä¹˜æ³•å˜æˆä½è¿ç®—
   *
   * @param objs
   * @return
   */
  public static int getHash(Object... objs) {
      if (objs == null) {
          return 0;
      }

      int result = 1;
      for (Object obj : objs) {
          if (obj == null) {
              result = result << 5 - result;
          } else {
              result = result << 5 - result + obj.hashCode();
          }
      }
      return result;
  }
```

#### MurmurHash

- å¿«é€Ÿè®¡ç®—ï¼šç›¸å¯¹äºå…¶ä»–å“ˆå¸Œå‡½æ•°ï¼Œå…·æœ‰æ›´å¿«çš„è®¡ç®—é€Ÿåº¦
- ä½ç¢°æ’ç‡ï¼šå¤„ç†ä¸€äº¿ä¸ªæ•°æ®ï¼Œæœ€å¤šåªæœ‰ä¸¤ä¸ªå†²çª
- éšæœºæ€§å¼ºï¼šèƒ½å¤Ÿå¾ˆå¥½çš„ä¿æŒæ•°æ®çš„éšæœºæ€§

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>32.1.2-jre</version>
</dependency>
```

```java
// å¯¹ä¸åŒç±»å‹æ•°æ®è¿›è¡Œhash
int i = Hashing.murmur3_32_fixed().hashInt(3).asInt();
```

## 4. HashTable

### 4.1 hash-indexæ˜ å°„

- æ ¹æ®å¯¹åº”çš„hash(intç±»å‹çš„å¤§çš„æ•°å­—ï¼Œæ ¹æ®æ•°ç»„é•¿åº¦æ¥æ±‚æ¨¡)
- æ•°ç»„é•¿åº¦ä¸º2çš„æ¬¡æ–¹æ—¶ï¼Œæ±‚æ¨¡å¯ä»¥è½¬æ¢ä¸ºä½è¿ç®—ï¼Œæ•ˆç‡æ›´é«˜

![image-20231113160711854](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231113160711854.png)

```java
private int getHash(Object key) {
    return key.hashCode();
}

/**
 * @param hash ï¼š æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¤§çš„éšæœºintæ•´æ•°
 */
private int getIndex(int hash) {
    return hash & table.length - 1;
}
```

### 4.2 resize

- å¦‚æœä¸æ·»åŠ resizeï¼Œåˆ™æœ€ç»ˆéšç€æ•°æ®è¶Šæ¥è¶Šå¤šï¼Œæ•°ç»„ä¸Šçš„é“¾è¡¨ä¹Ÿä¼šè¶Šæ¥è¶Šé•¿
- æ·»åŠ æ•°æ®å®Œæˆåï¼Œè¿›è¡Œresizeé€‚å½“æ‰©å®¹ï¼Œå°½å¯èƒ½ä¿è¯æ•°ç»„æ¯ä¸ªéƒ½åªå­˜æ”¾ä¸€ä¸ªå…ƒç´ 

```bash
# hashå†²çª (å³ä½¿å­˜åœ¨æ‰©å®¹)
- ä¸åŒçš„keyï¼Œæœ€ç»ˆå¾—åˆ°çš„hashä¸€æ ·ï¼Œå°±ä¼šå¾—åˆ°ç›¸åŒçš„index
- ä¸åŒçš„keyï¼Œhashè™½ç„¶ä¸åŒï¼Œä½†æ˜¯æ±‚å¾—åˆ°çš„indexæ˜¯ä¸€æ ·çš„

# æœ€ç»ˆç»“æœ
- æ•°ç»„çš„æŸäº›ä½ç½®ä¸Šï¼Œå…ƒç´ çš„ä¸ªæ•°è¶…è¿‡1
```

#### æ‹†åˆ†è§„å¾‹

- ä¸€ä¸ªé“¾è¡¨æœ€å¤šæ‹†æˆä¸¤ä¸ª
- hash & table.length==0çš„ä¸€ç»„
- hash & table.length!=0çš„ä¸€ç»„

### 4.4 put

```java
// keyé‡å¤ï¼Œåˆ™æ›´æ–°ï¼Œkeyä¸å­˜åœ¨ï¼Œåˆ™å°¾éƒ¨æ·»åŠ 
public void put(Object key, Object value) {
    int hash = getHash(key);
    int targetIndex = getIndex(hash);

    if (table[targetIndex] == null) {
        table[targetIndex] = new Entry(key, value);
    } else {// éå†å¯»æ‰¾
        Entry entry = table[targetIndex];
        while (entry != null) {
            if (entry.key.equals(key)) {
                entry.value = value; // æ›´æ–°
                return;
            }
            if (entry.next == null) {
                break;
            }
            entry = entry.next;
        }
        entry.next = new Entry(key, value);
    }

    size++;
    if (size > threshold) {
        resize();
    }
}
```

# LeetCode

## âœ…[1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum/)

- ç´¢å¼•ä½keyï¼Œå€¼ä¸ºnum

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> hash = new HashMap<>();
    int[] result = new int[2];
    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];
        if (hash.containsKey(target - num)) {
            result[0] = i;
            result[1] = hash.get(target - num);
            return result;
        } else {
            hash.put(num, i);
        }
    }
    return result;
}
```

## ğŸ˜[3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

### Hash

- abbaæƒ…å†µ

![image-20240103232253672](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240103232253672.png)

```java
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> hash = new HashMap<>();
    int start = 0;
    int end = 0;
    char[] chs = s.toCharArray();
    int max = 0;

    for (int i = 0; i < chs.length; i++) {
        char ch = chs[i];
        if (hash.containsKey(ch)) {
            Integer index = hash.get(ch);// å¾—åˆ°é‡å¤å…ƒç´ çš„ç´¢å¼•
            if (index >= start) {// é‡å¤å…ƒç´ çš„ç´¢å¼•å¿…é¡»å¤§äºç­‰äºstart
                start = index + 1;
            }
        }
        hash.put(ch, i); // æ›´æ–°ç´¢å¼•
        end++;
        max = Math.max(end - start, max);
    }
    return max;
}
```

## âœ…[217. å­˜åœ¨é‡å¤å…ƒç´ ](https://leetcode.cn/problems/contains-duplicate/)

### Hash

```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> hash = new HashSet<>();
    for (int i = 0; i < nums.length; i++) {
        if (hash.contains(nums[i])) {
            return true;
        }
        hash.add(nums[i]);
    }
    return false;
}
```

## âœ…[219. å­˜åœ¨é‡å¤å…ƒç´  II](https://leetcode.cn/problems/contains-duplicate-ii/)

### Hash

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer, Integer> hash = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];
        if (hash.get(num) != null && Math.abs(hash.get(num) - i) <= k) {
            return true;
        } else {
            hash.put(num, i);
        }
    }
    return false;
}
```

## âœ…[349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](https://leetcode.cn/problems/intersection-of-two-arrays/)

### Hash

```java
  public int[] intersection(int[] nums1, int[] nums2) {
      Set<Integer> result = new HashSet<>();

      Set<Integer> hash = new HashSet<>();
      for (int i = 0; i < nums1.length; i++) {
          hash.add(nums1[i]);
      }
      for (int i = 0; i < nums2.length; i++) {
          if (hash.contains(nums2[i])) {
              result.add(nums2[i]);
          }
      }

      int[] arr = new int[result.size()];
      int i = 0;
      for (Integer el : result) {
          arr[i] = el;
          i++;
      }
      return arr;
  }
```



## âœ…[706.HashMap](https://leetcode.cn/problems/design-hashmap/)

```java
class MyHashMap {

    /*æ•°æ®ä¼šä»¥Entryçš„å½¢å¼ï¼Œé€šè¿‡æ‹‰é“¾æ³•ï¼Œæ”¾åœ¨æ•°ç»„ä¸­*/
    static class Entry {
        Object key;
        Object value;

        Entry next;

        public Entry(Object key, Object value) {
            this.key = key;
            this.value = value;
        }
    }

    /*æ•°ç»„é•¿åº¦æ§åˆ¶æˆ2çš„næ¬¡æ–¹*/
    Entry[] table;

    public MyHashMap() {
        table = new Entry[16];
    }

    /*keyé‡å¤ï¼Œåˆ™è¦†ç›–ï¼Œkeyä¸é‡å¤ï¼Œåˆ™å°¾æ’*/
    public void put(int key, int value) {
        int index = getIndex(getHash(key)); // æ‰¾åˆ°æ•°ç»„å¯¹åº”çš„ç´¢å¼•ä½ç½®

        Entry entry = table[index];
        if (entry == null) {
            table[index] = new Entry(key, value);
            return;
        }

        /*ç›¸ç­‰åˆ™è¦†ç›–*/
        Entry tail = null;
        while (entry != null) {
            if (entry.key.equals(key)) {
                entry.value = value;
                return;
            }
            if (entry.next == null) {
                tail = entry;
            }
            entry = entry.next;
        }
        tail.next = new Entry(key, value);
    }

    /*æ ¹æ®keyæ¥è·å–: è·å–ä¸åˆ°çš„è¯ï¼Œåˆ™è¿”å›-1*/
    public int get(int key) {
        int index = getIndex(getHash(key));
        Entry entry = table[index];

        while (entry != null) {
            if (entry.key.equals(key)) {
                return (int) entry.value;
            }
            entry = entry.next;
        }
        return -1;
    }

    /*å¦‚æœå­˜åœ¨æ˜ å°„ï¼Œåˆ™åˆ é™¤*/
    public void remove(int key) {
        int index = getIndex(getHash(key));
        /*åˆ é™¤é“¾è¡¨ä¸€ä¸ªç»“ç‚¹*/
        Entry entry = table[index];
        Entry prev = null;

        while (entry != null) {
            if (entry.key.equals(key)) {
                if (prev == null) {
                    table[index] = entry.next; // é¦–ç»“ç‚¹å°±åŒ¹é…ä¸Šäº†
                } else {
                    prev.next = entry.next; // åé¢ç»“ç‚¹
                }
            }
            prev = entry;
            entry = entry.next;
        }
    }

    /*æ ¹æ®keyæ¥è·å–åˆ°å¯¹åº”çš„hashå€¼*/
    private int getHash(Object key) {
        return key.hashCode();
    }

    /*æ•°ç»„é•¿åº¦å¦‚æœæ˜¯2çš„næ¬¡æ–¹ï¼Œåˆ™å¯ä»¥é€šè¿‡ä½è¿ç®—ä»£æ›¿æ±‚æ¨¡è¿ç®—*/
    private int getIndex(int hash) {
        return hash & (table.length - 1);
    }
}
```

## ğŸ˜[146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)

- æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„ç§»é™¤

![image-20240103210023864](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240103210023864.png)

```bash
# åŒç«¯é“¾è¡¨ï¼šå¤´å…ƒç´ æ˜¯æœ€è¿‘ä½¿ç”¨è¿‡çš„
# Hash: å­˜æ”¾å¯¹åº”çš„kå’Œå¯¹åº”kçš„nodeç»“ç‚¹

# getï¼š 
- æ ¹æ®hashæ‰¾åˆ°å¯¹åº”çš„nodeï¼Œç„¶ååœ¨é“¾è¡¨ä¸­ç§»é™¤ï¼Œå¹¶é‡æ–°æ·»åŠ åˆ°å¤´
# putï¼š 
- å¦‚æœå·²ç»å­˜åœ¨ï¼Œåˆ™æ ¹æ®hashæ‰¾åˆ°å¯¹åº”çš„nodeï¼Œåœ¨é“¾è¡¨ä¸­ç§»é™¤ï¼Œé‡æ–°æ·»åŠ åˆ°å¤´
- å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™ç›´æ¥å¤´æ’(),å¦‚æœæ’å…¥å‰è¶…è¿‡äº†sizeï¼Œåˆ™ç§»é™¤é“¾è¡¨å°¾éƒ¨å…ƒç´ 
```

```java
package com.citi.tree;

import java.util.HashMap;
import java.util.Map;

class LRUCache {

    static class Node {
        int key;
        int value;
        Node next;
        Node prev;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private Node dummyHead;
    private Node dummyTail;
    private Map<Integer, Node> cache = new HashMap<>();
    int size;
    int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        dummyHead = new Node(-999, -999);
        dummyTail = new Node(-999, -999);
        dummyHead.next = dummyTail;
        dummyTail.prev = dummyHead;
    }

    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        } else {
            removeTarget(node);
            addFirst(new Node(node.key, node.value));
            return node.value;
        }
    }

    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node != null) {
            removeTarget(node);
        }
        if (size == capacity) {
            removeLast();
        }
        addFirst(new Node(key, value));
    }

    /*ä¸‹é¢ä¸‰ä¸ªæ–¹æ³•ï¼šåˆ†åˆ«å¤„ç†é“¾è¡¨ï¼Œsizeï¼Œhash*/
    private void addFirst(Node first) {
        Node next = dummyHead.next;
        first.next = next;
        next.prev = first;
        dummyHead.next = first;
        first.prev = dummyHead;
        cache.put(first.key, first);
        size++;
    }

    private void removeTarget(Node target) {
        Node prev = target.prev;
        Node next = target.next;
        prev.next = next;
        next.prev = prev;
        cache.remove(target.key);
        size--;
    }

    /*åˆ é™¤æœ€åä¸€ä¸ªç»“ç‚¹*/
    private void removeLast() {
        Node removed = dummyTail.prev;
        Node prev = dummyTail.prev.prev;

        prev.next = dummyTail;
        dummyTail.prev = prev;
        cache.remove(removed.key);
        size--;
    }
}
```

