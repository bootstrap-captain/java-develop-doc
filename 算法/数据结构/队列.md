# 普通队列

- 尾进数据，头出数据

```java
package com.citi.queue;

interface MyQueue {

    /*尾插*/
    boolean offer(int val);

    /*头弹，队列为空，队列为空，返回null*/
    int poll();

    /*获取头元素，不弹出来，队列为空，返回null*/
    int peek();

    boolean isEmpty();

    boolean isFull();
}
```

## 1. 链表实现

- 可以使用单向环形带哨兵的链表来实现队列

![image-20231129130253403](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231129130253403.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class LinkedListQueue implements MyQueue {

    class Node {
        int val;
        Node next;

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    Node sentinel = new Node(-999);
    Node head; // head不会移动
    Node tail; // tail移动
    int size = 0;
    int capacity;

    public LinkedListQueue(int capacity) {
        this.capacity = capacity;
        sentinel.next = sentinel;
        head = sentinel;
        tail = sentinel;
    }

    /*尾插*/
    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val);
        inserted.next = sentinel;
        tail.next = inserted;
        tail = tail.next;
        size++;
        return true;
    }

    /*删除sentinel后面的第一个元素*/
    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        Node removed = sentinel.next;
        sentinel.next = removed.next;
        size--;
        return removed.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return sentinel.next.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        if (size == capacity) {
            return true;
        }
        return false;
    }
}
```

## 2. 环形数组

- 相比普通数组，起点和终点更加自由，不用考虑数据移动
- 环形数组，就是在数组长度固定的情况下，定义一定的可用索引范围，通过覆盖写来进行
- 数组性能更佳
- 可以用三种不同的实现来做
- 下一个索引位置：head = (head +1)%arr.length

### 2.1 空位置

- 空位置是移动的，是head后面的一个元素
- 浪费了一个索引位置来进行判满

![image-20231130103313058](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231130103313058.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArrayFirstQueue implements MyQueue {

    int[] arr;

    int head = 0;

    int tail = 0;

    public ArrayFirstQueue(int capacity) {
        this.arr = new int[capacity + 1]; // 空位置要保存数据
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length; // tail向后移动一次
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head];
        arr[head] = -999; // 可以不覆盖写
        head = (head + 1) % arr.length;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head];
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    /*tail+1=head*/
    @Override
    public boolean isFull() {
        return head == (tail + 1) % arr.length;
    }
}
```

### 2.2 新增size

- 新增一个size变量，来判断队列是空还是满

![image-20231130103618498](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231130103618498.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArraySecondQueue implements MyQueue {
    int[] arr;

    int size;

    int head = 0;
    int tail = 0;

    public ArraySecondQueue(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        size++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head];
        arr[head] = -999; // 可以不覆盖写
        head = (head + 1) % arr.length;
        size--;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}
```

### 2.3 head/tail自增

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算

![image-20231014110521963](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110521963.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArrayThirdQueue implements MyQueue {
    int[] arr;
    int head = 0;
    int tail = 0;

    public ArrayThirdQueue(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[(tail) % arr.length] = val;
        tail++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head % arr.length];
        arr[head % arr.length] = -999; // 可以不覆盖
        head++;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head % arr.length];
    }

    @Override
    public boolean isEmpty() {
        return tail == head;
    }

    @Override
    public boolean isFull() {
        return tail - head == arr.length;
    }
}
```

## 3. JDK实现

### 3.1 LinkedList

- 底层是用链表实现

### 3.2 ArrayDeque

- 底层用数组实现



# 双端队列

- 两端都可以进行删除，添加
- Deque: Double Ended Queue

```java
interface Deque {
    boolean offerFirst(int val);

    boolean offerLast(int val);

    int pollFirst();

    int pollLast();

    int peekFirst();

    int peekLast();

    boolean isEmpty();

    boolean isFull();
}
```

### 2.1 链表实现-双向环形链表

![image-20231019172058116](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231019172058116.png)

```java
class LinkedListDeque implements Deque {

    static class Node {
        int val;
        Node next;
        Node prev;

        public Node(int val, Node prev, Node next) {
            this.val = val;
            this.prev = prev;
            this.next = next;
        }
    }

    private int size;     // 当前队列的大小
    private int capacity;  //容量

    private Node sentinel = new Node(Integer.MAX_VALUE, null, null);

    public LinkedListDeque(int capacity) {
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
        this.capacity = capacity;
    }

    /*head和tail自己定义*/
    @Override
    public boolean offerFirst(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val, null, null);
        Node next = sentinel.next; // 下一个元素
        sentinel.next = inserted;
        inserted.prev = sentinel;
        inserted.next = next;
        next.prev = inserted;
        size++;
        return true;
    }

    @Override
    public boolean offerLast(int val) {
        if (isFull()) {
            return false;
        }
        Node prev = sentinel.prev;
        Node inserted = new Node(val, null, null);
        inserted.next = sentinel;
        sentinel.prev = inserted;
        prev.next = inserted;
        inserted.prev = prev;
        size++;
        return true;
    }

    @Override
    public int pollFirst() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        Node pollElement = sentinel.next;
        Node next = pollElement.next;
        sentinel.next = next;
        next.prev = sentinel;
        size--;
        return pollElement.val;
    }

    @Override
    public int pollLast() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        Node pollElement = sentinel.prev;
        Node prev = pollElement.prev;
        prev.next = sentinel;
        sentinel.prev = prev;
        size--;
        return pollElement.val;
    }

    @Override
    public int peekFirst() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.next.val;
    }

    @Override
    public int peekLast() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.prev.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

### 2.2 环形数组

- 实现思路和上面的普通队列的基本相同

# 优先级队列

- 数组的对象多了一个优先级的属性

```java
class Entry {
    int val;
    int priority;
}
```

### 3.1 无序数组实现

![image-20231020120223645](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231020120223645.png)

```java
class PriorityQueue {
    private Entry[] arr;
    private int capacity;
    private int size;

    public PriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        arr[size] = entry;
        size++;
        return true;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        int index = selectMaxIndex();
        Entry result = arr[index];
        remove(index);
        return result;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        int index = selectMaxIndex();
        return arr[index];
    }

    private int selectMaxIndex() {
        int maxP = 0;
        for (int i = 1; i < size; i++) {
            if (arr[i].priority > arr[maxP].priority) {
                maxP = i;
            }
        }
        return maxP;
    }

    private void remove(int index) {
        if (index == size - 1) {
            arr[index] = null;
        } else { // 进行复制拷贝
            System.arraycopy(arr, index + 1, arr, index, size - 1 + index);
            arr[size - 1] = null;
        }
        size--;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```

### 3.2 有序数组实现

- 插入时候进行插入排序，弹出时，只需要弹出数尾部的元素

![image-20231022103506620](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231022103506620.png)

```java
class SortedArrayPriorityQueue {
    private Entry[] arr;

    private int capacity;
    private int size;

    public SortedArrayPriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        insert(entry);
        return true;
    }

    /*插入排序*/
    private void insert(Entry entry) {
        int p = size - 1;
        while (p > 0 && arr[p].priority > entry.priority) {
            arr[p + 1] = arr[p];
            p--;
        }
        arr[p + 1] = entry;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        Entry entry = arr[size - 1];
        arr[size - 1] = null;
        return entry;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        return arr[size - 1];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```



```java

```

```java
class ArrayQueue implements Queue {

    private int capacity;
    private int size;

    private int[] arr;

    private int tail;

    private int head;

    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int data) {
        if (isFull()) {
            return false;
        }
        arr[tail] = data;
        tail = (tail + 1) % capacity;
        size++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = 888;
        size--;
        head = (head + 1) % capacity;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```
