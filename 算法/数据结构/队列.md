- 尾进数据，头出数据

## 1. 普通队列

![image-20231013105008033](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231013105008033.png)

```java
interface MyQueue {

    /*尾插*/
    boolean offer(int val);

    /*头弹，队列为空，队列为空，返回null*/
    int poll();

    /*获取头元素，不弹出来，队列为空，返回null*/
    int peek();

    boolean isEmpty();

    boolean isFull();
}
```

### 1.1 链表实现

- 单向环形带哨兵的链表来实现队列

![image-20231013104421976](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231013104421976.png)

```java
class LinkedListQueue implements MyQueue {

    static class Node {
        int val;
        Node next;

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    Node head;  // head会移动

    Node tail;  // tail会移动

    Node sentinel;

    int capacity = 10; // 最大容量

    int currentSize = 0; // 结点数量

    public LinkedListQueue(int capacity) {
        this.capacity = capacity;
        sentinel = new Node(Integer.MIN_VALUE, null);
        sentinel.next = sentinel;
        head = sentinel; // head永远指向哨兵节点
        tail = sentinel;
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }

        Node inserted = new Node(val, null);
        inserted.next = sentinel; // 新结点下一个指向sentinel
        tail.next = inserted;     // 上一个元素指向当前插入的
        tail = inserted;          // tail重新指向新的尾元素
        currentSize++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }

        Node first = head.next;
        sentinel.next = first.next;
        if (first == tail) { // 尾指针重新指向
            tail = head;
        }
        currentSize--;
        return first.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return head.next.val;
    }

    @Override
    public boolean isEmpty() {
        return head == tail; // head永远指向sentinel
    }

    @Override
    public boolean isFull() {
        return currentSize >= capacity;
    }
}
```

### 1.2 环形数组

- 相比普通数组，起点和终点更加自由，不用考虑数据移动
- 环形数组，就是在数组长度固定的情况下，定义一定的可用索引范围，通过覆盖写来进行
- 数组性能更佳

####  空位置

- 空位置是移动的，是head后面的一个元素
- 浪费了一个索引位置来进行判满

![image-20231014110027770](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110027770.png)

```java
class ArrayQueueFirst implements MyQueue {
    int[] arr;
    int capacity;
    /*index*/
    int head = 0;
    int tail = 0;

    public ArrayQueueFirst(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity + 1];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = Integer.MIN_VALUE; // 可以不用，就是覆盖写
        head = (head + 1) % arr.length;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        int nextIndex = (tail + 1) % arr.length;
        return nextIndex == head;
    }
}
```

#### 新增size

- 新增一个size变量，来判断队列是空还是满

![image-20231014110115755](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110115755.png)

```java
class ArrayQueueSecond implements MyQueue {
    private int head;
    private int tail;
    private int size;
    private int capacity;
    private int[] arr;

    public ArrayQueueSecond(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }

        arr[tail] = val;
        tail = (tail + 1) % capacity;
        size++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = Integer.MIN_VALUE;
        head = (head + 1) % capacity;
        size--;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size >= capacity;
    }
}
```

#### head/tail自增

![image-20231014110521963](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110521963.png)

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算

```java
class ArrayQueueThird implements MyQueue {
    private int capacity;
    private int[] arr;
    private int head = 0;
    private int tail = 0;

    public ArrayQueueThird(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[(tail + 1) % capacity] = val;
        tail++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head % capacity];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head % capacity];
        head++;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        return head - tail >= capacity;
    }
}
```

## 2. 双端队列

- 两端都可以进行删除，添加
- Deque: Double Ended Queue
- 

```java
interface Deque {
    boolean offerFirst(int val);

    boolean offerLast(int val);

    int pollFirst();

    int pollLast();

    int peekFirst();

    int peekLast();

    boolean isEmpty();

    boolean isFull();
}
```

### 2.1 链表实现-双向环形链表

![image-20231019172058116](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231019172058116.png)

```java
class LinkedListDeque implements Deque {

    static class Node {
        int val;
        Node next;
        Node prev;

        public Node(int val, Node prev, Node next) {
            this.val = val;
            this.prev = prev;
            this.next = next;
        }
    }

    private int size;     // 当前队列的大小
    private int capacity;  //容量

    private Node sentinel = new Node(Integer.MAX_VALUE, null, null);

    public LinkedListDeque(int capacity) {
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
        this.capacity = capacity;
    }

    /*head和tail自己定义*/
    @Override
    public boolean offerFirst(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val, null, null);
        Node next = sentinel.next; // 下一个元素
        sentinel.next = inserted;
        inserted.prev = sentinel;
        inserted.next = next;
        next.prev = inserted;
        size++;
        return true;
    }

    @Override
    public boolean offerLast(int val) {
        if (isFull()) {
            return false;
        }
        Node prev = sentinel.prev;
        Node inserted = new Node(val, null, null);
        inserted.next = sentinel;
        sentinel.prev = inserted;
        prev.next = inserted;
        inserted.prev = prev;
        size++;
        return true;
    }

    @Override
    public int pollFirst() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        Node pollElement = sentinel.next;
        Node next = pollElement.next;
        sentinel.next = next;
        next.prev = sentinel;
        size--;
        return pollElement.val;
    }

    @Override
    public int pollLast() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        Node pollElement = sentinel.prev;
        Node prev = pollElement.prev;
        prev.next = sentinel;
        sentinel.prev = prev;
        size--;
        return pollElement.val;
    }

    @Override
    public int peekFirst() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.next.val;
    }

    @Override
    public int peekLast() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.prev.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

### 2.2 环形数组

- 实现思路和上面的普通队列的基本相同

## 3. 优先级队列

- 数组的对象多了一个优先级的属性

```java
class Entry {
    int val;
    int priority;
}
```

### 3.1 无序数组实现

![image-20231020120223645](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231020120223645.png)

```java
class PriorityQueue {
    private Entry[] arr;
    private int capacity;
    private int size;

    public PriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        arr[size] = entry;
        size++;
        return true;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        int index = selectMaxIndex();
        Entry result = arr[index];
        remove(index);
        return result;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        int index = selectMaxIndex();
        return arr[index];
    }

    private int selectMaxIndex() {
        int maxP = 0;
        for (int i = 1; i < size; i++) {
            if (arr[i].priority > arr[maxP].priority) {
                maxP = i;
            }
        }
        return maxP;
    }

    private void remove(int index) {
        if (index == size - 1) {
            arr[index] = null;
        } else { // 进行复制拷贝
            System.arraycopy(arr, index + 1, arr, index, size - 1 + index);
            arr[size - 1] = null;
        }
        size--;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```

### 3.2 有序数组实现

- 插入时候进行插入排序，弹出时，只需要弹出数尾部的元素

![image-20231022103506620](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231022103506620.png)

```java
class SortedArrayPriorityQueue {
    private Entry[] arr;

    private int capacity;
    private int size;

    public SortedArrayPriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        insert(entry);
        return true;
    }

    /*插入排序*/
    private void insert(Entry entry) {
        int p = size - 1;
        while (p > 0 && arr[p].priority > entry.priority) {
            arr[p + 1] = arr[p];
            p--;
        }
        arr[p + 1] = entry;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        Entry entry = arr[size - 1];
        arr[size - 1] = null;
        return entry;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        return arr[size - 1];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```



```java

```

```java
class ArrayQueue implements Queue {

    private int capacity;
    private int size;

    private int[] arr;

    private int tail;

    private int head;

    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int data) {
        if (isFull()) {
            return false;
        }
        arr[tail] = data;
        tail = (tail + 1) % capacity;
        size++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = 888;
        size--;
        head = (head + 1) % capacity;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```
