# 栈

- 只能从数据结构的一端进行操作，先进后出

![image-20231016113311031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016113311031.png)

```java
package com.citi.stack;

public interface MyStack {
    boolean push(int val);

    int pop();

    int peek();

    boolean isEmpty();

    boolean isFull();
}
```

## 1. 链表实现

- 单向带哨兵链表，头插头出

![image-20231016115640568](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016115640568.png)

```java
package com.citi.stack;

import java.util.NoSuchElementException;

public class LinkedListStack implements MyStack {
    class Node {
        int val;
        Node next;

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    Node sentinel = new Node(-999, null);
    int size;
    int capacity;

    public LinkedListStack(int capacity) {
        this.capacity = capacity;
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        sentinel.next = new Node(val, sentinel.next);
        size++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        Node removed = sentinel.next;
        sentinel.next = removed.next;
        size--;
        return removed.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return sentinel.next.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

## 2. 数组实现

![image-20231202101646696](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231202101646696.png)

```java
package com.citi.stack;

import java.util.NoSuchElementException;

public class ArrayStack implements MyStack {
    int[] arr;

    int top = 0;

    public ArrayStack(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        arr[top] = val;
        top++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        int result = arr[top - 1];
        arr[top - 1] = -999;
        top--;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Stack");
        }
        return arr[top - 1];
    }

    @Override
    public boolean isEmpty() {
        return top == 0;
    }

    @Override
    public boolean isFull() {
        return top == arr.length;
    }
}
```

## 3. 栈-队列转换

### 😎[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

- 出的时候，先把当前的outStack中出完，再去倒手

![image-20231018120502207](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231018120502207.png)

```java
import java.util.LinkedList;
import java.util.NoSuchElementException;

class MyQueue {

    LinkedList<Integer> inStack = new LinkedList<>();
    LinkedList<Integer> outStack = new LinkedList<>();

    int size = 0;


    public MyQueue() {
    }

    public void push(int x) {
        inStack.push(x);
        size++;
    }

    public int pop() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }

        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        size--;
        return outStack.pop();
    }

    public int peek() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }

        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.peek();
    }

    public boolean empty() {
        return size == 0;
    }
}
```

### 😎[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

![image-20231202135602075](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231202135602075.png)

```java
import java.util.LinkedList;
import java.util.NoSuchElementException;

class MyStack {

    LinkedList<Integer> queue = new LinkedList<>();

    public MyStack() {
    }

    public void push(int x) {
        queue.push(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.push(queue.pop());
        }
    }

    public int pop() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return queue.pop();
    }

    public int top() {
        if (empty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return queue.peek();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

## 😎 [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

### 栈

- 遍历字符串，如果左边符号，则入栈另一半字符；
- 如果右边，则出栈并比较

```java
public boolean isValid(String s) {
    LinkedList<Character> stack = new LinkedList<>();
    char[] chs = s.toCharArray();

    if (chs.length % 2 != 0) {
        return false;
    }
    for (char ch : chs) {
        if (ch == '{') {
            stack.push('}');
        } else if (ch == '[') {
            stack.push(']');
        } else if (ch == '(') {
            stack.push(')');
        } else {
            if (stack.isEmpty()) {
                return false;
            }
            if (stack.pop()!=ch){
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

## 逆波兰表达式

### 😡[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

- <font color=orange>后缀表达式</font>：运算符号在数字的后面，这样就不用考虑优先级问题
- JVM的运算指令就是这么玩的

#### 栈

- 碰见符号就把前面两个数字弹出栈
- 运算完成后重新入栈

```java
public int evalRPN(String[] tokens) {
      LinkedList<Integer> stack = new LinkedList<>();
      for (String token : tokens) {
          // 处理具体逻辑
          Integer second;
          Integer first;
          switch (token) {
              case "+":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first + second);
                  break;
              case "-":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first - second);
                  break;
              case "*":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first * second);
                  break;
              case "/":
                  second = stack.pop();
                  first = stack.pop();
                  stack.push(first / second);
                  break;
              default:
                  stack.push(Integer.valueOf((token)));
          }
      }
      return stack.pop();
  }
```

### 😡中缀转后缀-无括号

- 给一个中缀表达式，将其转换为后缀表达式

![image-20231202132427456](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231202132427456.png)

```java
/*中缀表达式转后缀*/
public String convert(String str) {
    LinkedList<Character> stack = new LinkedList<>();
    StringBuffer sb = new StringBuffer();
    char[] chs = str.toCharArray();

    for (char ch : chs) {
        if (priority(ch) == -1) {  // 1. 不是运算符，则直接拼接
            sb.append(ch);
        } else {                   // 2. 是运算符
            if (stack.isEmpty()) {
                stack.push(ch);           // 2.1 栈如果为空，则直接添加
            } else {                      // 2.2 栈不空，判断
                if (priority(ch) <= priority(stack.peek())) {
                    while (!stack.isEmpty() && stack.peek() >= priority(ch)) {
                        sb.append(stack.pop());
                    }
                }
                stack.push(ch);
            }
        }
    }
    //3. 处理完成后，把栈里的元素依次出栈拼接
    while (!stack.isEmpty()) {
        sb.append(stack.pop());
    }
    return sb.toString();
}

private int priority(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 0;
        case '*':
        case '/':
            return 1;
        default:
            return -1;
    }
}
```

# 队列

## 1. 普通队列

- 尾进数据，头出数据
- 622题目

```java
package com.citi.queue;

interface MyQueue {

    /*尾插*/
    boolean offer(int val);

    /*头弹，队列为空，队列为空，返回null*/
    int poll();

    /*获取头元素，不弹出来，队列为空，返回null*/
    int peek();

    boolean isEmpty();

    boolean isFull();
}
```

### 链表实现

- 可以使用单向环形带哨兵的链表来实现队列

![image-20231129130253403](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231129130253403.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class LinkedListQueue implements MyQueue {

    class Node {
        int val;
        Node next;

        public Node(int val) {
            this.val = val;
        }

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    Node sentinel = new Node(-999);
    Node head; // head不会移动
    Node tail; // tail移动
    int size = 0;
    int capacity;

    public LinkedListQueue(int capacity) {
        this.capacity = capacity;
        sentinel.next = sentinel;
        head = sentinel;
        tail = sentinel;
    }

    /*尾插*/
    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val);
        inserted.next = sentinel;
        tail.next = inserted;
        tail = tail.next;
        size++;
        return true;
    }

    /*删除sentinel后面的第一个元素: 要考虑只剩下一个节点的情况*/
    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        Node removed = sentinel.next;
        sentinel.next = sentinel.next.next;
        size--;
        // 最后一个元素的时候，考虑下
        if (isEmpty()) {
            tail = sentinel;
        }
        return removed.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return sentinel.next.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        if (size == capacity) {
            return true;
        }
        return false;
    }
}
```

### 环形数组

- 相比普通数组，起点和终点更加自由，不用考虑数据移动
- 环形数组，就是在数组长度固定的情况下，定义一定的可用索引范围，通过覆盖写来进行
- 数组性能更佳
- 可以用三种不同的实现来做
- 下一个索引位置：head = (head +1)%arr.length，每次计算索引，都必须通过这个公式，而不能使用++或者--

#### 空位置

- 空位置是移动的，是head后面的一个元素
- 浪费了一个索引位置来进行判满
- 上一个元素位置 tail = (tail+(arr.length-1))%arr.length, 用来获取尾部元素，防止数组越界

![image-20231205211525773](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231205211525773.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArrayFirstQueue implements MyQueue {

    int[] arr;

    int head = 0;

    int tail = 0;

    public ArrayFirstQueue(int capacity) {
        this.arr = new int[capacity + 1]; // 空位置要保存数据
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length; // tail向后移动一次
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head];
        arr[head] = -999; // 可以不覆盖写
        head = (head + 1) % arr.length;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head];
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    /*tail+1=head*/
    @Override
    public boolean isFull() {
        return head == (tail + 1) % arr.length;
    }
}
```

#### 新增size

- 新增一个size变量，来判断队列是空还是满

![image-20231130103618498](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231130103618498.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArraySecondQueue implements MyQueue {
    int[] arr;

    int size;

    int head = 0;
    int tail = 0;

    public ArraySecondQueue(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        size++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head];
        arr[head] = -999; // 可以不覆盖写
        head = (head + 1) % arr.length;
        size--;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}
```

#### head/tail自增

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算
- 没有size属性

##### 模运算

![image-20231014110521963](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110521963.png)

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArrayThirdQueue implements MyQueue {
    int[] arr;
    int head = 0;
    int tail = 0;

    public ArrayThirdQueue(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[(tail) % arr.length] = val;
        tail++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head % arr.length];
        arr[head % arr.length] = -999; // 可以不覆盖
        head++;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head % arr.length];
    }

    @Override
    public boolean isEmpty() {
        return tail == head;
    }

    @Override
    public boolean isFull() {
        return tail - head == arr.length;
    }
}
```

##### 位运算

- 假如数组的head和tail一直增加，那么当超过int的最大值的时候，计算出来的索引就是负，就会报错
- 当数组长度是2的n次方的时候，计算索引的时候，求模运算可以用位运算来代替

```bash
# 求模运算 vs 按位与
# 前提：除数是 2 的  n  次方

# 结果： head&(arr.length-1)
```

```java
package com.citi.queue;

import java.util.NoSuchElementException;

public class ArrayFourthQueue implements MyQueue{
    int[] arr;
    int head = 0;
    int tail = 0;

    public ArrayFourthQueue(int capacity) {
        arr = new int[capacity];
    }

    /*该用位运算
    1. 可以解决索引超过int范围问题
    2. 位运算更快*/
    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[(tail) & (arr.length - 1)] = val;
        tail++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int result = arr[head & (arr.length - 1)];
        arr[head & (arr.length - 1)] = -999; // 可以不覆盖
        head++;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return arr[head & (arr.length - 1)];
    }

    @Override
    public boolean isEmpty() {
        return tail == head;
    }

    /*不用担心越界问题*/
    @Override
    public boolean isFull() {
        return tail - head == arr.length;
    }
}
```

## 2. 双端队列

- 两端都可以进行删除，添加
- Deque: Double Ended Queue
- 641题目

```java
package com.citi.deque;

interface MyDequeue {
    boolean offerFirst(int val);

    boolean offerLast(int val);

    int pollFirst();

    int pollLast();

    int peekFirst();

    int peekLast();

    boolean isEmpty();

    boolean isFull();
}
```

### 链表实现

- 双向环形链表，带头指针

![image-20231203111932930](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231203111932930.png)

```java
import java.util.NoSuchElementException;

public class LinkedDequeue implements MyDequeue {

    Node sentinel = new Node(-999);

    int size;
    int capacity;


    public LinkedDequeue(int capacity) {
        this.capacity = capacity;
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
    }


    @Override
    public boolean offerFirst(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val);
        size++;
        // 插入结点：维护两个指针
        inserted.prev = sentinel;
        inserted.next = sentinel.next;
        // 维护前后
        sentinel.next.prev = inserted;
        sentinel.next = inserted;
        return true;
    }

    @Override
    public boolean offerLast(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val);
        size++;
        // 插入结点：维护两个指针
        inserted.prev = sentinel.prev;
        inserted.next = sentinel;
        // 维护前后
        sentinel.prev.next = inserted;
        sentinel.prev = inserted;
        return true;
    }

    @Override
    public int pollFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        Node removed = sentinel.next;
        // 只需要维护两个指针
        sentinel.next = sentinel.next.next;
        sentinel.next.prev = sentinel;
        size--;
        return removed.val;
    }

    @Override
    public int pollLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        Node removed = sentinel.prev;
        // 只需要维护两个指针
        sentinel.prev.prev.next = sentinel;
        sentinel.prev = sentinel.prev.prev;
        size--;
        return removed.val;
    }

    @Override
    public int peekFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return sentinel.next.val;
    }

    @Override
    public int peekLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        return sentinel.prev.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

```java
class Node {
    int val;
    Node prev;
    Node next;

    public Node(int val) {
        this.val = val;
    }

    public Node(Node prev, int val, Node next) {
        this.prev = prev;
        this.val = val;
        this.next = next;
    }
}
```

### 环形数组

#### 空位置

#### 新增size

![image-20231205225124108](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231205225124108.png)

```java
package com.citi.deque;

import java.util.NoSuchElementException;

public class SecondArrayDequeue implements MyDequeue {

    int[] arr;

    int size;

    int head;

    int tail;

    public SecondArrayDequeue(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean offerFirst(int val) {
        if (isFull()) {
            return false;
        }
        // 索引减一的处理
        head = (head + arr.length - 1) % arr.length;
        arr[head] = val;
        size++;
        return true;
    }

    @Override
    public boolean offerLast(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        size++;
        return true;
    }

    @Override
    public int pollFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Dequeue");
        }
        int result = arr[head];
        arr[head] = -999;
        head = (head + 1) % arr.length;
        size--;
        return result;
    }

    @Override
    public int pollLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Dequeue");
        }

        tail = (tail + arr.length - 1) % arr.length; // 减1
        int result = arr[tail];
        arr[tail] = -999;
        size--;
        return result;
    }

    @Override
    public int peekFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Dequeue");
        }
        return arr[(head % arr.length)];
    }

    @Override
    public int peekLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Dequeue");
        }
        return arr[(tail + arr.length - 1) % arr.length];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}
```

#### head/tail自增

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算
- 没有size属性

## 3. 优先级队列

- 数组的对象多了一个优先级的属性
- 入队是尾部插入
- 出队时，优先级高的先出来

```java
public interface PriorityQueue {
    boolean offer(Entry entry);

    Entry poll();

    Entry peek();

    boolean isEmpty();

    boolean isFull();
}
```

```java
class Entry {
    int value;
    int priority;

    public Entry(int value, int priority) {
        this.value = value;
        this.priority = priority;
    }
}
```

### 无序数组--size

![image-20231206131751397](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231206131751397.png)

```java
package com.citi.priorityqueue;

import java.util.NoSuchElementException;

public class ArrayPriorityQueue implements PriorityQueue {

    Entry[] arr;
    int size;

    @Override
    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        arr[size] = entry;
        size++;
        return false;
    }

    @Override
    public Entry poll() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int targetIndex = selectMaxPriorityIndex();
        Entry removedEntry = arr[targetIndex];
        remove(targetIndex);
        return removedEntry;
    }

    @Override
    public Entry peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Empty Queue");
        }
        int targetIndex = selectMaxPriorityIndex();
        return arr[targetIndex];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }

    /*寻找优先级最高的元素*/
    private int selectMaxPriorityIndex() {
        int maxIndex = -1;
        int priority = Integer.MIN_VALUE;
        for (int i = 0; i < size; i++) {
            Entry entry = arr[i];
            if (entry.priority > priority) {
                maxIndex = i;
            }
        }
        return maxIndex;
    }

    /*删除元素*/
    private void remove(int index) {
        if (index == size - 1) { // 队列最后一个元素
            arr[index] = null;
        } else { // 复制拷贝
            System.arraycopy(arr, index + 1, arr, index, size - 1 + index);
            arr[size - 1] = null;
        }
        size--;
    }
}
```

### 有序数组实现

- 插入时候进行插入排序，弹出时，只需要弹出数尾部的元素

![image-20231022103506620](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231022103506620.png)

```java
class SortedArrayPriorityQueue {
    private Entry[] arr;

    private int capacity;
    private int size;

    public SortedArrayPriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        insert(entry);
        return true;
    }

    /*插入排序*/
    private void insert(Entry entry) {
        int p = size - 1;
        while (p > 0 && arr[p].priority > entry.priority) {
            arr[p + 1] = arr[p];
            p--;
        }
        arr[p + 1] = entry;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        Entry entry = arr[size - 1];
        arr[size - 1] = null;
        return entry;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        return arr[size - 1];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```

### 堆实现

- 堆，本身就是一种优先级队列

## 4. 阻塞队列

### 单锁实现

### 双锁实现



# 堆-优先队列

- 堆是一种优先级队列，可以通过数组的方式实现

## 1. 大顶堆/小顶堆

```bash
# 大顶堆： 任意节点都小于其父节点
# 小顶堆： 任意节点都大与其父节点
- 左节点和右节点关系不定

# 索引原则：索引0开始存储，i表示索引
- 节点i的父节点：       floor((i-1)/2)      当i大于0时
- 节点i的左子节点为：    2i+1                结果不能大于size
- 节点i的右子节点为：    2i+2                结果不能大于size
```

![image-20231023190718489](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023190718489.png)

## 2. MaxHeap

```java
package com.citi.heap;

public interface MaxHeap {
    /*头尾交换，并下潜*/
    int poll();

    void down(int parent);

    /*尾部添加：并上浮*/
    boolean offer(int data);

    void up(int child);

    boolean isFull();

    boolean isEmpty();
}
```

### 2.1 offer

```bash
# 威廉姆斯算法
- 入堆新元素，加入到数组末尾
- 不断比较新加元素与其父节点的值
    - 父节点更小，则父节点向下移动，继续向上找parent
    - 直到父节点值更大
```

![image-20231023172249031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023172249031.png)

### 2.2 poll

```bash
# poll： 删除堆顶处的元素
- 堆顶元素 和最后一个元素交换
- 删除最后一个元素
- 对堆顶元素进行下潜

# 下潜： 比左右孩子最大的小
- 比较当前节点的值和左右孩子的值
- 如果当前节点的值比左右孩子最大的小，则交换
```

### 2.3 heapify

```bash
# 方式一：威廉姆斯算法，旧数组，一个个offer进去

# 方式二：弗洛伊德算法):  对既有数组进行重排，
- 找到最后一个非叶子节点
- 从后向前，对每个节点执行下潜（比较左右值）

    # 非叶子节点
   - 没有任何一个左孩子或者右孩子
   - 最后一个元素的父节点
```

![image-20231023152506251](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023152506251.png)

```java
package com.citi.heap;

public class ArrayMaxHeap implements MaxHeap {

    private int[] arr;
    private int size;

    private int capacity;

    public ArrayMaxHeap(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    /*现有数组构建:*/
    public ArrayMaxHeap(int[] input, int capacity) {
        this(capacity);
        if (input.length <= capacity) {
            size = input.length;
            System.arraycopy(arr, 0, input, 0, input.length);
            heapfiy(arr);
        } else {
            size = arr.length;
            System.arraycopy(arr, 0, input, 0, capacity);
            heapfiy(arr);
        }
    }

    private void heapfiy(int[] arr) {
        int lastIndex = size / 2 - 1;
        for (int i = lastIndex; i >= 0; i--) {
            down(i);
        }
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int res = arr[0];

        swap(0, size - 1);
        arr[size - 1] = Integer.MIN_VALUE;
        down(0);
        size--;
        return res;
    }

    @Override
    public void down(int parent) {
        int left = 2 * parent + 1;
        int right = 2 * parent + 2;
        int max = parent;
        if (left < size && arr[left] > arr[max]) {
            max = left;
        }
        if (right < size && arr[right] > arr[max]) {
            max = right;
        }
        if (parent != max) {
            swap(parent, max);
            down(max);
        }
    }

    @Override
    public boolean offer(int data) {
        if (isFull()) {
            return false;
        }

        arr[size] = data;
        up(size);
        size++;
        return true;
    }

    @Override
    public void up(int child) {
        int val = arr[child];
        int parent = (child - 1) / 2;
        while (arr[parent] < val && child > 0) {
            arr[child] = arr[parent];
            child = parent;
            parent = (child - 1) / 2;
        }
        arr[child] = val;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 3. JDK-PriorityQueue

```java
PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> (b - a));      // 大顶堆
PriorityQueue<Integer> min = new PriorityQueue<>((a, b) -> (a - b));      // 小顶堆
```



## 4. LeetCode

### ❤️[数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

```bash
# 小顶堆(堆底元素就是第k大的)
# 方法类似大顶堆
- 1. 将前k个元素加入到数组中，并heapify成小顶堆
- 2. 后续数组元素依次入和堆顶元素比较
    - 2.1 如果比堆顶大，则替换堆顶元素，并下潜
    - 2.2 如果比堆顶小或等，则什么也不做
- 3. 返回堆顶元素 
```

![image-20231026112424150](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231026112424150.png)

```java
// JDK提供的小顶堆
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> stack = new PriorityQueue<>(k, Comparator.comparingInt(a -> a));
    for (int i = 0; i < k; i++) {
        stack.add(nums[i]);
    }

    for (int i = k; i < nums.length; i++) {
        if (nums[i] > stack.peek()) {
            stack.poll();
            stack.add(nums[i]);
        }
    }
    return stack.peek();
}
```

### 4.2 数据流中的第K大元素 - 321

```bash
# 给定整数数组 nums 和整数 k，返回数组中第k个最大的元素
# 可以给数组不断添加新的元素，依然返回第K个最大的元素
#  数组初始可能为null，数据可能为负数
# 题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素

# 解题思路类似上面
- 1.构建大小为k的小顶堆: 数据为Integer.MIN_VALUE
- 2.逐个添加顶部元素，并进行下潜
```

```java
class KthLargest {

    private MinHeap minHeap;

    public KthLargest(int k, int[] nums) {
        minHeap = new MinHeap(k);
        for (int i = 0; i < nums.length; i++) {
            minHeap.add(nums[i]);
        }
    }

    public int add(int val) {
        minHeap.add(val);
        return minHeap.arr[0];
    }
}

class MinHeap {
    int[] arr;
    int size;
    int capacity;

    public MinHeap(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
        Arrays.fill(arr, Integer.MIN_VALUE);
        size = capacity;
    }

    public void add(int data) {
        if (data > arr[0]) {
            arr[0] = data;
            down(0);
        }
    }

    private void down(int parent) {
        int left = parent * 2 + 1;
        int right = parent * 2 + 2;
        int min = parent;
        if (left < size && arr[left] < arr[min]) {
            min = left;
        }
        if (right < size && arr[right] < arr[min]) {
            min = right;
        }
        if (min != parent) {
            swap(min, parent);
            down(min);
        }
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 4.3 数据流的中位数

```bash
输入： 2,3,4,     输出：3
输入：1，2，3，4， 输出：2.5

# 思路：构建一个大顶堆，一个小顶堆，确保大顶堆的堆顶元素小于小顶堆的堆顶元素
# add
- 两边个数一样时，左边个数加一
- 两边个数不一样时，右边加一
# add规则
- 左边添加时，把新元素添加在右，弹出右边堆顶元素加入左边
- 右边逻辑类似
```

![image-20231029104600488](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029104600488.png)

```java
class MedianFinder {

    PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> (b - a));
    PriorityQueue<Integer> min = new PriorityQueue<>((a, b) -> (a - b));

    public MedianFinder() {
    }

    public void addNum(int num) {
        if (max.size() == min.size()) {
            // 添加到大顶堆
            min.add(num); // 添加后还是有序的堆
            Integer data = min.poll();
            max.add(data);
        } else {
            // 添加到小顶堆
            max.add(num);
            Integer data = max.poll();
            min.add(data);
        }
    }

    public double findMedian() {
        if (max.size() == min.size()) {
            return (max.peek() + min.peek()) / 2.0;
        } else {
            return max.peek();
        }
    }
}
```



## 

# JDK-栈-队列(普通,双端)

## 1. LinkedList

- 底层是用链表实现
- 栈，普通队列，双端队列

## 2. ArrayDeque

- 底层用数组实现
- 栈，普通队列，双端队列
