# 位运算

# 二进制码

## 1. 比特/字节

### 1. 1 bit

- 比特位：计算机中最小的表示单位，存储0或1

### 1.2 byte

- 字节：计算机中最小的存储单位
- 一个字节包含8个bit，为一组
- 文中全部先用1个byte来进行计算

### 1.3 二进制数

- 数据在底层都是通过二进制来存储的
- 给定大小的数据类型，最高位是符号位，0代表正数，1代表负数

## 2. 正数

- 正数的<font color=orange>原码，反码，补码一样</font>
- 计算时候，就是在最右边进行累加计算

### 2.1 最大值

![image-20231112161418176](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112161418176.png)

### 2.2 计算

![image-20231112162750931](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112162750931.png)

## 3. 负数

- 负数的存储和计算，在计算机底层都是通过补码来实现的

```bash
# 原码
- 最高位为1，其余正常表示

# 反码
- 符号位不变，其余位取反
```

### 3.1 反码

- 如果通过原码，对负数进行计算，实际运算结果刚好和运算相反
- 可以通过反码来对负数进行计算
- 只要不涉及跨0，负数完全可以用反码来进行计算

```bash
# 负数运算规则
- 将十进制转换为二进制原码
- 先将原码转换成反码
- 对反码进行计算 加1
- 对计算后的反码，再转换为原码
- 对原码转换成二进制
```

![image-20231112163648724](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112163648724.png)

### 3.2 跨0问题

- 0值的反码比较特殊会有两个
- 负数计算时，如果跨0 到正数，就会缺少一次，因此计算结果就不准确了

![image-20231112165424053](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112165424053.png)

### 3.3 补码

- 补码是为了解决跨0问题
- 计算机底层存储和运算，都是通过补码来实现的
- 补码是在反码的基础上加1

![image-20231112170813309](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112170813309.png)

### 3.4 -128

- 计算机中规定，补码中，1后面7个0，表示-128
- 一个字节的取值范围：-128～127

![image-20231112171747339](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112171747339.png)

# 数据表示

## 1. 数据类型

- 十进制的数据，用二进制表示，如果切换到数据类型较大的数据类型，则前面补充0

```bash
# byte：   1个字节
# short：  2个字节
# int：    4个字节
# long     8个字节
```

## 2. 类型转换

- 底层存储都是用的补码

### 2.1 小转大

```bash
# 十进制的10： 前面补0
- byte：                                 0000 1010
- int：   0000 0000 0000 0000 0000 0000  0000 1010
```

### 2.2 大转小

```bash
# 十进制的300： 前面补0
- int：   0000 0000 0000 0000 0000 0001  0010 1100
- byte：                                 0010 1100 = 44            # 精度丢失

# 十进制的200:
- int：    0000 0000 0000 0000 0000 0000  1100 1000
- byte：                                  1100 1000 (补码)             #  精度丢失 + 符号变换
                                          1100 0111 (反码)
                                          1011 1000 (原码) = -56
```

# 位运算

## 1. 与

### 1.1 基本计算

- 对二进制数据进行按位与
- 0为false，1为true，如果都是true则是1，否则就是0

```java
public void test01() {
    int a = 200;
    int b = 10;
    int result = a & b;   // 8
    System.out.println(result);
}
```

```bash
# 计算过程
- a=200：   0000 0000 0000 0000 0000 0000 1100 1000
- b=10 ：   0000 0000 0000 0000 0000 0000 0000 1010
- result：  0000 0000 0000 0000 0000 0000 0000 1000 = 8
```

### 1.2 求模运算

- key>0, 和数组索引一一对应，如果超过索引长度，则进行求模型
- 如果<font color=orange>数组长度是2的n次方</font>，则key % arr.length等价于key & arr.length - 1
- 位运算比除法运算性能更高

```java
public int getIndex01(int key) {
    int[] arr = new int[8];
    int target = key % arr.length;
    return target;
}

public int getIndex(int key) {
    int[] arr = new int[8];
    int target = key & arr.length - 1;
    return target;
}
```



## 2. 或

### 2.1 基本计算

- 对二进制数据进行按位与
- 0为false，1为true，一个为true则是1，否则就是0

```java
public void test01() {
    int a = 200;
    int b = 10;
    int result = a | b;   // 202
    System.out.println(result);
}
```

```bash
# 计算过程
- a=200：   0000 0000 0000 0000 0000 0000 1100 1000
- b=10 ：   0000 0000 0000 0000 0000 0000 0000 1010
- result：  0000 0000 0000 0000 0000 0000 1100 1010 = 202
```

## 3. 异或

### 3.1 基本计算

- 对二进制数据进行按位与
- 0为false，1为true，两个不同时为1，相同时为0

```java
public void test01() {
    int a = 200;
    int b = 10;
    int result = a ^ b;   // 194
    System.out.println(result);
}
```

```bash
# 计算过程
- a=200：   0000 0000 0000 0000 0000 0000 1100 1000
- b=10 ：   0000 0000 0000 0000 0000 0000 0000 1010
- result：  0000 0000 0000 0000 0000 0000 1100 0010 = 194
```

## 4. 左移

### 4.1 基本计算

- 低位补0
- 左移一次，结果乘2

```java
public void test01() {
    int a = 200;
    int result = a << 2;   // 800
    System.out.println(result);
}
```

```bash
# 计算过程: 左移，
- a=200：       000000000000000011001000    
- result：   00`0000000000000011001000 
- result：   00`000000000000001100100000 = 800
```

## 5. 右移

### 5.1 基本计算

- 最高位：原来的数字高位是什么，就用什么来补
- 其他位：补0
- 右移一次，结果除2

```java
public void test01() {
    int a = 200;
    int b = 2;
    int result = a >> b;   // 50
    System.out.println(result);
}
```

```bash
# 计算过程: 右移，
- a=200：       000000000000000011001000    
- result：       `0000000000000000110010
- result：     00`0000000000000000110010
```

## 6. 无符号右移

### 6.1 基本计算

- 高位补0

```java
public void test01() {
    int a = 200;
    int b = 2;
    int result = a >>> b;   // 50
    System.out.println(result);
}
```



# 动态数组

```java
class DynamicArray {
    int capacity; // 数组最大长度
    int size;         // 当前数组非空元素的个数
    int[] arr = {};

    public DynamicArray(int capacity) {
        this.capacity = capacity;
    }

    public void addLast(int val) {
        add(size, val);
    }

    public void add(int index, int val) {
        checkAndExpand();
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("Illegal Index");
        }

        if (index < size) { // 指定位置添加
            System.arraycopy(arr, index, arr, index + 1, size - index);
        }
        arr[index] = val;           // addLast添加
        size++;
    }

    public int get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return arr[index];
    }


    public void loop(Consumer<Integer> consumer) {
        for (int i = 0; i < size; i++) {
            consumer.accept(arr[i]);
        }
    }

    public int remove(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("Illegal Index");
        }
        int removed = arr[index];
        // 数组间,数组内，拷贝, 删除后的数据，只是无法访问了，但是最后一个元素，其实不是0值
        System.arraycopy(arr, index + 1, arr, index, size - index - 1);
        size--;
        return removed;
    }
    
    private void checkAndExpand() {
        if (size == 0) {                   //  首次扩容
            arr = new int[capacity];
        } else if (size == capacity) {     //  后续扩容
            capacity += capacity / 2;
            int[] newArray = new int[capacity];
            System.arraycopy(arr, 0, newArray, 0, size); // 数组拷贝
            arr = newArray;
        }
    }
}
```



# 链表

## 1. 单向链表

```java
class Node{
    int val;
    Node next;

    public Node(int val, Node next) {
        this.val = val;
        this.next = next;
    }
}
```

```java
interface SingleListInter {
    void addFirst(int val);

    void loop(Consumer<Integer> consumer);

    void addLast(int val);

    int get(int index);

    void removeFirst();

    void remove(int index);

    void insert(int index, int val);
}
```

### 1.1 无哨兵

- head永远指向头元素，不要变动
- 会有很多判空的处理

![image-20231004155002630](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004155002630.png)

```java
class SingledList implements SingleListInter {
    Node head;

    @Override
    public void addFirst(int val) {
        head = new Node(val, head); // head为空/不空简化后的代码
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        Node pointer = head;  // 移动pointer而不是head
        while (pointer != null) {
            consumer.accept(pointer.val);
            pointer = pointer.next;
        }
    }

    @Override
    public void addLast(int val) {
        Node last = findLast();
        if (last == null) {
            addFirst(val);
        } else {
            last.next = new Node(val, null);
        }
    }

    @Override
    public int get(int index) {
        Node node = getNode(index);
        if (node == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return node.val;
    }

    @Override
    public void removeFirst() {
        if (head == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        head = head.next; // 前面一个元素，自动被垃圾回收掉
    }

    @Override
    public void remove(int index) {
        if (index == 0) {
            removeFirst();
        }
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node removed = prev.next;
        if (removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = removed.next;
    }

    @Override
    public void insert(int index, int val) {
        if (index == 0) {
            addFirst(val);
            return;
        }

        Node prev = getNode(index - 1); // 找前一个节点
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        prev.next = new Node(val, prev.next);
    }


    private Node findLast() {
        if (head == null) {
            return null;
        }
        Node pointer = head;
        while (pointer.next != null) {
            pointer = pointer.next;
        }
        return pointer;
    }

    private Node getNode(int index) {
        Node pointer = head;
        int currentIndex = -1;
        while (pointer != null) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

### 1.2 带哨兵

- dummy元素充当首元素，避免了一些判空处理

![image-20231004182312899](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004182312899.png)

```java

class SingledDummyList implements SingleListInter {
    Node dummy = new Node(Integer.MIN_VALUE, null);
    Node head = dummy;

    @Override
    public void addFirst(int val) {
        head.next = new Node(val, head.next);
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        Node pointer = head.next;
        while (pointer != null) {
            consumer.accept(pointer.val);
            pointer = pointer.next;
        }
    }

    @Override
    public void addLast(int val) {
        Node last = findLast();
        last.next = new Node(val, null);
    }

    @Override
    public int get(int index) {
        Node node = getNode(index);
        if (node == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return node.val;
    }

    @Override
    public void removeFirst() {
        if (dummy.next == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        dummy.next = dummy.next.next;
    }

    @Override
    public void remove(int index) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node removed = prev.next;
        if (removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = removed.next;
    }

    @Override
    public void insert(int index, int val) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = new Node(val, prev.next);
    }

    private Node findLast() {
        Node pointer = head;
        while (pointer.next != null) {
            pointer = pointer.next;
        }
        return pointer;
    }

    private Node getNode(int index) {
        Node pointer = head;
        int currentIndex = -2;
        while (pointer != null) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

## 2. 双向链表

- 带头哨兵和尾哨兵的双向链表

![image-20231004191925877](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004191925877.png)

```java
class Node {
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

```java
/*主要好处：可以逆序遍历，快速找到最后的结点*/
class DoublyLinkedList {
    Node head;
    Node tail;

    public DoublyLinkedList() {
        head = new Node(Integer.MIN_VALUE, null, null);
        tail = new Node(Integer.MIN_VALUE, null, null);
        head.next = tail;
        tail.prev = head;
    }

    public void addFirst(int val) {
        insert(0, val);
    }

    public void insert(int index, int val) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = prev.next;

        /*新节点*/
        Node inserted = new Node(val, prev, next);
        prev.next = inserted;
        next.prev = inserted;
    }

    public void remove(int index) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        Node removed = prev.next;
        if (removed == tail) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    public void addLast(int val) {
        Node prev = tail.prev;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;

        inserted.next = tail;
        tail.prev = inserted;
    }

    public void removeLast() {
        Node removed = tail.prev;
        if (removed == head) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = removed.prev;
        prev.next = tail;
        tail.prev = prev;
    }

    private Node getNode(int index) {
        int currentIndex = -2; // head节点的索引是-1
        Node pointer = head;
        while (pointer != tail) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

## 3. 双向环形链表

- 只有一个头哨兵

![image-20231005150947772](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231005150947772.png)

```java
class Node{
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

```java
class CrossDoublyLinkedList {
    Node sentinel;

    /*一开始的时候，哨兵结点的prev和next都指向本身自己*/
    public CrossDoublyLinkedList() {
        sentinel = new Node(Integer.MIN_VALUE, null, null);
        sentinel.prev = sentinel;
        sentinel.next = sentinel;
    }

    public void addFirst(int val) {
        Node prev = sentinel;
        Node next = sentinel.next;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;
        inserted.next = next;
        next.prev = inserted;
    }

    public void addLast(int val) {
        Node last = sentinel.prev;
        Node inserted = new Node(val, null, null);

        inserted.next = sentinel;
        sentinel.prev = inserted;
        last.next = inserted;
        inserted.prev = last;
    }

    public void removeFirst() {
        Node removed = sentinel.next;
        if (removed == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        sentinel.next = next;
        next.prev = sentinel;
    }

    public void removeLast() {
        Node last = sentinel.prev;
        if (last == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = last.prev;
        prev.next = sentinel;
        sentinel.prev = prev;
    }

    public void removeByVal(int val) {
        Node removed = findByVal(val);
        if (removed == null) {
            throw new IllegalArgumentException("No Target Found");
        }

        Node prev = removed.prev;
        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    private Node findByVal(int val) {
        Node pointer = sentinel.next;
        while (pointer != sentinel) {
            if (val == pointer.val) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }

}
```

- 默认每个题目中都是给一个head，可以在方法里面添加哨兵

## 4. LeetCode

### 4.2 删除节点

#### ByValue

```bash
# 输入: head = [4,5,1,9], val = 5            输出: [4,1,9]
# 输入: head = [4,5,1,9], val = 1            输出: [4,5,9]
# 可能重复值

# 思路
- 前置结点和当前结点
```

```java
public ListNode deleteNode(ListNode head, int val) {
    // 添加一个头结点，后续省略很多判空处理，后续都用sentinel来处理
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head); 
    ListNode prev = sentinel;
    ListNode current = prev.next;
    while (current != null) {
        if (current.val == val) {
            prev.next = current.next;
        } else {
            prev = prev.next;
        }
        current = current.next;
    }
    return sentinel.next;
}
```

#### 倒数第N个

```bash
# 输入：head = [1,2,3,4,5], n = 2
# 输出：[1,2,3,5]
```

##### 正序遍历

```bash
# 一共需要遍历三次
- 1. 第一次遍历，得到链表总长length
- 2. 被删除索引 index = length-num
- 3. 删除指定索引的元素, sentinel的索引是-1
```

```java
 public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
        // 得到总size
        int length = getLength(sentinel);
        // 得到目标索引
        int targetIndex = length - n;
        // 前一个元素
        ListNode prev = getNode(sentinel, targetIndex - 1);
        // 后一个元素
        ListNode removed = getNode(sentinel, targetIndex);
        if (prev == null || removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        prev.next = removed.next;
        return sentinel.next;
    }

    private int getLength(ListNode sentinel) {
        ListNode pointer = sentinel.next;
        int length = 0;
        while (pointer != null) {
            length++;
            pointer = pointer.next;
        }
        return length;
    }

    private ListNode getNode(ListNode sentinel, int targetIndex) {
        int index = -2;
        ListNode pointer = sentinel;
        while (pointer != null) {
            index++;
            if (targetIndex == index) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
```

##### 快慢指针

![image-20231008115435110](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231008115435110.png)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode fast = sentinel;
    ListNode slow = sentinel;
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }

    while (fast.next != null) {
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;
    return sentinel.next;
}
```

#### 有序去重

- 重复元素保留一个

##### pre+current

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode pre = sentinel;
    ListNode current = sentinel.next;
    while (current != null) {
        if (pre.val == current.val) {
            pre.next = current.next;
        } else {
            pre = pre.next;
        }
        current = current.next;
    }
    return sentinel.next;
}
```

#### 有序去重

- 重复元素删除

##### p1+p2+p3

![image-20231009110239365](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231009110239365.png)

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode p1 = sentinel;
    ListNode p2 = p1.next;
    ListNode p3 = p2.next;

    while (p3 != null) {
        if (p3.val != p2.val) {
            p1 = p2;
            p2 = p3;
            p3 = p3.next;
        } else {
            while (p3 != null && p3.val == p2.val) {
                p3 = p3.next;
            }
            p1.next = p3;
            p2 = p3;
            if (p3 != null) {
                p3 = p3.next;
            }
        }
    }
    return sentinel.next;
}
```

### 4.4 中间结点

```bash
# 输入：head = [1,2,3,4,5]，   输出：[3,4,5]
# 输入：head = [1,2,3,4,5,6]   输出：[4,5,6]
```

#### 两次遍历

```bash
# 思路：
- 1. 遍历一次，得到链表长度，得到中间索引
- 2. 第二次遍历，根据索引获取到指定索引位置
```

#### 快慢指针

- 慢指针每次移动一个，快指针每次移动2个
- 快指针指向null时，慢指针的当前位置

![image-20231009154523418](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231009154523418.png)

```java
    public ListNode middleNode(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
        ListNode fast = sentinel;
        ListNode slow = sentinel;
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
            if (fast != null){
                fast = fast.next;
            }
        }
        return slow;
    }
```

# 队列

- 尾进数据，头出数据

## 1. 普通队列

![image-20231013105008033](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231013105008033.png)

```java
interface MyQueue {

    /*尾插*/
    boolean offer(int val);

    /*头弹，队列为空，队列为空，返回null*/
    int poll();

    /*获取头元素，不弹出来，队列为空，返回null*/
    int peek();

    boolean isEmpty();

    boolean isFull();
}
```

### 1.1 链表实现

- 单向环形带哨兵的链表来实现队列

![image-20231013104421976](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231013104421976.png)

```java
class LinkedListQueue implements MyQueue {

    static class Node {
        int val;
        Node next;

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    Node head;  // head会移动

    Node tail;  // tail会移动

    Node sentinel;

    int capacity = 10; // 最大容量

    int currentSize = 0; // 结点数量

    public LinkedListQueue(int capacity) {
        this.capacity = capacity;
        sentinel = new Node(Integer.MIN_VALUE, null);
        sentinel.next = sentinel;
        head = sentinel; // head永远指向哨兵节点
        tail = sentinel;
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }

        Node inserted = new Node(val, null);
        inserted.next = sentinel; // 新结点下一个指向sentinel
        tail.next = inserted;     // 上一个元素指向当前插入的
        tail = inserted;          // tail重新指向新的尾元素
        currentSize++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }

        Node first = head.next;
        sentinel.next = first.next;
        if (first == tail) { // 尾指针重新指向
            tail = head;
        }
        currentSize--;
        return first.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return head.next.val;
    }

    @Override
    public boolean isEmpty() {
        return head == tail; // head永远指向sentinel
    }

    @Override
    public boolean isFull() {
        return currentSize >= capacity;
    }
}
```

### 1.2 环形数组

- 相比普通数组，起点和终点更加自由，不用考虑数据移动
- 环形数组，就是在数组长度固定的情况下，定义一定的可用索引范围，通过覆盖写来进行
- 数组性能更佳

####  空位置

- 空位置是移动的，是head后面的一个元素
- 浪费了一个索引位置来进行判满

![image-20231014110027770](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110027770.png)

```java
class ArrayQueueFirst implements MyQueue {
    int[] arr;
    int capacity;
    /*index*/
    int head = 0;
    int tail = 0;

    public ArrayQueueFirst(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity + 1];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = Integer.MIN_VALUE; // 可以不用，就是覆盖写
        head = (head + 1) % arr.length;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        int nextIndex = (tail + 1) % arr.length;
        return nextIndex == head;
    }
}
```

#### 新增size

- 新增一个size变量，来判断队列是空还是满

![image-20231014110115755](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110115755.png)

```java
class ArrayQueueSecond implements MyQueue {
    private int head;
    private int tail;
    private int size;
    private int capacity;
    private int[] arr;

    public ArrayQueueSecond(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }

        arr[tail] = val;
        tail = (tail + 1) % capacity;
        size++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = Integer.MIN_VALUE;
        head = (head + 1) % capacity;
        size--;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size >= capacity;
    }
}
```

#### head/tail自增

![image-20231014110521963](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110521963.png)

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算

```java
class ArrayQueueThird implements MyQueue {
    private int capacity;
    private int[] arr;
    private int head = 0;
    private int tail = 0;

    public ArrayQueueThird(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[(tail + 1) % capacity] = val;
        tail++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head % capacity];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head % capacity];
        head++;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        return head - tail >= capacity;
    }
}
```

## 2. 双端队列

- 两端都可以进行删除，添加
- Deque: Double Ended Queue

```java
interface Deque {
    boolean offerFirst(int val);

    boolean offerLast(int val);

    int pollFirst();

    int pollLast();

    int peekFirst();

    int peekLast();

    boolean isEmpty();

    boolean isFull();
}
```

### 2.1 链表实现-双向环形链表

![image-20231019172058116](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231019172058116.png)

```java
class LinkedListDeque implements Deque {

    static class Node {
        int val;
        Node next;
        Node prev;

        public Node(int val, Node prev, Node next) {
            this.val = val;
            this.prev = prev;
            this.next = next;
        }
    }

    private int size;     // 当前队列的大小
    private int capacity;  //容量

    private Node sentinel = new Node(Integer.MAX_VALUE, null, null);

    public LinkedListDeque(int capacity) {
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
        this.capacity = capacity;
    }

    /*head和tail自己定义*/
    @Override
    public boolean offerFirst(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val, null, null);
        Node next = sentinel.next; // 下一个元素
        sentinel.next = inserted;
        inserted.prev = sentinel;
        inserted.next = next;
        next.prev = inserted;
        size++;
        return true;
    }

    @Override
    public boolean offerLast(int val) {
        if (isFull()) {
            return false;
        }
        Node prev = sentinel.prev;
        Node inserted = new Node(val, null, null);
        inserted.next = sentinel;
        sentinel.prev = inserted;
        prev.next = inserted;
        inserted.prev = prev;
        size++;
        return true;
    }

    @Override
    public int pollFirst() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        Node pollElement = sentinel.next;
        Node next = pollElement.next;
        sentinel.next = next;
        next.prev = sentinel;
        size--;
        return pollElement.val;
    }

    @Override
    public int pollLast() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        Node pollElement = sentinel.prev;
        Node prev = pollElement.prev;
        prev.next = sentinel;
        sentinel.prev = prev;
        size--;
        return pollElement.val;
    }

    @Override
    public int peekFirst() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.next.val;
    }

    @Override
    public int peekLast() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.prev.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

### 2.2 环形数组

- 实现思路和上面的普通队列的基本相同

## 3. 优先级队列

- 数组的对象多了一个优先级的属性

```java
class Entry {
    int val;
    int priority;
}
```

### 3.1 无序数组实现

![image-20231020120223645](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231020120223645.png)

```java
class PriorityQueue {
    private Entry[] arr;
    private int capacity;
    private int size;

    public PriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        arr[size] = entry;
        size++;
        return true;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        int index = selectMaxIndex();
        Entry result = arr[index];
        remove(index);
        return result;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        int index = selectMaxIndex();
        return arr[index];
    }

    private int selectMaxIndex() {
        int maxP = 0;
        for (int i = 1; i < size; i++) {
            if (arr[i].priority > arr[maxP].priority) {
                maxP = i;
            }
        }
        return maxP;
    }

    private void remove(int index) {
        if (index == size - 1) {
            arr[index] = null;
        } else { // 进行复制拷贝
            System.arraycopy(arr, index + 1, arr, index, size - 1 + index);
            arr[size - 1] = null;
        }
        size--;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```

### 3.2 有序数组实现

- 插入时候进行插入排序，弹出时，只需要弹出数尾部的元素

![image-20231022103506620](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231022103506620.png)

```java
class SortedArrayPriorityQueue {
    private Entry[] arr;

    private int capacity;
    private int size;

    public SortedArrayPriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        insert(entry);
        return true;
    }

    /*插入排序*/
    private void insert(Entry entry) {
        int p = size - 1;
        while (p > 0 && arr[p].priority > entry.priority) {
            arr[p + 1] = arr[p];
            p--;
        }
        arr[p + 1] = entry;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        Entry entry = arr[size - 1];
        arr[size - 1] = null;
        return entry;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        return arr[size - 1];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```



```java

```

```java
class ArrayQueue implements Queue {

    private int capacity;
    private int size;

    private int[] arr;

    private int tail;

    private int head;

    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int data) {
        if (isFull()) {
            return false;
        }
        arr[tail] = data;
        tail = (tail + 1) % capacity;
        size++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = 888;
        size--;
        head = (head + 1) % capacity;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

# 堆

- 方式一：基于树的数据结构，通常使用完全二叉树来实现
- 方式二：可以用数组来进行存储

## 1. 大顶堆/小顶堆

```bash
# 大顶堆： 任意节点都小于其父节点
# 小顶堆： 任意节点都大与其父节点
- 左节点和右节点关系不定

# 索引原则：索引0开始存储，i表示索引
- 节点i的父节点：       floor((i-1)/2)      当i大于0时
- 节点i的左子节点为：    2i+1                结果不能大于size
- 节点i的右子节点为：    2i+2                结果不能大于size
```

![image-20231023190718489](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023190718489.png)

## 2. MaxHeap

```java
package com.citi.heap;

public interface MaxHeap {
    /*头尾交换，并下潜*/
    int poll();

    void down(int parent);

    /*尾部添加：并上浮*/
    boolean offer(int data);

    void up(int child);

    boolean isFull();

    boolean isEmpty();
}
```

### 2.1 offer

```bash
# 威廉姆斯算法
- 入堆新元素，加入到数组末尾
- 不断比较新加元素与其父节点的值
    - 父节点更小，则父节点向下移动，继续向上找parent
    - 直到父节点值更大
```

![image-20231023172249031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023172249031.png)

### 2.2 poll

```bash
# poll： 删除堆顶处的元素
- 堆顶元素 和最后一个元素交换
- 删除最后一个元素
- 对堆顶元素进行下潜

# 下潜： 比左右孩子最大的小
- 比较当前节点的值和左右孩子的值
- 如果当前节点的值比左右孩子最大的小，则交换
```

### 2.3 heapify

```bash
# 方式一：威廉姆斯算法，旧数组，一个个offer进去

# 方式二：弗洛伊德算法):  对既有数组进行重排，
- 找到最后一个非叶子节点
- 从后向前，对每个节点执行下潜（比较左右值）

    # 非叶子节点
   - 没有任何一个左孩子或者右孩子
   - 最后一个元素的父节点
```

![image-20231023152506251](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023152506251.png)

```java
package com.citi.heap;

public class ArrayMaxHeap implements MaxHeap {

    private int[] arr;
    private int size;

    private int capacity;

    public ArrayMaxHeap(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    /*现有数组构建:*/
    public ArrayMaxHeap(int[] input, int capacity) {
        this(capacity);
        if (input.length <= capacity) {
            size = input.length;
            System.arraycopy(arr, 0, input, 0, input.length);
            heapfiy(arr);
        } else {
            size = arr.length;
            System.arraycopy(arr, 0, input, 0, capacity);
            heapfiy(arr);
        }
    }

    private void heapfiy(int[] arr) {
        int lastIndex = size / 2 - 1;
        for (int i = lastIndex; i >= 0; i--) {
            down(i);
        }
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int res = arr[0];

        swap(0, size - 1);
        arr[size - 1] = Integer.MIN_VALUE;
        down(0);
        size--;
        return res;
    }

    @Override
    public void down(int parent) {
        int left = 2 * parent + 1;
        int right = 2 * parent + 2;
        int max = parent;
        if (left < size && arr[left] > arr[max]) {
            max = left;
        }
        if (right < size && arr[right] > arr[max]) {
            max = right;
        }
        if (parent != max) {
            swap(parent, max);
            down(max);
        }
    }

    @Override
    public boolean offer(int data) {
        if (isFull()) {
            return false;
        }

        arr[size] = data;
        up(size);
        size++;
        return true;
    }

    @Override
    public void up(int child) {
        int val = arr[child];
        int parent = (child - 1) / 2;
        while (arr[parent] < val && child > 0) {
            arr[child] = arr[parent];
            child = parent;
            parent = (child - 1) / 2;
        }
        arr[child] = val;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 3. JDK-PriorityQueue

```java
PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> (b - a));      // 大顶堆
PriorityQueue<Integer> min = new PriorityQueue<>((a, b) -> (a - b));      // 小顶堆
```



## 4. LeetCode

### ❤️[数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

```bash
# 小顶堆(堆底元素就是第k大的)
# 方法类似大顶堆
- 1. 将前k个元素加入到数组中，并heapify成小顶堆
- 2. 后续数组元素依次入和堆顶元素比较
    - 2.1 如果比堆顶大，则替换堆顶元素，并下潜
    - 2.2 如果比堆顶小或等，则什么也不做
- 3. 返回堆顶元素 
```

![image-20231026112424150](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231026112424150.png)

```java
// JDK提供的小顶堆
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> stack = new PriorityQueue<>(k, Comparator.comparingInt(a -> a));
    for (int i = 0; i < k; i++) {
        stack.add(nums[i]);
    }

    for (int i = k; i < nums.length; i++) {
        if (nums[i] > stack.peek()) {
            stack.poll();
            stack.add(nums[i]);
        }
    }
    return stack.peek();
}
```

### 4.2 数据流中的第K大元素 - 321

```bash
# 给定整数数组 nums 和整数 k，返回数组中第k个最大的元素
# 可以给数组不断添加新的元素，依然返回第K个最大的元素
#  数组初始可能为null，数据可能为负数
# 题目数据保证，在查找第 k 大元素时，数组中至少有 k 个元素

# 解题思路类似上面
- 1.构建大小为k的小顶堆: 数据为Integer.MIN_VALUE
- 2.逐个添加顶部元素，并进行下潜
```

```java
class KthLargest {

    private MinHeap minHeap;

    public KthLargest(int k, int[] nums) {
        minHeap = new MinHeap(k);
        for (int i = 0; i < nums.length; i++) {
            minHeap.add(nums[i]);
        }
    }

    public int add(int val) {
        minHeap.add(val);
        return minHeap.arr[0];
    }
}

class MinHeap {
    int[] arr;
    int size;
    int capacity;

    public MinHeap(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
        Arrays.fill(arr, Integer.MIN_VALUE);
        size = capacity;
    }

    public void add(int data) {
        if (data > arr[0]) {
            arr[0] = data;
            down(0);
        }
    }

    private void down(int parent) {
        int left = parent * 2 + 1;
        int right = parent * 2 + 2;
        int min = parent;
        if (left < size && arr[left] < arr[min]) {
            min = left;
        }
        if (right < size && arr[right] < arr[min]) {
            min = right;
        }
        if (min != parent) {
            swap(min, parent);
            down(min);
        }
    }

    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 4.3 数据流的中位数

```bash
输入： 2,3,4,     输出：3
输入：1，2，3，4， 输出：2.5

# 思路：构建一个大顶堆，一个小顶堆，确保大顶堆的堆顶元素小于小顶堆的堆顶元素
# add
- 两边个数一样时，左边个数加一
- 两边个数不一样时，右边加一
# add规则
- 左边添加时，把新元素添加在右，弹出右边堆顶元素加入左边
- 右边逻辑类似
```

![image-20231029104600488](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029104600488.png)

```java
class MedianFinder {

    PriorityQueue<Integer> max = new PriorityQueue<>((a, b) -> (b - a));
    PriorityQueue<Integer> min = new PriorityQueue<>((a, b) -> (a - b));

    public MedianFinder() {
    }

    public void addNum(int num) {
        if (max.size() == min.size()) {
            // 添加到大顶堆
            min.add(num); // 添加后还是有序的堆
            Integer data = min.poll();
            max.add(data);
        } else {
            // 添加到小顶堆
            max.add(num);
            Integer data = max.poll();
            min.add(data);
        }
    }

    public double findMedian() {
        if (max.size() == min.size()) {
            return (max.peek() + min.peek()) / 2.0;
        } else {
            return max.peek();
        }
    }
}
```



# 栈

- 只能从数据结构的两端进行操作，先进后出

![image-20231016113311031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016113311031.png)

```java
interface Stack {
    /*加数据*/
    boolean push(int val);
    /*弹出数据*/
    int pop();
    /*不弹出数据*/
    int peek();
    boolean isEmpty();
    boolean isFull();
}
```

## 1. 实现方式

### 1.1 链表实现

![image-20231016115640568](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016115640568.png)

```java
class LinkedListStack implements Stack {

    private int capacity;

    private int size;

    private Node sentinel = new Node(Integer.MIN_VALUE, null);

    public LinkedListStack(int capacity) {
        this.capacity = capacity;
    }

    static class Node {
        int val;
        Node next;

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        sentinel.next = new Node(val, sentinel.next);
        size++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int val = sentinel.next.val;
        sentinel.next = sentinel.next.next;
        size--;
        return val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.next.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size >= capacity;
    }
}
```

### 1.2 数组实现

```java
/*
 *  底          顶
 *  0   1   2   3
 *  a   b   c   d
 *
 *  top一开始为0，表示为空
 *  top增长到4(数组长度)，表示为满
 * */
class ArrayStack implements Stack {

    private int capacity;

    private int[] arr;

    private int top;

    public ArrayStack(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        arr[top] = val;
        top++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        top--;
        int result = arr[top];
        arr[top] = Integer.MAX_VALUE;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[top - 1];
    }

    @Override
    public boolean isEmpty() {
        return top == 0;
    }

    @Override
    public boolean isFull() {
        return top == capacity;
    }
}
```

### 1.3 JDK实现

- LinkedList

## 2. leetcode

### 2.1 有效的括号-20

```bash
# 输入： ()[]{}     输出：true
# 输入： {[}        输出：false
0. 长度为奇数，直接返回错误
1. 遇见左括号，则在栈中添加右括号
2. 遇见右括号，如果和栈顶元素相同，则弹出(空元素)；    如果不同，则直接返回错误
3. 最后栈的长度要为空
```

```java
 public boolean isValid(String s) {
        LinkedList<Character> list = new LinkedList();
        char[] charArray = s.toCharArray();
        if (charArray.length % 2 != 0) {
            return false;
        }

        for (char ch : charArray) {
            if (ch == '{') {
                list.push('}');
            } else if (ch == '[') {
                list.push(']');
            } else if (ch == '(') {
                list.push(')');
            } else if (list.isEmpty() || ch != list.pop()) {
                return false;
            }
        }
        return list.isEmpty();
    }
```

### 2.2 比较含退格的元素-844

```bash
# 比较两个字符串是否相等， # 代表回退删除一个空格
```

```java
public boolean backspaceCompare(String s, String t) {
        LinkedList<Character> first = processStr(s);
        LinkedList<Character> second = processStr(t);
        if (first.size() != second.size()) {
            return false;
        }
        while (first.size() != 0) {
            Character firstEl = first.pop();
            Character secondEl = second.pop();
            if (!firstEl.equals(secondEl)) {
                return false;
            }
        }
        return true;
    }

    private LinkedList<Character> processStr(String s) {
        LinkedList<Character> list = new LinkedList<>();
        for (char ch : s.toCharArray()) {
            if (ch == '#') {
                if (!list.isEmpty()) {
                    list.pop();
                }
            } else {
                list.push(ch);
            }
        }
        return list;
    }
```

### 2.3 逆波兰表达式

#### 后缀表达式求值-150

- 运算符号在数字的后面，这样就不用考虑优先级问题

```bash
# 1. 碰见符号就把前面两个数字弹出栈
# 2. 运算完成后重新入栈

# 输入：tokens = ["2","1","+","3","*"]， 输出：9
```

```java
public int evalRPN(String[] tokens) {
      LinkedList<Integer> list = new LinkedList();
      List<String> calToken = new ArrayList<>();
      calToken.add("+");
      calToken.add("-");
      calToken.add("*");
      calToken.add("/");
      for (String token : tokens) {
          if (calToken.contains(token)) {
              Integer second = list.pop();
              Integer first = list.pop();
              int result = calculate(first, second, token);
              list.push(result);
          } else {
              list.push(Integer.valueOf(token));
          }
      }
      return list.pop();
  }

  private int calculate(int first, int second, String token) {
      switch (token) {
          case "+":
              return first + second;
          case "-":
              return first - second;
          case "*":
              return first * second;
          case "/":
              return first / second;
          default:
              throw new IllegalArgumentException();
      }
  }
```

#### 中缀表达式转后缀

### 2.4 双栈模拟队列-232

- 出的时候，先把当前的outStack中出完，再去倒手

![image-20231018120502207](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231018120502207.png)

```java
class MyQueue {
    LinkedList<Integer> inStack = new LinkedList<>();
    LinkedList<Integer> outStack = new LinkedList<>();

    public MyQueue() {
    }

    public void push(int x) {
        inStack.push(x);
    }

    public int pop() {
        if (empty()) {
            return Integer.MIN_VALUE;
        }

        if (!outStack.isEmpty()) {
            return outStack.pop();
        }

        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
        return outStack.pop();
    }

    public int peek() {
        if (empty()) {
            return Integer.MIN_VALUE;
        }

        if (!outStack.isEmpty()) {
            return outStack.peek();
        }

        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
        return outStack.peek();
    }

    public boolean empty() {
        return inStack.size() == 0 && outStack.size() == 0;
    }
}
```

### 2.5 单队列模拟栈-225

```bash
# 1. 反转队列: 队列中添加元素时候，先判断是否为空
- 为空，  offer添加
- 不会空， 先offer添加，然后把其他的元素先出队列，再重新进
```

![image-20231018123135569](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231018123135569.png)

```java
class MyStack {

    private Queue<Integer> queue = new ArrayDeque();

    public MyStack() {
    }

    public void push(int x) {
        queue.offer(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.offer(queue.poll());
        }
    }

    public int pop() {
        return queue.poll();
    }

    public int top() {
        return queue.peek();
    }

    public boolean empty() {
        return queue.size()==0;
    }
}
```

# 哈希

## 1. 思想

![image-20231113094946264](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231113094946264.png)

- 给每个数据分配一个编号，放入数组表格
- 编号和表格索引的关系，可以通过编号来快速查找数据

```bash
# 数据结构
- 建立一个数组来存储所有的数据
- 每个数据实体，包含一个key和一个value
- 通过key来映射到数组索引，然后将数据存储在该索引处
- 每个索引只存放一个数据

# 理想情况
- 每个数据实体，key唯一，数组足够大，能存放所有数据
- 每个数组只存放一个数据
  # 优点
  - 时间复杂度为O(1)，只需要根据key找到数组索引位置即可
  # 缺点
  - 数组的内存连续，因此大数组对内存要求苛刻

# 拉链法则
- 有限长度的数组
- key允许重复，允许多个key对应同一个索引
- 一个索引处的数据，通过链表来连接
- 时间复杂度会增加
```

```bash
# key(hash)
- 数据的key，通过某种规则，可以映射到数组的某个索引上
- 如果一个数组的存储元素过多，则需要遍历链表，时间复杂度增加

# hash算法
- 在添加数据的时候，用户没办法保证key的分散性，因此一般会根据具体的value，尽可能来生成一个唯一的key，即hash
```

## 2. 哈希码

### 2.1 哈希算法

- 一种将任意长度的任意数据，通过算法，转换为<font color=orange>固定长度数据</font>的过程，这个固定长度的数据就是hash值
- MD5，SHA1，SHA256，SHA512， CRC32等
- 计算hash值时，考虑原始数据的每个字节，一旦改动原始数据的任何一个字节，对应hash值都会有明显不同
- 摘取了原始数据的一些特征，某种程度上能代表原始数据
- 被广泛用于数据完整性校验和加密方面

### 2.2 实现方式

#### Object-hashCode

```java
/*同一个对象的hash值相同*/
public void test01() {
    Object obj = new Object();
    for (int i = 0; i < 100; i++) {
        int result = obj.hashCode();
        System.out.println(result); // 757108857
    }
}

/*不同对象的hash值不同*/
public void test02() {
    for (int i = 0; i < 100; i++) {
        Object obj = new Object();
        int result = obj.hashCode();
        System.out.println(result);
    }
}
```

#### 权重Hash

- 利用不同的权重，经验表明，选取质数31，哈希冲突的概率比较低

```java
 /**
 * 不同的字段，其hash的权重不同
 * field1*31 + field2*31*31 + field3*31*31*31 +...
 *
 * @param objs
 * @return
 */
public static int getHash(Object... objs) {
    if (objs == null) {
        return 0;
    }

    int result = 1;
    for (Object obj : objs) {
        if (obj == null) {
            result = result * 31;
        } else {
            result = result * 31 + obj.hashCode();
        }
    }
    return result;
}
```

```java
 /**
   * 优化：乘法变成位运算
   *
   * @param objs
   * @return
   */
  public static int getHash(Object... objs) {
      if (objs == null) {
          return 0;
      }

      int result = 1;
      for (Object obj : objs) {
          if (obj == null) {
              result = result << 5 - result;
          } else {
              result = result << 5 - result + obj.hashCode();
          }
      }
      return result;
  }
```

#### MurmurHash

- 快速计算：相对于其他哈希函数，具有更快的计算速度
- 低碰撞率：处理一亿个数据，最多只有两个冲突
- 随机性强：能够很好的保持数据的随机性

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>32.1.2-jre</version>
</dependency>
```

```java
// 对不同类型数据进行hash
int i = Hashing.murmur3_32_fixed().hashInt(3).asInt();
```

## 3. Entity

```java
class Entry {
    Object key; // 会根据key，来生成对应的hash
    Object value;
    Entry next;

    public Entry(Object key, Object value) {
        this.key = key;
        this.value = value;
    }
}
```

## 4. HashTable

### 4.1 hash-index映射

- 根据对应的hash(int类型的大的数字，根据数组长度来求模)
- 数组长度为2的次方时，求模可以转换为位运算，效率更高

![image-20231113160711854](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231113160711854.png)

```java
private int getHash(Object key) {
    return key.hashCode();
}

/**
 * 数组长度是2的n次方，可以用位运算来代替求模运算
 *
 * @param hash ： 是一个比较大的随机int整数
 */
private int getIndex(int hash) {
    return hash & table.length - 1;
}
```

### 4.2 resize

- 如果不添加resize，则最终随着数据越来越多，数组上的链表也会越来越长
- 添加数据完成后，进行resize适当扩容，尽可能保证数组每个都只存放一个元素

```bash
# hash冲突 (即使存在扩容)
- 不同的key，最终得到的hash一样，就会得到相同的index
- 不同的key，hash虽然不同，但是求得到的index是一样的

# 最终结果
- 数组的某些位置上，元素的个数超过1
```

#### 拆分规律

- 一个链表最多拆成两个
- hash & table.length==0的一组
- hash & table.length!=0的一组

### 4.3 get

```java
public Object get(Object key) {
    int hash = getHash(key);
    int targetIndex = getIndex(hash);
    if (table[targetIndex] == null) {
        return null;
    }
    // 遍历链表
    Entry entry = table[targetIndex];
    while (entry != null) {
        if (entry.key.equals(key)) {
            return entry.value;
        }
        entry = entry.next;
    }
    return null;
}
```

### 4.4 put

```java
// key重复，则更新，key不存在，则尾部添加
public void put(Object key, Object value) {
    int hash = getHash(key);
    int targetIndex = getIndex(hash);

    if (table[targetIndex] == null) {
        table[targetIndex] = new Entry(key, value);
    } else {// 遍历寻找
        Entry entry = table[targetIndex];
        while (entry != null) {
            if (entry.key.equals(key)) {
                entry.value = value; // 更新
                return;
            }
            if (entry.next == null) {
                break;
            }
            entry = entry.next;
        }
        entry.next = new Entry(key, value);
    }

    size++;
    if (size > threshold) {
        resize();
    }
}
```

### 4.5 remove

```java
public Object remove(Object key) {
    int hash = getHash(key);
    int targetIndex = getIndex(hash);

    Entry entry = table[targetIndex];
    if (entry == null) {
        return null;
    }

    Entry prev = null;
    while (entry != null) {
        if (entry.key.equals(key)) {
            if (prev == null) {
                table[targetIndex] = entry.next;
            } else {
                prev.next = entry.next;
            }
            size--;
            return entry.value;
        }
        prev = entry;
        entry = entry.next;
    }
    return null;
}
```
