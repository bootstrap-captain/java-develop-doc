# äºŒå‰æ ‘

## 1. åŸºæœ¬æ¦‚å¿µ

```bash
# äºŒå‰æ ‘
- æ¯ä¸ªèŠ‚ç‚¹ï¼Œæœ€å¤šåªå­˜åœ¨ä¸¤ä¸ªå­èŠ‚ç‚¹

# æ ¹èŠ‚ç‚¹
- äºŒå‰æ ‘çš„èµ·å§‹èŠ‚ç‚¹

# å¶å­èŠ‚ç‚¹
- æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹

# æ»¡äºŒå‰æ ‘
- æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå¶å­èŠ‚ç‚¹

# å®Œå…¨äºŒå‰æ ‘
- å…¶ä½™å±‚éƒ½å¿…é¡»å¡«æ»¡ï¼Œæœ€åä¸€å±‚å¯å¡«æ»¡å¯ä¸å¡«æ»¡
- æœ€åä¸€å±‚ï¼šå¿…é¡»ä»å·¦å‘å³å¡«å……
- å †çš„å®ç°å°±æ˜¯

# å®ç°æ–¹å¼
- æ•°ç»„
- TreeNode
```

```java
package com.citi.tree;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 2. å¹¿åº¦ä¼˜å…ˆ

- å±‚åºéå†ï¼Œ Breadth-first order
- å°½å¯èƒ½å…ˆè®¿é—®è·ç¦»æ ¹èŠ‚ç‚¹æœ€è¿‘çš„èŠ‚ç‚¹

```bash
# é˜Ÿåˆ—æ€è·¯
- æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
- å¤´å¼¹å‡ºï¼Œå¤„ç†å½“å‰èŠ‚ç‚¹ï¼Œç„¶åå°†å½“å‰èŠ‚ç‚¹çš„å·¦å³å­©å­ä¾æ¬¡å…¥é˜Ÿ
- ç›´åˆ°é˜Ÿåˆ—ä¸ºç©º
```

![image-20231014115013816](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014115013816.png)

### ğŸ˜åŸºç¡€æ‰“å°

- ä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³ï¼Œå±‚åºæ‰“å°

#### è¿­ä»£+é˜Ÿåˆ—

```java
public void printTree(TreeNode root) {
    LinkedList<TreeNode> path = new LinkedList<>();
    path.offer(root);

    while (!path.isEmpty()) {
        TreeNode element = path.pop();
        System.out.println(element.val); // å¤„ç†å½“å‰èŠ‚ç‚¹
        // å·¦èŠ‚ç‚¹
        if (element.left != null) {
            path.offer(element.left);
        }
        // å³ç»“ç‚¹
        if (element.right != null) {
            path.offer(element.right);
        }
    }
}
```

#### é€’å½’



### ğŸ˜¡[ 102/107 äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- 102é¢˜ç›®: ä»ä¸Šåˆ°ä¸‹ï¼Œæ¯å±‚æŒ‰ç…§ä»å·¦åˆ°å³å°è£…ç»“æœï¼š result.add(subResult);
- 107é¢˜ç›®: ä»å°åˆ°ä¸Šï¼Œæ¯å±‚æŒ‰ç…§ä»å·¦åˆ°å³å°è£…ç»“æœï¼š result.add(0, subResult);

#### è¿­ä»£ + é˜Ÿåˆ—

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    // å¤„ç†
    LinkedList<TreeNode> path = new LinkedList<>();
    path.offer(root);
    int curLayerSize = 1;
    while (!path.isEmpty()) {
        int nextLayerSize = 0;
        List<Integer> subResult = new ArrayList<>();
        for (int i = 0; i < curLayerSize; i++) { // å½“å‰å±‚å¤„ç†å‡ ä¸ªèŠ‚ç‚¹
            TreeNode element = path.pop();
            subResult.add(element.val);
            if (element.left != null) {
                path.offer(element.left);
                nextLayerSize++;
            }
            if (element.right != null) {
                path.offer(element.right);
                nextLayerSize++;
            }
        }
        result.add(subResult);
        curLayerSize = nextLayerSize;
    }
    return result;
}
```

### ğŸ˜¡[103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

#### è¿­ä»£ + é˜Ÿåˆ—

- ä»ä¸Šåˆ°å°ï¼ŒæŒ‰ç…§ä¸€å±‚å·¦å³ï¼Œä¸€å±‚å³å·¦çš„é¡ºåº 
-  å¥‡æ•°å±‚ä»å·¦åˆ°å³ï¼Œå¶æ•°å±‚ä»å³åˆ°å·¦ï¼Œå’Œä¸Šé¢å¤„ç†ç±»ä¼¼

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
      List<List<Integer>> result = new ArrayList<>();
      if (root == null) {
          return result;
      }

      LinkedList<TreeNode> path = new LinkedList<>();
      path.offer(root);
      int curLayerSize = 1;
      boolean flag = true;

      while (!path.isEmpty()) {
          LinkedList<Integer> subResult = new LinkedList<>();
          int nextLayerSize = 0;
          for (int i = 0; i < curLayerSize; i++) {
              TreeNode element = path.pop();
              /*ç”¨flagè¿›è¡Œæ ‡è®°*/
              if (flag) {
                  subResult.add(element.val);
              } else {
                  subResult.add(0, element.val);
              }

              if (element.left != null) {
                  path.offer(element.left);
                  nextLayerSize++;
              }

              if (element.right != null) {
                  path.offer(element.right);
                  nextLayerSize++;
              }
          }
          curLayerSize = nextLayerSize;
          flag = !flag;
          result.add(subResult);
      }
      return result;
  }
```

## 3. æ·±åº¦ä¼˜å…ˆ

- æ¯æ¬¡éå†çš„æ—¶å€™ï¼Œéƒ½éœ€è¦æ·±å…¥åˆ°å¶å­èŠ‚ç‚¹
- éå†é¡ºåºï¼šæ˜¯å¯¹äºæ¯ä¸€ä¸ªå­æ ‘è€Œè¨€çš„
- éƒ½æ˜¯ä»å·¦å‘å³å¤„ç†çš„

### 3.0 éå†é¡ºåº

#### å‰åºéå†

- å…ˆå¤„ç†çˆ¶èŠ‚ç‚¹ï¼Œå†å¤„ç†å­èŠ‚ç‚¹

![image-20231029161521912](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161521912.png)

#### ä¸­åºéå†

- å¤„ç†å­èŠ‚ç‚¹çš„ä¸­é—´ï¼Œå¤„ç†çˆ¶èŠ‚ç‚¹

![image-20231029161415584](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161415584.png)

#### ååºéå†

- å…ˆå¤„ç†å­èŠ‚ç‚¹ï¼Œå†å¤„ç†çˆ¶èŠ‚ç‚¹

![image-20231029161334384](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161334384.png)

### 3.1 é€’å½’å®ç°

```java
class Solution {
    static TreeNode root = new TreeNode(1, new TreeNode(2,
            new TreeNode(4, new TreeNode(7), new TreeNode(8)),
            null),
            new TreeNode(3, new TreeNode(5, new TreeNode(9), new TreeNode(11)),
                    new TreeNode(6, new TreeNode(12), null)));

    /* å‰åºéå†ï¼š1ï¼Œ2ï¼Œ4ï¼Œ7ï¼Œ8ï¼Œ3ï¼Œ5ï¼Œ9ï¼Œ11ï¼Œ6ï¼Œ12*/
    List<Integer> preResult = new ArrayList<>();

    /* ä¸­åºéå†ï¼š 7ï¼Œ4ï¼Œ8ï¼Œ2ï¼Œ1ï¼Œ9ï¼Œ5ï¼Œ11ï¼Œ3ï¼Œ12ï¼Œ6*/
    List<Integer> inResult = new ArrayList<>();

    /* ååºéå†ï¼š 7, 8, 4, 2, 9, 11, 5, 12, 6, 3, 1*/
    List<Integer> postResult = new ArrayList<>();

    public List<Integer> preorderTraversal(TreeNode root) {
        preOrder(root);
        return preResult;
    }

    /*å‰åº*/
    private void preOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        preResult.add(root.val);
        preOrder(root.left);
        preOrder(root.right);
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        inOrder(root);
        return inResult;
    }

    /*ä¸­åº*/
    private void inOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        inOrder(root.left);
        inResult.add(root.val);
        inOrder(root.right);
    }


    public List<Integer> postorderTraversal(TreeNode root) {
        postOrder(root);
        return postResult;
    }

    /*ååº*/
    private void postOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        postResult.add(root.val);
    }
}
```

### 3.2 æ ˆå®ç°

```java
class Solution {
    /*å‰åºéå†*/
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> path = new LinkedList<>();
        TreeNode cur = root;
        while (cur != null || !path.isEmpty()) {
            if (cur != null) {     // å·¦è¾¹çš„è¿˜æ²¡èµ°å®Œ
                result.add(cur.val);
                path.push(cur);         // è®°ä½å›æ¥çš„è·¯
                cur = cur.left;
            } else {             // åº”è¯¥èµ°å³è¾¹çš„äº†
                TreeNode pop = path.pop();
                cur = pop.right;
            }
        }
        return result;
    }

    /*ä¸­åºéå†*/
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> path = new LinkedList<>();
        TreeNode cur = root;
        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode pop = path.pop();
                result.add(pop.val);
                cur = pop.right;
            }
        }
        return result;
    }

    /*ååºéå†*/
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> path = new LinkedList<>();
        TreeNode cur = root;
        TreeNode recentPop = null;

        while (cur != null || !path.isEmpty()) {
            if (cur != null) {     // å·¦å­æ ‘å·²ç»å¤„ç†å®Œäº†
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode peek = path.peek();
                if (peek.right == null || peek.right == recentPop) {    // å³å­æ ‘å·²ç»å¤„ç†å®Œäº†æ‰èƒ½pop: å³å­æ ‘ä¸ºnull
                    TreeNode pop = path.pop();
                    recentPop = pop;
                    result.add(pop.val);
                } else {
                    cur = peek.right;
                }
            }
        }
        return result;
    }
}
```

## 4. LeetCode

### 4.1 å¯¹ç§°äºŒå‰æ ‘ - 101

```java
// é€’å½’å®ç°
public boolean checkSymmetricTree(TreeNode root) {
    if (root==null){
        return true;
    }
    return check(root.left, root.right);
}

public boolean check(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }

    if (left == null || right == null) {
        return false;
    }

    if (left.val != right.val) {
        return false;
    }

    return check(left.left, right.right) && check(left.right, right.left);
}
```

### ğŸ˜[104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

#### å±‚åºéå†

- æŒ‰ç…§ä¸€å±‚æ¥åšç»“æœé›†åˆï¼Œæ€»å…±æœ‰å‡ å±‚ï¼Œå°±æ˜¯æœ€å¤§æ·±åº¦

```java
public int maxDepth(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> path = new LinkedList<>();
    path.offer(root);

    int curLayerSize = 1;
    while (!path.isEmpty()) {
        int nextLayerSize = 0;
        List<Integer> subResult = new ArrayList<>();
        for (int i = 0; i < curLayerSize; i++) {
            TreeNode element = path.pop();
            subResult.add(element.val);
            if (element.left != null) {
                path.offer(element.left);
                nextLayerSize++;
            }

            if (element.right != null) {
                path.offer(element.right);
                nextLayerSize++;
            }
        }
        result.add(subResult);
        curLayerSize = nextLayerSize;
    }
    return result.size();
}
```



#### é€’å½’

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null && root.right == null) {
        return 1;  // å¶å­èŠ‚ç‚¹
    }
    return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
}
```

#### ååºéå†

- ååºéå†ï¼Œæ¯æ¬¡popçš„æ—¶å€™ï¼Œè®°å½•ä¸€ä¸‹popå‰çš„æœ€å¤§è·¯å¾„
- å–æœ€å¤§å€¼å³å¯

```java
public int maxDepth(TreeNode root) {
    int max = 0;
    if (root == null) {
        return max;
    }

    TreeNode cur = root;
    LinkedList<TreeNode> path = new LinkedList<>();

    TreeNode recentPop = null;
    while (cur != null || !path.isEmpty()) {
        if (cur != null) {
            path.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = path.peek();
            if (peek.right == null || peek.right == recentPop) {
                max = Math.max(max, path.size());
                recentPop = path.pop();
            } else {
                cur = peek.right;
            }
        }
    }
    return max;
}
```

### ğŸ˜[111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

#### å±‚åºéå†

- å±‚åºéå†ä¸€æ¬¡ï¼šé‡åˆ°çš„ç¬¬ä¸€ä¸ªå¶å­ç»“ç‚¹æ‰€åœ¨çš„å±‚ï¼Œå°±æ˜¯æœ€å°æ·±åº¦

![image-20231030175543994](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231030175543994.png)

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> path = new LinkedList<>();
    path.offer(root);
    int curLayerSize = 1;
    int result = 1;

    while (!path.isEmpty()) {
        int nextLayerSize = 0;
        for (int i = 0; i < curLayerSize; i++) {
            TreeNode element = path.pop();
            if (element.left == null && element.right == null) {
                return result;
            }
            if (element.left != null) {
                path.offer(element.left);
                nextLayerSize++;
            }

            if (element.right != null) {
                path.offer(element.right);
                nextLayerSize++;
            }
        }
        curLayerSize = nextLayerSize;
        result++;
    }
    return result;
}
```

### 4.4 ç¿»è½¬äºŒå‰æ ‘ - 226

- äºŒå‰æ ‘çš„å·¦å³å­©å­è¿›è¡Œå˜æ¢

#### é€’å½’

```java
/*äºŒå‰æ ‘ç¿»è½¬*/
public TreeNode mirrorTree(TreeNode root) {
    mirror(root);
    return root;
}

private void mirror(TreeNode root) {
    if (root == null) {
        return;
    }

    // äº¤æ¢å½“å‰å±‚
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
    // ç»§ç»­ç¿»è½¬å·¦å³å­æ ‘
    mirror(root.left);
    mirror(root.right);
}
```

# äºŒå‰æœç´¢æ ‘

- æ ‘èŠ‚ç‚¹å¢åŠ keyï¼Œæ¯”è¾ƒè°å¤§è°å°ï¼Œkeyä¸å¯é‡å¤
- æ‰€æœ‰æ ‘èŠ‚ç‚¹ï¼Œkeyæ¯”å·¦å­æ ‘çš„keyéƒ½å¤§ï¼ŒåŒæ—¶ä¹Ÿæ¯”å³å­æ ‘çš„keyéƒ½å°
- LeetCodeä¸­ï¼ŒåªåŒ…å«ä¸€ä¸ªå±æ€§ï¼Œæ—¢è¡¨ç¤ºkeyï¼Œä¹Ÿè¡¨ç¤ºvalue

```java
package com.citi.bstree;

public class BSTreeNode {
    int val;
    BSTreeNode left;
    BSTreeNode right;

    public BSTreeNode(int val) {
        this.val = val;
    }

    public BSTreeNode(BSTreeNode left, int val, BSTreeNode right) {
        this.left = left;
        this.val = val;
        this.right = right;
    }
}
```

```java
public class BSTree {
    static BSTreeNode root; // æ ¹ç»“ç‚¹

    /**
     *              6
     *           /     |
     *           4     8
     *          /  |   / |
     *         3   5   7  9
     * 
     */
    static {
        root = new BSTreeNode(new BSTreeNode(new BSTreeNode(3), 4, new BSTreeNode(5)), 6,
                new BSTreeNode(new BSTreeNode(7), 8, new BSTreeNode(9)));
    }
}
```

## 1. æ ¹æ®keyæŸ¥æ‰¾

### 1.1 é€’å½’

```java
public BSTreeNode getByKey(int val) {
    return doGet(root, val);
}

private BSTreeNode doGet(BSTreeNode node, int val) {
    if (node == null) {
        return null;
    }
    if (val == node.val) {
        return node;
    } else if (val < node.val) {
        return doGet(node.left, val);
    } else {
        return doGet(node.right, val);
    }
}
```

### 1.2 éé€’å½’

```java
public BSTreeNode getByKey(int val) {
    BSTreeNode node = root;
    while (node != null) {
        if (node.val == val){
            return node;
        } else if (node.val<val) {
            node = node.right;
        }else{
            node = node.left;
        }
    }
    return null;
}
```

## 2. æœ€å°/å¤§key

- æœ€å°æ˜¯æ‰¾å·¦è¾¹ï¼Œæœ€å¤§æ˜¯æ‰¾å³è¾¹

### 2.1 é€’å½’

```java
  public BSTreeNode getMin() {
      return doMin(root);
  }

  private BSTreeNode doMin(BSTreeNode node) {
      if (node == null) {
          return null;
      }
      if (node.left == null) {
          return node;
      }
      return doMin(node.left);
  }
```

### 2.2 éé€’å½’

```java
public BSTreeNode getMin() {
    BSTreeNode node = root;
    if (node == null) {
        return null;
    }
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
```

## 3. put

- keyå¦‚æœå­˜åœ¨ï¼Œåˆ™æ›´æ–°ï¼Œkeyä¸å­˜åœ¨ï¼Œæ–°å¢å·¦æˆ–å³èŠ‚ç‚¹

```java
public void put(int val) {
    if (root == null) {
        root = new BSTreeNode(val);
    }
    BSTreeNode node = root;
    BSTreeNode prev = null;
    while (node != null) {
        if (node.val == val) {
            return;
        } else if (node.val < val) {
            prev = node;
            node = node.right;
        } else {
            prev = node;
            node = node.left;
        }
    }
    /*å·¦æˆ–å³*/
    BSTreeNode inserted = new BSTreeNode(val);
    if (prev.val < val) {
        prev.right = inserted;
    } else {
        prev.left = inserted;
    }
}
```

## 4. å‰ä»»åä»»

- å¯ä»¥é‡‡ç”¨ä¸­åºéå†çš„æ–¹å¼ï¼Œä½†æ˜¯æ•ˆç‡è¾ƒä½ï¼Œæ²¡æœ‰å……åˆ†åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§

![image-20231105105853330](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231105105853330.png)

```bash
# å‰ä»»
- å…ˆæ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹
- ç›®æ ‡èŠ‚ç‚¹æœ‰å·¦å­æ ‘ï¼Œå‰ä»»å°±æ˜¯å·¦å­æ ‘çš„æœ€å¤§å€¼ï¼š               å¦‚4çš„å‰ä»»å°±æ˜¯3
- ç›®æ ‡èŠ‚ç‚¹æ²¡æœ‰å·¦å­æ ‘ï¼Œå‰ä»»å°±æ˜¯ç¦»å®ƒæœ€è¿‘çš„ï¼Œä»å·¦è¾¹æ¥çš„ç¥–å…ˆï¼š    å¦‚5çš„å‰ä»»å°±æ˜¯4(1æ²¡æœ‰å‰ä»»)

# åä»»
- å…ˆæ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹
- ç›®æ ‡èŠ‚ç‚¹æœ‰å³å­æ ‘ï¼Œ åä»»å°±æ˜¯å³å­æ ‘çš„æœ€å°å€¼ï¼š            4çš„åä»»æ˜¯5
- ç›®æ ‡èŠ‚ç‚¹æ²¡æœ‰å³å­æ ‘ï¼Œåä»»å°±æ˜¯ä»å³è¾¹æ¥çš„æœ€è¿‘çš„ç¥–å…ˆï¼š      3çš„åä»»æ˜¯4
```

```java
// å‰ä»»ä»£ç 
public BSTreeNode predecessor(int val) {
      // 1. æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹
      BSTreeNode target = root;
      BSTreeNode possibleParent = null; // 1.1 è®°å½•æœ€è¿‘å¯èƒ½çš„å‰ä»»ç¥–å…ˆ
      while (target != null) {
          if (target.val == val) {
              break;
          } else if (target.val < val) {
              possibleParent = target;
              target = target.right;
          } else {
              target = target.left;
          }
      }

      if (target == null) {
          return null;
      }


      // 2. åˆ¤æ–­ç›®æ ‡èŠ‚ç‚¹æ˜¯å¦æœ‰å·¦å­æ ‘
      BSTreeNode child = target.left;
      if (child != null) { //  å·¦å­æ ‘ä¸ä¸ºç©ºï¼Œæ‰¾å·¦å­æ ‘çš„æœ€å¤§å€¼
          while (child.right != null) {
              child = child.right;
          }
          return child;
      } else { // å·¦å­æ ‘ä¸ºç©ºï¼Œæ‰¾æœ€è¿‘çš„æ¥è‡ªå·¦è¾¹çš„ç¥–å…ˆ, åœ¨æ‰¾targetçš„æ—¶å€™å°±èƒ½çŸ¥é“
          return possibleParent;  // å‰ä»»ä¹Ÿå¯èƒ½ä¸ºnull
      }
  }
```

## 5.  åˆ é™¤

### 5.1 å·¦èŠ‚ç‚¹æˆ–å³èŠ‚ç‚¹ä¸ºç©º

```bash
# 1. åˆ é™¤èŠ‚ç‚¹æ²¡æœ‰leftï¼Œå°†rightç»™parent                           èŠ‚ç‚¹9
# 2. åˆ é™¤èŠ‚ç‚¹æ²¡æœ‰rightï¼Œå°†leftç»™parent                           èŠ‚ç‚¹6
# 3. åˆ é™¤èŠ‚ç‚¹æ²¡æœ‰left å’Œ rightï¼Œç›´æ¥å°†nullç»™parent                èŠ‚ç‚¹1ï¼Œ åŒ…å«åœ¨1ï¼Œ2ä¸¤ç§æƒ…å†µé‡Œé¢
```

![image-20231106110112165](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231106110112165.png)

![image-20231106110326081](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231106110326081.png)

### 5.2 å·¦å³èŠ‚ç‚¹å‡ä¸ä¸ºç©º

```java
    public void delete(int val) {
        BSTreeNode target = root;
        if (target == null) {
            return;
        }
        BSTreeNode parent = null;
        // 1. æ‰¾åˆ°å¾…åˆ é™¤èŠ‚ç‚¹
        while (target != null) {
            if (target.val == val) {
                break;
            } else if (target.val < val) {
                parent = target;
                target = target.right;
            } else {
                parent = target;
                target = target.left;
            }
        }

        if (target == null) {
            return;
        }

        // 2.å¯¹å¾…åˆ é™¤èŠ‚ç‚¹è¿›è¡Œå‡ ç§æƒ…å†µçš„åˆ¤æ–­
        if (target.left == null && target.right != null) { // å¯¹å³èŠ‚ç‚¹ç›´æ¥ç»™parentä½œä¸ºå³
            shift(parent, target, target.right);
        } else if (target.left != null && target.right == null) {// å¯¹å·¦èŠ‚ç‚¹ç›´æ¥ç»™parentä½œä¸ºå·¦
            shift(parent, target, target.left);
        } else { // å·¦å³èŠ‚ç‚¹å‡ä¸æ˜¯null
            // å¾…å¤„ç†
        }
    }

    /*æ‰˜å­¤æ–¹æ³•*/
    private void shift(BSTreeNode parent, BSTreeNode deleted, BSTreeNode child) {
        if (parent == null) {
            root = child;
        } else if (deleted == parent.left) {
            parent.left = child;
        } else {
            parent.right = child;
        }
    }
```

## 6. LeetCode

### 6.1 å…¬å…±ç¥–å…ˆ -- 235

```bash
# æ€è·¯
- å¦‚æœä¸¤ä¸ªå¾…æŸ¥æ‰¾èŠ‚ç‚¹ï¼Œåœ¨ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¾§ï¼Œåˆ™è¯¥èŠ‚ç‚¹å°±æ˜¯å®ƒä»¬çš„å…¬å…±ç¥–å…ˆ
# 1ï¼Œ3
- åœ¨2çš„å·¦å³ä¸¤ä¾§ï¼Œåˆ™2å°±æ˜¯
# 2ï¼Œ3 
- ä¸åœ¨4çš„å·¦å³ä¸¤ä¾§ï¼Œåˆ™ç»§ç»­æ‰¾4çš„å·¦å³å­©å­
```

![image-20231105114310381](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231105114310381.png)

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode ancestor = root;
    // å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹åœ¨åŒä¸€ä¾§ï¼Œåˆ™ç»§ç»­å‘ä¸‹æ‰¾
    while ((ancestor.val > p.val && ancestor.val > q.val) || 
           (ancestor.val < p.val && ancestor.val < q.val)) {
        if (ancestor.val > p.val) {
            ancestor = ancestor.left;
        } else {
            ancestor = ancestor.right;
        }
    }
    return ancestor;
}
```

### 6.2 éªŒè¯åˆæ³• -- 98

#### ä¸­åºéå†

- ä¸­åºéå†åçš„ç»“æœï¼Œå°±åº”è¯¥æ˜¯ä¸€ä¸ªæœ‰åºé€’å¢çš„é›†åˆï¼Œå¦‚æœä¸‹ä¸€ä¸ªæ•°æ®æ¯”ä¸Šä¸€ä¸ªæ•°æ®å°äº†ï¼Œåˆ™åˆ¤æ–­ä¸åˆæ³•

```java
public boolean isValidBST(TreeNode root) {
    LinkedList<TreeNode> path = new LinkedList<>();
    TreeNode cur = root;
    long prev = Long.MIN_VALUE; // ä¸Šä¸€ä¸ªæ•°æ®
    while (cur != null || !path.isEmpty()) {
        if (cur != null) {
            path.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = path.pop();
            if (pop.val <= prev) {
                return false;
            }
            prev = pop.val;
            cur = pop.right;
        }
    }
    return true;
}
```

### 6.3 èŒƒå›´å’Œ -- 938

- ç»™å®šäºŒå‰æœç´¢æ ‘çš„æ ¹ç»“ç‚¹rootï¼Œè¿”å›å€¼ä½äºèŒƒå›´ [low, high] ä¹‹é—´çš„æ‰€æœ‰ç»“ç‚¹çš„å€¼çš„å’Œ

#### ä¸­åºéå† 

- å……åˆ†åˆ©ç”¨ä¸­åºéå†åŠäºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§
- åªèƒ½ä»æœ€å°çš„å¼€å§‹ï¼Œç„¶ååˆ°highçš„æ—¶å€™ç»“æŸï¼Œä¸èƒ½ç›´æ¥è¿‡æ»¤ç‚¹å°äºlowçš„èŠ‚ç‚¹çš„è¿‡æ»¤

```java
public int rangeSumBST(TreeNode root, int low, int high) {
      int result = 0;
      LinkedList<TreeNode> path = new LinkedList<>();
      TreeNode cur = root;
      while (cur != null || !path.isEmpty()) {
          if (cur != null) {
              path.push(cur);
              cur = cur.left;
          } else {
              TreeNode pop = path.pop();
              if (pop.val > high) {
                  return result;
              }

              if (low <= pop.val) {
                  result += pop.val;
              }
              cur = pop.right;
          }
      }
      return result;
  }
```

#### å‰ªæé€’å½’

```java
public int rangeSumBST(TreeNode root, int low, int high) {
    if (root == null) {
        return 0;
    }
    if (root.val < low) {
        return rangeSumBST(root.right,low,high);
    }
    if (root.val > high) {
        return rangeSumBST(root.left,low,high);
    }
    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
}
```

### 6.4 å‰åºéå†æ„é€ äºŒå‰æœç´¢æ ‘ -- 1008

- æ•°ç»„é•¿åº¦å¤§äº1
- æ•°ç»„ä¸­æ²¡æœ‰é‡å¤å€¼

#### ä¾æ¬¡put

- å…¶å®å°±æ˜¯å°†æ•°ç»„ä¸­çš„æ•°æ®ä¾æ¬¡æ·»åŠ åˆ°äºŒå‰æœç´¢æ ‘ä¸­
- ä¸èƒ½æœ‰æ•ˆçš„åˆ©ç”¨å‰åºéå†çš„é¡ºåº

```java
public TreeNode bstFromPreorder(int[] preorder) {
        TreeNode root = new TreeNode(preorder[0]);
        for (int i = 1; i < preorder.length; i++) {
            put(root, preorder[i]);
        }
        return root;
    }

    private void put(TreeNode root, int val) {
        TreeNode cur = root;
        TreeNode prev = null;
        while (cur != null) {
            prev = cur; // è®°å½•ä¸Šä¸€ä¸ª
            if (cur.val < val) {
                cur = cur.right;
            } else {
                cur = cur.left;
            }
        }
        TreeNode inserted = new TreeNode(val);
        if (val < prev.val) {
            prev.left = inserted;
        } else {
            prev.right = inserted;
        }
    }
```

### 6.5 ä¸¤æ•°ä¹‹å’Œ -- 653

- äºŒå‰æœç´¢æ ‘çš„ä¸¤æ•°ä¹‹å’Œ

#### ä¸­åºéå†+Hash

- ä¸­åºéå†è½¬æ¢ä¸ºæ’åºæ•°ç»„ï¼Œhashå¯¹æ•°ç»„å¤„ç†

```java
public boolean findTarget(TreeNode root, int k) {
        List<Integer> result = inOrder(root);
        Map<Integer, Integer> cache = new HashMap<>();
        for (int i = 0; i < result.size(); i++) {
            if (cache.containsKey(k - result.get(i))) {
                return true;
            }
            cache.put(result.get(i), i);
        }
        return false;
    }

    private List<Integer> inOrder(TreeNode root) {
        LinkedList<TreeNode> path = new LinkedList<>();
        List<Integer> result = new ArrayList<>();
        TreeNode cur = root;
        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode pop = path.pop();
                result.add(pop.val);
                cur = pop.right;
            }
        }
        return result;
    }
```



# AVLæ ‘

## 1. å¹³è¡¡äºŒå‰æ ‘

```bash
# å¹³è¡¡
- ä¸€ä¸ªäºŒå‰æ ‘ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„rightå’Œleftï¼Œé«˜åº¦å·®è¶…è¿‡1ï¼Œåˆ™æ­¤èŠ‚ç‚¹å¤±è¡¡ï¼Œéœ€è¦æ—‹è½¬
- ä¸€ä¸ªäºŒå‰æ ‘ï¼Œåœ¨å¢åŠ å’Œåˆ é™¤æ—¶ï¼Œå°±ä¼šå¯èƒ½å¯¼è‡´å¤±è¡¡
```

### 1.1 æ˜¯å¦å¹³è¡¡ -- 110

![image-20231112093611479](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112093611479.png)

#### è‡ªé¡¶å‘ä¸‹

- 

## 2. ALVæ ‘

### 2.1 AVLTreeNode

- AVLæ ‘æ˜¯æœ€æ—©çš„ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘

```java
class AVLTreeNode {
    int val;
    int height = 1;
    AVLTreeNode left;
    AVLTreeNode right;

    public AVLTreeNode(int val) {
        this.val = val;
    }

    public AVLTreeNode(int val, AVLTreeNode left, AVLTreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 2.2 AVLTree

```java
class AVLTree {
  AVLTreeNode root = null;
}
```

## 3. å¸¸è§æ–¹æ³•

### 3.1 height

- heightï¼šåœ¨æ·»åŠ èŠ‚ç‚¹æ—¶ï¼Œå°±ä¼šè‡ªåŠ¨å¯¹ç›¸åº”èŠ‚ç‚¹è¿›è¡Œé«˜åº¦èµ‹å€¼

```java
public int getHeight(AVLTreeNode node) {
    return node == null ? 0 : node.height;
}

public void updateHeight(AVLTreeNode node) {
    node.height = Integer.max(getHeight(node.left), getHeight(node.right)) + 1;
}
```

### 3.2 insert

- ä¿è¯æ¯æ¬¡æ·»åŠ å…ƒç´ åï¼Œéƒ½æ˜¯ä¸€ä¸ªåˆæ³•çš„å¹³è¡¡äºŒå‰æœç´¢æ ‘

![image-20231111130306086](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231111130306086.png)

```bash
# 1. æ·»åŠ 
- 1.1 æ·»åŠ ï¼š æ‰¾åˆ°è¦insertçš„å…·ä½“å…ƒç´ çš„ä½ç½®è¿›è¡Œæ·»åŠ 
- 1.2 é«˜åº¦ï¼š  æ ¹æ®ä¸Šä¸€æ­¥éª¤ä¸­çš„æ‰¾å¯»çš„è·¯å¾„ï¼Œå¯¹æ¯ä¸ªç»¿è‰²èŠ‚ç‚¹ï¼Œä»åº•åˆ°é¡¶çš„æ›´æ–°é«˜åº¦

# 2. åˆ¤æ–­å¹³è¡¡
- 2.1 åˆ¤æ–­æ˜¯å¦å¹³è¡¡ï¼Œå¹³è¡¡åˆ™ä»€ä¹ˆä¸åšï¼Œä¸å¹³è¡¡åˆ™æ ¹æ®å››ç§å¤±è¡¡ï¼Œè¿›è¡Œå¯¹åº”æ—‹è½¬
- 2.2.æ—‹è½¬æ—¶å€™ï¼šå¯¹å¯¹åº”çš„ä¸‹æ½œå’Œä¸Šä½èŠ‚ç‚¹è¿›è¡Œé«˜åº¦æ›´æ–°
# æ¯æ¬¡æ·»åŠ å…ƒç´ éƒ½ä¼šè¿›è¡Œåˆ¤æ–­å¹³è¡¡ï¼Œå› æ­¤æ¯æ¬¡åªéœ€è¦å¯¹rootèŠ‚ç‚¹è¿›è¡Œåˆ¤æ–­å¹³è¡¡ï¼Œä¸éœ€è¦æ•´ä½“æ‰«ææ•´æ£µæ ‘
```

```java
public void insert(int val) {
      if (root == null) {
          root = new AVLTreeNode(val);
          return;
      }

      LinkedList<AVLTreeNode> path = new LinkedList<>(); // è¦æ›´æ–°çš„èŠ‚ç‚¹é«˜åº¦
      AVLTreeNode cur = root;
      AVLTreeNode prev = null;

      while (cur != null) {
          path.push(cur);
          prev = cur;
          if (val < cur.val) {
              cur = cur.left;
          } else if (val > cur.val) {
              cur = cur.right;
          } else {
              System.out.println("equals, ignore");
          }
      }

      /*å·¦æˆ–å³*/
      AVLTreeNode inserted = new AVLTreeNode(val);
      if (prev.val > val) {
          prev.left = inserted;
      } else {
          prev.right = inserted;
      }

      /*æŒ‰ç…§æœç´¢è·¯å¾„ï¼Œæ›´æ–°æ¯ä¸ªèŠ‚ç‚¹çš„height*/
      while (!path.isEmpty()) {
          updateHeight(path.pop());
      }
      // é‡æ–°å¹³è¡¡
      
  }
```

### 3.3 remove

- åˆ é™¤åŒç†
- ä»£ç å¾…æäº¤

### 3.4 bf

- balance factor: ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå·¦å­æ ‘é«˜åº¦-å³å­æ ‘é«˜åº¦
- å¹³è¡¡ï¼š 0ï¼Œ1ï¼Œ-1

```java
public int balanceFactor(AVLTreeNode node) {
    AVLTreeNode left = node.left;
    AVLTreeNode right = node.right;
    return getHeight(left) - getHeight(right);
}
```

## 4. å››ç§å¤±è¡¡

- Lå’ŒRè¡¨ç¤ºè°é«˜ï¼Œé¡ºåºè¡¨ç¤ºå¤±è¡¡èŠ‚ç‚¹å’Œå­æ ‘
- å¹³è¡¡å› å­ï¼šä¸€ä¸ªèŠ‚ç‚¹ï¼Œå·¦å­æ ‘é«˜åº¦-å³å­æ ‘é«˜åº¦ï¼ŒBF

### 4.1 LL

- å¤±è¡¡èŠ‚ç‚¹(5)çš„ bf >1ï¼Œå³å·¦è¾¹æ›´é«˜
- å¤±è¡¡èŠ‚ç‚¹çš„å·¦å­æ ‘(3)çš„bf >=0ï¼Œå³å·¦å­©å­ä¹Ÿæ˜¯å·¦è¾¹é«˜æˆ–è€…ç­‰é«˜

```Â bash
# å‘å³æ—‹è½¬ä¸€æ¬¡
- 1. å‘å³æ—‹è½¬
- 2. å¤±è¡¡èŠ‚ç‚¹çš„å·¦å­©å­3çš„å³å­æ ‘4ï¼Œå˜æˆäº†ä¸‹æ½œèŠ‚ç‚¹5çš„å·¦å­æ ‘

# é«˜åº¦
- ç°è‰²èŠ‚ç‚¹çš„éƒ½æ²¡å˜ï¼Œæ¢çˆ¹èŠ‚ç‚¹4ä¹Ÿä¸å˜
- å…ˆæ›´æ–°ä¸‹æ½œçš„èŠ‚ç‚¹é«˜åº¦
- å†æ›´æ–°ä¸Šä½èŠ‚ç‚¹é«˜åº¦
```

![image-20231109144447006](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109144447006.png)

### 4.2 LR

- å¤±è¡¡èŠ‚ç‚¹(6)çš„BF>1ï¼Œå³å·¦è¾¹æ›´é«˜
- å¤±è¡¡èŠ‚ç‚¹çš„å·¦å­æ ‘(2)çš„BF<0, å³å·¦å­æ ‘çš„æƒ…å†µæ˜¯ï¼šå³è¾¹æ›´é«˜

```bash
# å¤±è¡¡èŠ‚ç‚¹å·¦å­æ ‘å‘å·¦æ—‹è½¬1æ¬¡
- å˜æˆ4.1çš„æƒ…å†µ
# å‘å³è¾¹æ—‹è½¬ä¸€æ¬¡
```

![image-20231109150223352](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109150223352.png)

### 4.3 RL

- å¤±è¡¡èŠ‚ç‚¹(2)çš„BF < -1, å³å³è¾¹æ›´é«˜
- å¤±è¡¡èŠ‚ç‚¹çš„å³å­©å­(6)çš„BF>0, å³å³å­©å­è¿™è¾¹ï¼šå·¦è¾¹æ›´é«˜

![image-20231109151053257](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109151053257.png)

### 4.4 RR

- å¤±è¡¡èŠ‚ç‚¹(2)çš„BF<-1ï¼Œå³å³è¾¹æ›´é«˜
- å¤±è¡¡èŠ‚ç‚¹çš„å³å­©å­(6)çš„BF<=0ï¼Œå³å³å­©å­è¿™è¾¹ï¼Œå³è¾¹æ›´é«˜æˆ–è€…ç­‰é«˜

```bash
# å‘å·¦æ—‹ä¸€æ¬¡
- 1. å‘å·¦æ—‹è½¬
- 2. å¤±è¡¡èŠ‚ç‚¹çš„å³å­æ ‘çš„å·¦èŠ‚ç‚¹3ï¼Œå˜ä¸ºä¸‹æ½œèŠ‚ç‚¹2çš„å³å­æ ‘

# é«˜åº¦
# é«˜åº¦
- ç°è‰²èŠ‚ç‚¹çš„éƒ½æ²¡å˜ï¼Œæ¢çˆ¹èŠ‚ç‚¹3ä¹Ÿä¸å˜
- å…ˆæ›´æ–°ä¸‹æ½œçš„èŠ‚ç‚¹é«˜åº¦
- å†æ›´æ–°ä¸Šä½èŠ‚ç‚¹é«˜åº¦
```

![image-20231109144322946](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109144322946.png)

```java
/*å³æ—‹å¤±è¡¡èŠ‚ç‚¹*/
  public AVLTreeNode rightRotate(AVLTreeNode node) {
      AVLTreeNode up = node.left;
      AVLTreeNode down = node;
      AVLTreeNode child = up.right;

      down.right = child; // æ¢çˆ¹
      up.right = down;    // ä¸Šä½
      updateHeight(down); // æ›´æ–°é«˜åº¦é¡ºåºä¸èƒ½å˜
      updateHeight(up);
      return up;
  }

  /*å·¦æ—‹å¤±è¡¡èŠ‚ç‚¹*/
  public AVLTreeNode leftRotate(AVLTreeNode node) {
      AVLTreeNode up = node.right;
      AVLTreeNode down = node;
      AVLTreeNode child = up.left;

      down.right = child; // æ¢çˆ¹
      up.left = down;      // ä¸Šä½
      updateHeight(down);
      updateHeight(up);
      return up;
  }

  /*å…ˆå·¦æ—‹ï¼Œåå³æ—‹*/
  public AVLTreeNode leftRightRotate(AVLTreeNode node) {
      // 1. å¤±è¡¡èŠ‚ç‚¹çš„å·¦å­æ ‘å·¦æ—‹è½¬
      node.left = leftRotate(node.left);
      // 2. æ ¹èŠ‚ç‚¹æœ‰æ—‹è½¬
      return rightRotate(node);
  }

  /*å…ˆå³æ—‹ï¼Œå†å·¦è½¬*/
  public AVLTreeNode rightLeftRotate(AVLTreeNode node) {
      node.right = rightRotate(node.right);
      return leftRotate(node);
  }

  /*å¹³è¡¡æŸä¸ªèŠ‚ç‚¹*/
  public AVLTreeNode balance(AVLTreeNode node) {
      if (node == null) {
          return null;
      }

      int balanceFactor = balanceFactor(node);
      /*ä¸å¹³è¡¡çš„å››ç§æƒ…å†µ*/
      if (balanceFactor > 1 && balanceFactor(node.left) >= 0) { //LL
          return rightRotate(node);
      } else if (balanceFactor > 1 && balanceFactor(node.left) < 0) { // LR
          return leftRightRotate(node);
      } else if (balanceFactor < -1 && balanceFactor(node.right) > 0) { //RL
          return rightLeftRotate(node);
      } else if (balanceFactor < -1 && balanceFactor(node.right) <= 0) { //RR
          return leftRotate(node);
      }
      return node;
  }
```

#  çº¢é»‘æ ‘

# Bæ ‘

