# 二进制码

## 1. 比特/字节

### 1. 1 bit

- 比特位：计算机中最小的表示单位，存储0或1

### 1.2 byte

- 字节：计算机中最小的存储单位
- 一个字节包含8个bit，为一组
- 文中全部先用1个byte来进行计算

### 1.3 二进制数

- 数据在底层都是通过二进制来存储的
- 给定大小的数据类型，最高位是符号位，0代表正数，1代表负数

## 2. 正数

- 正数的<font color=orange>原码，反码，补码一样</font>
- 计算时候，就是在最右边进行累加计算

### 2.1 最大值

![image-20231112161418176](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112161418176.png)

### 2.2 计算

![image-20231112162750931](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112162750931.png)

## 3. 负数

- 负数的存储和计算，在计算机底层都是通过补码来实现的

```bash
# 原码
- 最高位为1，其余正常表示

# 反码
- 符号位不变，其余位取反
```

### 3.1 反码

- 如果通过原码，对负数进行计算，实际运算结果刚好和运算相反
- 可以通过反码来对负数进行计算
- 只要不涉及跨0，负数完全可以用反码来进行计算

```bash
# 负数运算规则
- 将十进制转换为二进制原码
- 先将原码转换成反码
- 对反码进行计算 加1
- 对计算后的反码，再转换为原码
- 对原码转换成二进制
```

![image-20231112163648724](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112163648724.png)

### 3.2 跨0问题

- 0值的反码比较特殊会有两个
- 负数计算时，如果跨0 到正数，就会缺少一次，因此计算结果就不准确了

![image-20231112165424053](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112165424053.png)

### 3.3 补码

- 补码是为了解决跨0问题
- 计算机底层存储和运算，都是通过补码来实现的
- 补码是在反码的基础上加1

![image-20231112170813309](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112170813309.png)

### 3.4 -128

- 计算机中规定，补码中，1后面7个0，表示-128
- 一个字节的取值范围：-128～127

![image-20231112171747339](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112171747339.png)

# 数据表示

## 1. 数据类型

- 十进制的数据，用二进制表示，如果切换到数据类型较大的数据类型，则前面补充0

```bash
# byte：   1个字节
# short：  2个字节
# int：    4个字节
# long     8个字节
```

## 2. 类型转换

- 底层存储都是用的补码

### 2.1 小转大

```bash
# 十进制的10： 前面补0
- byte：                                 0000 1010
- int：   0000 0000 0000 0000 0000 0000  0000 1010
```

### 2.2 大转小

```bash
# 十进制的300： 前面补0
- int：   0000 0000 0000 0000 0000 0001  0010 1100
- byte：                                 0010 1100 = 44            # 精度丢失

# 十进制的200:
- int：    0000 0000 0000 0000 0000 0000  1100 1000
- byte：                                  1100 1000 (补码)             #  精度丢失 + 符号变换
                                          1100 0111 (反码)
                                          1011 1000 (原码) = -56
```

# 位运算

## 1. 与

### 1.1 基本计算

- 对二进制数据进行按位与
- 0为false，1为true，如果都是true则是1，否则就是0

```java
public void test01() {
    int a = 200;
    int b = 10;
    int result = a & b;   // 8
    System.out.println(result);
}
```

```bash
# 计算过程
- a=200：   0000 0000 0000 0000 0000 0000 1100 1000
- b=10 ：   0000 0000 0000 0000 0000 0000 0000 1010
- result：  0000 0000 0000 0000 0000 0000 0000 1000 = 8
```

### 1.2 求模运算

- key>0, 和数组索引一一对应，如果超过索引长度，则进行求模型
- 如果<font color=orange>数组长度是2的n次方</font>，则key % arr.length等价于key & arr.length - 1
- 位运算比除法运算性能更高

```java
public int getIndex01(int key) {
    int[] arr = new int[8];
    int target = key % arr.length;
    return target;
}

public int getIndex(int key) {
    int[] arr = new int[8];
    int target = key & arr.length - 1;
    return target;
}
```



## 2. 或

### 2.1 基本计算

- 对二进制数据进行按位与
- 0为false，1为true，一个为true则是1，否则就是0

```java
public void test01() {
    int a = 200;
    int b = 10;
    int result = a | b;   // 202
    System.out.println(result);
}
```

```bash
# 计算过程
- a=200：   0000 0000 0000 0000 0000 0000 1100 1000
- b=10 ：   0000 0000 0000 0000 0000 0000 0000 1010
- result：  0000 0000 0000 0000 0000 0000 1100 1010 = 202
```

## 3. 异或

### 3.1 基本计算

- 对二进制数据进行按位与
- 0为false，1为true，两个不同时为1，相同时为0

```java
public void test01() {
    int a = 200;
    int b = 10;
    int result = a ^ b;   // 194
    System.out.println(result);
}
```

```bash
# 计算过程
- a=200：   0000 0000 0000 0000 0000 0000 1100 1000
- b=10 ：   0000 0000 0000 0000 0000 0000 0000 1010
- result：  0000 0000 0000 0000 0000 0000 1100 0010 = 194
```

### 3.2 只出现一次的数字❤️136

- 除了某个元素只出现一次以外，其余每个元素均出现两次，找到一个的元素

```bash
# 思路： 消消乐[2,3,3,2,1]
- 0和任何数的异或结果，就是数字的本身
- 任何数和它本身异或，结果是0
- 异或时候，数组顺序变换，结果不变
```

```java
public int singleNumber(int[] nums) {
    int result = 0;
    for (int i = 0; i < nums.length; i++) {
        result = result ^ nums[i];
    }
    return result;
}
```



## 4. 左移

### 4.1 基本计算

- 低位补0
- 左移一次，结果乘2

```java
public void test01() {
    int a = 200;
    int result = a << 2;   // 800
    System.out.println(result);
}
```

```bash
# 计算过程: 左移，
- a=200：       000000000000000011001000    
- result：   00`0000000000000011001000 
- result：   00`000000000000001100100000 = 800
```

## 5. 右移

### 5.1 基本计算

- 最高位：原来的数字高位是什么，就用什么来补
- 其他位：补0
- 右移一次，结果除2

```java
public void test01() {
    int a = 200;
    int b = 2;
    int result = a >> b;   // 50
    System.out.println(result);
}
```

```bash
# 计算过程: 右移，
- a=200：       000000000000000011001000    
- result：       `0000000000000000110010
- result：     00`0000000000000000110010
```

## 6. 无符号右移

### 6.1 基本计算

- 高位补0

```java
public void test01() {
    int a = 200;
    int b = 2;
    int result = a >>> b;   // 50
    System.out.println(result);
}
```

# 哈希

## 1. 思想

![image-20231113094946264](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231113094946264.png)

- 给每个数据分配一个编号，放入数组表格
- 编号和表格索引的关系，可以通过编号来快速查找数据

```bash
# 数据结构
- 建立一个数组来存储所有的数据
- 每个数据实体，包含一个key和一个value
- 通过key来映射到数组索引，然后将数据存储在该索引处
- 每个索引只存放一个数据

# 理想情况
- 每个数据实体，key唯一，数组足够大，能存放所有数据
- 每个数组只存放一个数据
  # 优点
  - 时间复杂度为O(1)，只需要根据key找到数组索引位置即可
  # 缺点
  - 数组的内存连续，因此大数组对内存要求苛刻

# 拉链法则
- 有限长度的数组
- key允许重复，允许多个key对应同一个索引
- 一个索引处的数据，通过链表来连接
- 时间复杂度会增加
```

```bash
# key(hash)
- 数据的key，通过某种规则，可以映射到数组的某个索引上
- 如果一个数组的存储元素过多，则需要遍历链表，时间复杂度增加

# hash算法
- 在添加数据的时候，用户没办法保证key的分散性，因此一般会根据具体的value，尽可能来生成一个唯一的key，即hash
```

## 2. 哈希码

### 2.1 哈希算法

- 一种将任意长度的任意数据，通过算法，转换为<font color=orange>固定长度数据</font>的过程，这个固定长度的数据就是hash值
- MD5，SHA1，SHA256，SHA512， CRC32等
- 计算hash值时，考虑原始数据的每个字节，一旦改动原始数据的任何一个字节，对应hash值都会有明显不同
- 摘取了原始数据的一些特征，某种程度上能代表原始数据
- 被广泛用于数据完整性校验和加密方面

### 2.2 实现方式

#### Object-hashCode

```java
/*同一个对象的hash值相同*/
public void test01() {
    Object obj = new Object();
    for (int i = 0; i < 100; i++) {
        int result = obj.hashCode();
        System.out.println(result); // 757108857
    }
}

/*不同对象的hash值不同*/
public void test02() {
    for (int i = 0; i < 100; i++) {
        Object obj = new Object();
        int result = obj.hashCode();
        System.out.println(result);
    }
}
```

#### 权重Hash

- 利用不同的权重，经验表明，选取质数31，哈希冲突的概率比较低

```java
 /**
 * 不同的字段，其hash的权重不同
 * field1*31 + field2*31*31 + field3*31*31*31 +...
 *
 * @param objs
 * @return
 */
public static int getHash(Object... objs) {
    if (objs == null) {
        return 0;
    }

    int result = 1;
    for (Object obj : objs) {
        if (obj == null) {
            result = result * 31;
        } else {
            result = result * 31 + obj.hashCode();
        }
    }
    return result;
}
```

```java
 /**
   * 优化：乘法变成位运算
   *
   * @param objs
   * @return
   */
  public static int getHash(Object... objs) {
      if (objs == null) {
          return 0;
      }

      int result = 1;
      for (Object obj : objs) {
          if (obj == null) {
              result = result << 5 - result;
          } else {
              result = result << 5 - result + obj.hashCode();
          }
      }
      return result;
  }
```

#### MurmurHash

- 快速计算：相对于其他哈希函数，具有更快的计算速度
- 低碰撞率：处理一亿个数据，最多只有两个冲突
- 随机性强：能够很好的保持数据的随机性

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>32.1.2-jre</version>
</dependency>
```

```java
// 对不同类型数据进行hash
int i = Hashing.murmur3_32_fixed().hashInt(3).asInt();
```

## 3. Entity

```java
class Entry {
    Object key; // 会根据key，来生成对应的hash
    Object value;
    Entry next;

    public Entry(Object key, Object value) {
        this.key = key;
        this.value = value;
    }
}
```

## 4. HashTable

### 4.1 hash-index映射

- 根据对应的hash(int类型的大的数字，根据数组长度来求模)
- 数组长度为2的次方时，求模可以转换为位运算，效率更高

![image-20231113160711854](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231113160711854.png)

```java
private int getHash(Object key) {
    return key.hashCode();
}

/**
 * 数组长度是2的n次方，可以用位运算来代替求模运算
 *
 * @param hash ： 是一个比较大的随机int整数
 */
private int getIndex(int hash) {
    return hash & table.length - 1;
}
```

### 4.2 resize

- 如果不添加resize，则最终随着数据越来越多，数组上的链表也会越来越长
- 添加数据完成后，进行resize适当扩容，尽可能保证数组每个都只存放一个元素

```bash
# hash冲突 (即使存在扩容)
- 不同的key，最终得到的hash一样，就会得到相同的index
- 不同的key，hash虽然不同，但是求得到的index是一样的

# 最终结果
- 数组的某些位置上，元素的个数超过1
```

#### 拆分规律

- 一个链表最多拆成两个
- hash & table.length==0的一组
- hash & table.length!=0的一组

### 4.3 get

```java
public Object get(Object key) {
    int hash = getHash(key);
    int targetIndex = getIndex(hash);
    if (table[targetIndex] == null) {
        return null;
    }
    // 遍历链表
    Entry entry = table[targetIndex];
    while (entry != null) {
        if (entry.key.equals(key)) {
            return entry.value;
        }
        entry = entry.next;
    }
    return null;
}
```

### 4.4 put

```java
// key重复，则更新，key不存在，则尾部添加
public void put(Object key, Object value) {
    int hash = getHash(key);
    int targetIndex = getIndex(hash);

    if (table[targetIndex] == null) {
        table[targetIndex] = new Entry(key, value);
    } else {// 遍历寻找
        Entry entry = table[targetIndex];
        while (entry != null) {
            if (entry.key.equals(key)) {
                entry.value = value; // 更新
                return;
            }
            if (entry.next == null) {
                break;
            }
            entry = entry.next;
        }
        entry.next = new Entry(key, value);
    }

    size++;
    if (size > threshold) {
        resize();
    }
}
```

### 4.5 remove

```java
public Object remove(Object key) {
    int hash = getHash(key);
    int targetIndex = getIndex(hash);

    Entry entry = table[targetIndex];
    if (entry == null) {
        return null;
    }

    Entry prev = null;
    while (entry != null) {
        if (entry.key.equals(key)) {
            if (prev == null) {
                table[targetIndex] = entry.next;
            } else {
                prev.next = entry.next;
            }
            size--;
            return entry.value;
        }
        prev = entry;
        entry = entry.next;
    }
    return null;
}
```

## 5. LeetCode

### 5.1 重复元素

#### 存在重复元素1⃣️217

```bash
- 给你一个整数数组num，如果任一值在数组中出现至少两次，返回true
- 如果数组中每个元素互不相同，返回 false
```

```java
public boolean containsDuplicate(int[] nums) {
    Map<Integer, Integer> hash = new HashMap();
    for (int i = 0; i < nums.length; i++) {
        if (hash.containsKey(nums[i])) {
            return true;
        }
        hash.put(nums[i], null);
    }
    return false;
}
```

#### 存在重复元素2⃣️268

```bash
- 给你一个整数数组 nums 和一个整数 k ，
- 判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。
- 如果存在，返回 true ；否则，返回 false 。
```

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer, Integer> hash = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (hash.containsKey(nums[i]) && (i - hash.get(nums[i])) <= k) {
            return true;
        }
        hash.put(nums[i], i);
    }
    return false;
}
```

### 5.2 字符串中的第一个唯一字符串❤️387

- 给定一个字符串s，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1

```java
// 哈希：字母作为key，  频次  作为value
public int missingNumber(int[] nums) {
    Map<Integer, Boolean> hash = new HashMap<>();
    for (int num : nums) {
        hash.put(num, null);
    }

    for (int i = 0; i <= nums.length; i++) {
        if (!hash.containsKey(i)) {
            return i;
        }
    }
    return -1;
}
```

```java
// 哈希：字母作为key，  索引   作为value
public int firstUniqChar(String s) {
    Map<Character, Integer> hash = new HashMap<>();
    char[] chars = s.toCharArray();
    for (int i = 0; i < chars.length; i++) {
        if (hash.containsKey(chars[i])) {
            hash.put(chars[i], -1);
        } else {
            hash.put(chars[i], i);
        }
    }

    int firstIndex = Integer.MAX_VALUE;
    for (Map.Entry<Character, Integer> entry : hash.entrySet()) {
        Character key = entry.getKey();
        Integer value = entry.getValue();
        if (value != -1) {
            firstIndex = Math.min(firstIndex, value);
        }
    }

    return firstIndex == Integer.MAX_VALUE ? -1 : firstIndex;
}
```





### 5.2 丢失数

#### 丢失的数字❤️268

```bash
# 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数
输入：nums = [3,0,1]
输出：2
nums 中的所有数字都 独一无二
```

```java
public int missingNumber(int[] nums) {
    Map<Integer, Boolean> hash = new HashMap<>();
    for (int num : nums) {
        hash.put(num, null);
    }

    for (int i = 0; i <= nums.length; i++) {
        if (!hash.containsKey(i)) {
            return i;
        }
    }
    return -1;
}
```

### 两个数组的交集1⃣️349

```bash
# 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

```java
public int[] intersection(int[] nums1, int[] nums2) {
      Map<Integer, Object> hash1 = removeDuplicate(nums1);
      Map<Integer, Object> hash2 = removeDuplicate(nums2);

      List<Integer> result = new ArrayList<>();
      if (hash1.size() > hash2.size()) {
          for (Map.Entry<Integer, Object> entry : hash2.entrySet()) {
              if (hash1.containsKey(entry.getKey())) {
                  result.add(entry.getKey());
              }
          }
      } else {
          for (Map.Entry<Integer, Object> entry : hash1.entrySet()) {
              if (hash2.containsKey(entry.getKey())) {
                  result.add(entry.getKey());
              }
          }
      }

      int[] nums = new int[result.size()];
      for (int i = 0; i < nums.length; i++) {
          nums[i] = result.get(i);
      }
      return nums;
  }

  private Map<Integer, Object> removeDuplicate(int[] arr) {
      Map<Integer, Object> hash = new HashMap<>();
      for (int i = 0; i < arr.length; i++) {
          hash.put(arr[i], null);
      }
      return hash;
  }
```

### 两数之和❤️1

```bash
- 给定一个整数数组 nums 和一个整数目标值 target，
- 在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标

输入：nums = [3,3], target = 6
输出：[0,1]
```

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> hash = new HashMap<>();
    int[] result = new int[2];
    for (int i = 0; i < nums.length; i++) {
        if (hash.containsKey(target - nums[i])) {
            result[0] = hash.get(target - nums[i]);
            result[1] = i;
            return result;
        }
        hash.put(nums[i],i);
    }
    return result;
}
```

### 无重复字符的最长子串❤️3

```bash
# 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

输入: s = "abcabcbb"
输出: 3 
```

```java
// 重复元素时，删除重复元素前面的数据
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> hash = new HashMap<>();
    int max = 0;  // 最大size

    for (int i = 0; i < s.length(); i++) {
        char key = s.charAt(i);
        // 重复时，删除重复元素前面的数据
        if (hash.containsKey(key)) {
            Integer removedBound = hash.get(key); // 要删除元素的索引上限
            hash.entrySet().removeIf(next -> next.getValue() <= removedBound);
        }
        hash.put(key, i);
        max = Math.max(max, hash.size());
    }
    return max ;
}
```

```java
// 重复元素时，更新开始时候的索引
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> hash = new HashMap<>();
    int max = 0;  // 最大size
    int start = 0;
    int end = 0;

    for (int i = 0; i < s.length(); i++) {
        char key = s.charAt(i);
        // 重复： 在当前有效索引内contain
        if (hash.containsKey(key) && hash.get(key) >= start) {
            start = hash.get(key) + 1;              // 移起点
        }

        hash.put(key, i);
        end = i;
        max = Math.max(max, (end - start + 1)); // 每次添加，都计算一下有效长度
    }

    return max;
}
```

### 字母异位词分组❤️4

```bash
# 字母异位词 是由重新排列源单词的所有字母得到的一个新单词
- 只包含小写字母

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

```java
// 将重新排序好的字母作为 key， 异位词作为value
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> hash = new HashMap<>();

    for (String str : strs) {
        char[] chs = str.toCharArray();
        Arrays.sort(chs);
        String key = new String(chs);
        if (hash.containsKey(key)) {
            hash.get(key).add(str);
        } else {
            ArrayList<String> value = new ArrayList<>();
            value.add(str);
            hash.put(key, value);
        }
    }

   return new ArrayList<>(hash.values());
}
```

```java
//  key是一个26个长度的自定义的数组，重写equals和hashcode
class PArray {
        int[] arr = new int[26];

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            PArray pArray = (PArray) o;
            return Arrays.equals(arr, pArray.arr);
        }

        @Override
        public int hashCode() {
            return Arrays.hashCode(arr);
        }
    }

    public List<List<String>> groupAnagrams(String[] strs) {
        Map<PArray, List<String>> hash = new HashMap<>();

        for (String str : strs) {
            PArray pArray = new PArray();
            for (char ch : str.toCharArray()) {
                int idx = ch - 97; // 根据字符数据，对应到int的数组
                pArray.arr[idx]++;
            }

            if (hash.containsKey(pArray)) {
                hash.get(pArray).add(str);
            } else {
                ArrayList<String> sub = new ArrayList<>();
                sub.add(str);
                hash.put(pArray, sub);
            }
        }

        return new ArrayList<>(hash.values());
    }
}
```

