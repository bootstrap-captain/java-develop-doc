# 二叉树

- 每个节点，最多只存在两个子节点

## 1. 基本概念

```bash
# 根节点
- 二叉树的起始节点

# 叶子节点
- 没有子节点的节点

# 满二叉树
- 每个节点都有两个叶子节点

# 完全二叉树
- 其余层都必须填满，最后一层可填满可不填满
- 最后一层：必须从左向右填充
- 堆

# 实现方式
- 数组
- TreeNode
```

```java
package com.citi.tree;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 2. 广度优先

- 层序遍历

```bash
# 队列思路
- 根节点入队
- 头弹出，处理当前节点，然后将当前节点的左右孩子依次入队
- 直到队列为空
```

![image-20231014115013816](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014115013816.png)

### 😎基础打印

- 从上到下，从左到右，层序打印

#### 迭代 + 队列

```java
public void printTree(TreeNode root) {
    LinkedList<TreeNode> path = new LinkedList<>();
    path.offer(root);

    while (!path.isEmpty()) {
        TreeNode pop = path.pop();
        System.out.println(pop.val);// 打印
        if (pop.left != null) {
            path.offer(pop.left);
        }
        if (pop.right != null) {
            path.offer(pop.right);
        }
    }
}
```

#### 递归



### 😡[ 102/107 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- 102题目: 从上到下，每层按照从左到右封装结果： result.add(subResult);
- 107题目: 从小到上，每层按照从左到右封装结果： result.add(0, subResult);

#### 迭代 + 队列

```java
public List<List<Integer>> levelOrder(TreeNode root) {
  List<List<Integer>> result = new ArrayList<>();
  if (root == null) {
      return result;
  }

  LinkedList<TreeNode> path = new LinkedList<>();
  path.offer(root);
  int currentLayerSize = 1;

  while (!path.isEmpty()) {
      int nextLayerSize = 0;
      List<Integer> subResult = new ArrayList<>();
      for (int i = 0; i < currentLayerSize; i++) {
          TreeNode pop = path.pop();
          subResult.add(pop.val);
          if (pop.left != null) {
              nextLayerSize++;
              path.offer(pop.left);
          }
          if (pop.right != null) {
              nextLayerSize++;
              path.offer(pop.right);
          }
      }
      result.add(subResult);
      currentLayerSize = nextLayerSize;
  }

  return result;
}
```

### 😡[103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

#### 迭代 + 队列

- 从上到小，按照一层左右，一层右左的顺序 
-  奇数层从左到右，偶数层从右到左，和上面处理类似

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    LinkedList<TreeNode> path = new LinkedList<>();
    path.offer(root);
    int currentLayerSize = 1;
    boolean flag = true;

    while (!path.isEmpty()) {
        int nextLayerSize = 0;
        List<Integer> subResult = new ArrayList<>();
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode pop = path.pop();
            if (flag) {
                subResult.add(pop.val);
            } else {
                subResult.add(0, pop.val);
            }
            if (pop.left != null) {
                nextLayerSize++;
                path.offer(pop.left);
            }
            if (pop.right != null) {
                nextLayerSize++;
                path.offer(pop.right);
            }
        }
        result.add(subResult);
        currentLayerSize = nextLayerSize;
        flag = !flag;
    }
    return result;
}
```

## 3. 深度优先

- 都是从左向右处理的

### 3.0 遍历顺序

#### 前序遍历

- 先处理父节点，再处理子节点

![image-20231029161521912](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161521912.png)

#### 中序遍历

- 处理子节点的中间，处理父节点

![image-20231029161415584](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161415584.png)

#### 后序遍历

- 先处理子节点，再处理父节点

![image-20231029161334384](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161334384.png)

### 3.1 递归

```java
package com.citi.tree;

import java.util.ArrayList;
import java.util.List;

public class Solution {

    static TreeNode root = new TreeNode(1, new TreeNode(2,
            new TreeNode(4, new TreeNode(7), new TreeNode(8)),
            null),
            new TreeNode(3, new TreeNode(5, new TreeNode(9), new TreeNode(11)),
                    new TreeNode(6, new TreeNode(12), null)));

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        pre(result, root);
        return result;
    }

    private void pre(List<Integer> result, TreeNode root) {
        if (root == null) {
            return;
        }
        result.add(root.val);
        pre(result, root.left);
        pre(result, root.right);
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        in(result, root);
        return result;
    }

    private void in(List<Integer> result, TreeNode root) {
        if (root == null) {
            return;
        }
        in(result, root.left);
        result.add(root.val);
        in(result, root.right);
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        post(result, root);
        return result;
    }

    private void post(List<Integer> result, TreeNode root) {
        if (root == null) {
            return;
        }
        post(result, root.left);
        post(result, root.right);
        result.add(root.val);
    }
}
```

### 3.2 迭代 + 栈

```java
package com.citi.tree;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Solution {

    static TreeNode root = new TreeNode(1, new TreeNode(2,
            new TreeNode(4, new TreeNode(7), new TreeNode(8)),
            null),
            new TreeNode(3, new TreeNode(5, new TreeNode(9), new TreeNode(11)),
                    new TreeNode(6, new TreeNode(12), null)));

    /*前序遍历*/
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> paths = new LinkedList<>();

        TreeNode cur = root;
        while (cur != null || !paths.isEmpty()) {
            if (cur != null) {
                paths.push(cur);
                result.add(cur.val);
                cur = cur.left;
            } else {
                TreeNode pop = paths.pop();
                if (pop.right != null) {
                    cur = pop.right;
                }
            }
        }
        return result;
    }

    /*中序遍历*/
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> paths = new LinkedList<>();

        TreeNode cur = root;
        while (cur != null || !paths.isEmpty()) {
            if (cur != null) {
                paths.push(cur);
                cur = cur.left;
            } else {
                TreeNode pop = paths.pop();
                result.add(pop.val);
                if (pop.right != null) {
                    cur = pop.right;
                }
            }
        }
        return result;
    }

    /*后序遍历*/
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> paths = new LinkedList<>();
        TreeNode cur = root;

        TreeNode lastPop = null;
        while (cur != null || !paths.isEmpty()) {
            if (cur != null) {
                paths.push(cur);
                cur = cur.left;
            } else {
                TreeNode peek = paths.peek();
                if (peek.right == null || peek.right == lastPop) {
                    TreeNode pop = paths.pop();
                    lastPop = pop;
                    result.add(pop.val);
                } else {
                    cur = peek.right;
                }
            }
        }
        return result;
    }
}
```

## 4. LeetCode

### 😎[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

#### 递归

```java
public boolean isSymmetric(TreeNode root) {
    return check(root.left, root.right);
}

private boolean check(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }

    if (left == null || right == null) {
        return false;
    }

    if (left.val != right.val) {
        return false;
    }

    return check(left.left, right.right) && check(left.right, right.left);
}
```

#### 迭代+双端队列

- 头结点插入两次到双端队列中
- 弹出两个，并将这两个的左右结点按照相反的顺序插入到队列两端
- 相邻两个应该是一样的
- LinkedList可以添加多个null值，因此如果一个结点为null时，就直接添加null即可

![image-20231224160929316](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231224160929316.png)

```java
public boolean isSymmetric(TreeNode root) {
    LinkedList<TreeNode> dequeue = new LinkedList<>();
    dequeue.offer(root);
    dequeue.offer(root);

    while (!dequeue.isEmpty()) {
        TreeNode first = dequeue.pop();
        TreeNode second = dequeue.pop();
        if (first == null && second == null) {
            continue;
        }

        if (first == null || second == null) {
            return false;
        }

        if (first.val != second.val) {
            return false;
        }

        if (first == second) {
            dequeue.offerFirst(first.left);
            dequeue.offerLast(first.right);
        } else {
            dequeue.offerFirst(first.left);
            dequeue.offerFirst(second.right);

            dequeue.offerLast(second.left);
            dequeue.offerLast(first.right);
        }
    }
    return true;
}
```

### 😎[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

#### 递归

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return root;
    }
    invert(root);
    return root;
}

private void invert(TreeNode root) {
    if (root == null) {
        return;
    }

    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
    invert(root.left);
    invert(root.right);
}
```

#### 迭代

```

```



### 😎[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

#### 层序遍历

- 按照一层来做结果集合，总共有几层，就是最大深度

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    List<List<Integer>> result = new ArrayList<>();
    LinkedList<TreeNode> paths = new LinkedList<>();

    paths.offer(root);
    int currentLayerSize = 1;

    while (!paths.isEmpty()) {
        int nextLayerSize = 0;
        List<Integer> subResult = new ArrayList<>();
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode pop = paths.pop();
            subResult.add(pop.val);
            if (pop.left != null) {
                paths.offer(pop.left);
                nextLayerSize++;
            }
            if (pop.right != null) {
                paths.offer(pop.right);
                nextLayerSize++;
            }
        }
        result.add(subResult);
        currentLayerSize = nextLayerSize;
    }
    return result.size();
}
```

#### 后序遍历

- 后序遍历，每次pop的时候，记录一下pop前的最大路径
- 取最大值即可

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;
    int maxDepth = 0;
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = paths.peek();
            if (peek.right == null || peek.right == lastPop) {
                maxDepth = Math.max(maxDepth,paths.size());
                TreeNode pop = paths.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return maxDepth;
}
```

#### 递归

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int leftDepth = maxDepth(root.left);
    int rightDepth = maxDepth(root.right);
    return Math.max(leftDepth, rightDepth) + 1;
}
```

### 😎[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

#### 层序遍历

- 遇到的第一个叶子结点所在的层，就是最小深度

![image-20231030175543994](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231030175543994.png)

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> paths = new LinkedList<>();
    paths.offer(root);

    int currentLayerSize = 1;
    int layer = 1;
    while (!paths.isEmpty()) {
        int nextLayerSize = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode pop = paths.pop();
            if (pop.left == null && pop.right == null) {
                return layer;
            }
            if (pop.left != null) {
                paths.offer(pop.left);
                nextLayerSize++;
            }
            if (pop.right != null) {
                paths.offer(pop.right);
                nextLayerSize++;
            }
        }
        currentLayerSize = nextLayerSize;
        layer++;
    }
    return -1;
}
```





# 二叉搜索树

- 树节点增加key，比较谁大谁小，key不可重复
- 所有树节点，key比左子树的key都大，同时也比右子树的key都小
- LeetCode中，只包含一个属性，既表示key，也表示value

```java
package com.citi.bstree;

public class BSTreeNode {
    int val;
    BSTreeNode left;
    BSTreeNode right;

    public BSTreeNode(int val) {
        this.val = val;
    }

    public BSTreeNode(BSTreeNode left, int val, BSTreeNode right) {
        this.left = left;
        this.val = val;
        this.right = right;
    }
}
```

```java
public class BSTree {
    static BSTreeNode root; // 根结点

    /**
     *              6
     *           /     |
     *           4     8
     *          /  |   / |
     *         3   5   7  9
     * 
     */
    static {
        root = new BSTreeNode(new BSTreeNode(new BSTreeNode(3), 4, new BSTreeNode(5)), 6,
                new BSTreeNode(new BSTreeNode(7), 8, new BSTreeNode(9)));
    }
}
```

## 1. 根据key查找

### 1.1 递归

```java
public BSTreeNode getByKey(int val) {
    return doGet(root, val);
}

private BSTreeNode doGet(BSTreeNode node, int val) {
    if (node == null) {
        return null;
    }
    if (val == node.val) {
        return node;
    } else if (val < node.val) {
        return doGet(node.left, val);
    } else {
        return doGet(node.right, val);
    }
}
```

### 1.2 非递归

```java
public BSTreeNode getByKey(int val) {
    BSTreeNode node = root;
    while (node != null) {
        if (node.val == val){
            return node;
        } else if (node.val<val) {
            node = node.right;
        }else{
            node = node.left;
        }
    }
    return null;
}
```

## 2. 最小/大key

- 最小是找左边，最大是找右边

### 2.1 递归

```java
  public BSTreeNode getMin() {
      return doMin(root);
  }

  private BSTreeNode doMin(BSTreeNode node) {
      if (node == null) {
          return null;
      }
      if (node.left == null) {
          return node;
      }
      return doMin(node.left);
  }
```

### 2.2 非递归

```java
public BSTreeNode getMin() {
    BSTreeNode node = root;
    if (node == null) {
        return null;
    }
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
```

## 3. put

- key如果存在，则更新，key不存在，新增左或右节点

```java
public void put(int val) {
    if (root == null) {
        root = new BSTreeNode(val);
    }
    BSTreeNode node = root;
    BSTreeNode prev = null;
    while (node != null) {
        if (node.val == val) {
            return;
        } else if (node.val < val) {
            prev = node;
            node = node.right;
        } else {
            prev = node;
            node = node.left;
        }
    }
    /*左或右*/
    BSTreeNode inserted = new BSTreeNode(val);
    if (prev.val < val) {
        prev.right = inserted;
    } else {
        prev.left = inserted;
    }
}
```

## 4. 前任后任

- 可以采用中序遍历的方式，但是效率较低，没有充分利用二叉搜索树的特性

![image-20231105105853330](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231105105853330.png)

```bash
# 前任
- 先找到目标节点
- 目标节点有左子树，前任就是左子树的最大值：               如4的前任就是3
- 目标节点没有左子树，前任就是离它最近的，从左边来的祖先：    如5的前任就是4(1没有前任)

# 后任
- 先找到目标节点
- 目标节点有右子树， 后任就是右子树的最小值：            4的后任是5
- 目标节点没有右子树，后任就是从右边来的最近的祖先：      3的后任是4
```

```java
// 前任代码
public BSTreeNode predecessor(int val) {
      // 1. 找到目标节点
      BSTreeNode target = root;
      BSTreeNode possibleParent = null; // 1.1 记录最近可能的前任祖先
      while (target != null) {
          if (target.val == val) {
              break;
          } else if (target.val < val) {
              possibleParent = target;
              target = target.right;
          } else {
              target = target.left;
          }
      }

      if (target == null) {
          return null;
      }


      // 2. 判断目标节点是否有左子树
      BSTreeNode child = target.left;
      if (child != null) { //  左子树不为空，找左子树的最大值
          while (child.right != null) {
              child = child.right;
          }
          return child;
      } else { // 左子树为空，找最近的来自左边的祖先, 在找target的时候就能知道
          return possibleParent;  // 前任也可能为null
      }
  }
```

## 5.  删除

### 5.1 左节点或右节点为空

```bash
# 1. 删除节点没有left，将right给parent                           节点9
# 2. 删除节点没有right，将left给parent                           节点6
# 3. 删除节点没有left 和 right，直接将null给parent                节点1， 包含在1，2两种情况里面
```

![image-20231106110112165](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231106110112165.png)

![image-20231106110326081](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231106110326081.png)

### 5.2 左右节点均不为空

```java
    public void delete(int val) {
        BSTreeNode target = root;
        if (target == null) {
            return;
        }
        BSTreeNode parent = null;
        // 1. 找到待删除节点
        while (target != null) {
            if (target.val == val) {
                break;
            } else if (target.val < val) {
                parent = target;
                target = target.right;
            } else {
                parent = target;
                target = target.left;
            }
        }

        if (target == null) {
            return;
        }

        // 2.对待删除节点进行几种情况的判断
        if (target.left == null && target.right != null) { // 对右节点直接给parent作为右
            shift(parent, target, target.right);
        } else if (target.left != null && target.right == null) {// 对左节点直接给parent作为左
            shift(parent, target, target.left);
        } else { // 左右节点均不是null
            // 待处理
        }
    }

    /*托孤方法*/
    private void shift(BSTreeNode parent, BSTreeNode deleted, BSTreeNode child) {
        if (parent == null) {
            root = child;
        } else if (deleted == parent.left) {
            parent.left = child;
        } else {
            parent.right = child;
        }
    }
```

## 6. LeetCode

### 6.1 公共祖先 -- 235

```bash
# 思路
- 如果两个待查找节点，在一个节点的左右两侧，则该节点就是它们的公共祖先
# 1，3
- 在2的左右两侧，则2就是
# 2，3 
- 不在4的左右两侧，则继续找4的左右孩子
```

![image-20231105114310381](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231105114310381.png)

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode ancestor = root;
    // 如果两个节点在同一侧，则继续向下找
    while ((ancestor.val > p.val && ancestor.val > q.val) || 
           (ancestor.val < p.val && ancestor.val < q.val)) {
        if (ancestor.val > p.val) {
            ancestor = ancestor.left;
        } else {
            ancestor = ancestor.right;
        }
    }
    return ancestor;
}
```

### 6.2 验证合法 -- 98

#### 中序遍历

- 中序遍历后的结果，就应该是一个有序递增的集合，如果下一个数据比上一个数据小了，则判断不合法

```java
public boolean isValidBST(TreeNode root) {
    LinkedList<TreeNode> path = new LinkedList<>();
    TreeNode cur = root;
    long prev = Long.MIN_VALUE; // 上一个数据
    while (cur != null || !path.isEmpty()) {
        if (cur != null) {
            path.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = path.pop();
            if (pop.val <= prev) {
                return false;
            }
            prev = pop.val;
            cur = pop.right;
        }
    }
    return true;
}
```

### 6.3 范围和 -- 938

- 给定二叉搜索树的根结点root，返回值位于范围 [low, high] 之间的所有结点的值的和

#### 中序遍历 

- 充分利用中序遍历及二叉搜索树的特性
- 只能从最小的开始，然后到high的时候结束，不能直接过滤点小于low的节点的过滤

```java
public int rangeSumBST(TreeNode root, int low, int high) {
      int result = 0;
      LinkedList<TreeNode> path = new LinkedList<>();
      TreeNode cur = root;
      while (cur != null || !path.isEmpty()) {
          if (cur != null) {
              path.push(cur);
              cur = cur.left;
          } else {
              TreeNode pop = path.pop();
              if (pop.val > high) {
                  return result;
              }

              if (low <= pop.val) {
                  result += pop.val;
              }
              cur = pop.right;
          }
      }
      return result;
  }
```

#### 剪枝递归

```java
public int rangeSumBST(TreeNode root, int low, int high) {
    if (root == null) {
        return 0;
    }
    if (root.val < low) {
        return rangeSumBST(root.right,low,high);
    }
    if (root.val > high) {
        return rangeSumBST(root.left,low,high);
    }
    return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
}
```

### 6.4 前序遍历构造二叉搜索树 -- 1008

- 数组长度大于1
- 数组中没有重复值

#### 依次put

- 其实就是将数组中的数据依次添加到二叉搜索树中
- 不能有效的利用前序遍历的顺序

```java
public TreeNode bstFromPreorder(int[] preorder) {
        TreeNode root = new TreeNode(preorder[0]);
        for (int i = 1; i < preorder.length; i++) {
            put(root, preorder[i]);
        }
        return root;
    }

    private void put(TreeNode root, int val) {
        TreeNode cur = root;
        TreeNode prev = null;
        while (cur != null) {
            prev = cur; // 记录上一个
            if (cur.val < val) {
                cur = cur.right;
            } else {
                cur = cur.left;
            }
        }
        TreeNode inserted = new TreeNode(val);
        if (val < prev.val) {
            prev.left = inserted;
        } else {
            prev.right = inserted;
        }
    }
```

### 6.5 两数之和 -- 653

- 二叉搜索树的两数之和

#### 中序遍历+Hash

- 中序遍历转换为排序数组，hash对数组处理

```java
public boolean findTarget(TreeNode root, int k) {
        List<Integer> result = inOrder(root);
        Map<Integer, Integer> cache = new HashMap<>();
        for (int i = 0; i < result.size(); i++) {
            if (cache.containsKey(k - result.get(i))) {
                return true;
            }
            cache.put(result.get(i), i);
        }
        return false;
    }

    private List<Integer> inOrder(TreeNode root) {
        LinkedList<TreeNode> path = new LinkedList<>();
        List<Integer> result = new ArrayList<>();
        TreeNode cur = root;
        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode pop = path.pop();
                result.add(pop.val);
                cur = pop.right;
            }
        }
        return result;
    }
```



# AVL树

## 1. 平衡二叉树

```bash
# 平衡
- 一个二叉树，如果一个节点的right和left，高度差超过1，则此节点失衡，需要旋转
- 一个二叉树，在增加和删除时，就会可能导致失衡
```

### 1.1 是否平衡 -- 110

![image-20231112093611479](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112093611479.png)

#### 自顶向下

- 

## 2. ALV树

### 2.1 AVLTreeNode

- AVL树是最早的一种自平衡二叉搜索树

```java
class AVLTreeNode {
    int val;
    int height = 1;
    AVLTreeNode left;
    AVLTreeNode right;

    public AVLTreeNode(int val) {
        this.val = val;
    }

    public AVLTreeNode(int val, AVLTreeNode left, AVLTreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 2.2 AVLTree

```java
class AVLTree {
  AVLTreeNode root = null;
}
```

## 3. 常见方法

### 3.1 height

- height：在添加节点时，就会自动对相应节点进行高度赋值

```java
public int getHeight(AVLTreeNode node) {
    return node == null ? 0 : node.height;
}

public void updateHeight(AVLTreeNode node) {
    node.height = Integer.max(getHeight(node.left), getHeight(node.right)) + 1;
}
```

### 3.2 insert

- 保证每次添加元素后，都是一个合法的平衡二叉搜索树

![image-20231111130306086](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231111130306086.png)

```bash
# 1. 添加
- 1.1 添加： 找到要insert的具体元素的位置进行添加
- 1.2 高度：  根据上一步骤中的找寻的路径，对每个绿色节点，从底到顶的更新高度

# 2. 判断平衡
- 2.1 判断是否平衡，平衡则什么不做，不平衡则根据四种失衡，进行对应旋转
- 2.2.旋转时候：对对应的下潜和上位节点进行高度更新
# 每次添加元素都会进行判断平衡，因此每次只需要对root节点进行判断平衡，不需要整体扫描整棵树
```

```java
public void insert(int val) {
      if (root == null) {
          root = new AVLTreeNode(val);
          return;
      }

      LinkedList<AVLTreeNode> path = new LinkedList<>(); // 要更新的节点高度
      AVLTreeNode cur = root;
      AVLTreeNode prev = null;

      while (cur != null) {
          path.push(cur);
          prev = cur;
          if (val < cur.val) {
              cur = cur.left;
          } else if (val > cur.val) {
              cur = cur.right;
          } else {
              System.out.println("equals, ignore");
          }
      }

      /*左或右*/
      AVLTreeNode inserted = new AVLTreeNode(val);
      if (prev.val > val) {
          prev.left = inserted;
      } else {
          prev.right = inserted;
      }

      /*按照搜索路径，更新每个节点的height*/
      while (!path.isEmpty()) {
          updateHeight(path.pop());
      }
      // 重新平衡
      
  }
```

### 3.3 remove

- 删除同理
- 代码待提交

### 3.4 bf

- balance factor: 一个节点，左子树高度-右子树高度
- 平衡： 0，1，-1

```java
public int balanceFactor(AVLTreeNode node) {
    AVLTreeNode left = node.left;
    AVLTreeNode right = node.right;
    return getHeight(left) - getHeight(right);
}
```

## 4. 四种失衡

- L和R表示谁高，顺序表示失衡节点和子树
- 平衡因子：一个节点，左子树高度-右子树高度，BF

### 4.1 LL

- 失衡节点(5)的 bf >1，即左边更高
- 失衡节点的左子树(3)的bf >=0，即左孩子也是左边高或者等高

``` bash
# 向右旋转一次
- 1. 向右旋转
- 2. 失衡节点的左孩子3的右子树4，变成了下潜节点5的左子树

# 高度
- 灰色节点的都没变，换爹节点4也不变
- 先更新下潜的节点高度
- 再更新上位节点高度
```

![image-20231109144447006](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109144447006.png)

### 4.2 LR

- 失衡节点(6)的BF>1，即左边更高
- 失衡节点的左子树(2)的BF<0, 即左子树的情况是：右边更高

```bash
# 失衡节点左子树向左旋转1次
- 变成4.1的情况
# 向右边旋转一次
```

![image-20231109150223352](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109150223352.png)

### 4.3 RL

- 失衡节点(2)的BF < -1, 即右边更高
- 失衡节点的右孩子(6)的BF>0, 即右孩子这边：左边更高

![image-20231109151053257](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109151053257.png)

### 4.4 RR

- 失衡节点(2)的BF<-1，即右边更高
- 失衡节点的右孩子(6)的BF<=0，即右孩子这边，右边更高或者等高

```bash
# 向左旋一次
- 1. 向左旋转
- 2. 失衡节点的右子树的左节点3，变为下潜节点2的右子树

# 高度
# 高度
- 灰色节点的都没变，换爹节点3也不变
- 先更新下潜的节点高度
- 再更新上位节点高度
```

![image-20231109144322946](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109144322946.png)

```java
/*右旋失衡节点*/
  public AVLTreeNode rightRotate(AVLTreeNode node) {
      AVLTreeNode up = node.left;
      AVLTreeNode down = node;
      AVLTreeNode child = up.right;

      down.right = child; // 换爹
      up.right = down;    // 上位
      updateHeight(down); // 更新高度顺序不能变
      updateHeight(up);
      return up;
  }

  /*左旋失衡节点*/
  public AVLTreeNode leftRotate(AVLTreeNode node) {
      AVLTreeNode up = node.right;
      AVLTreeNode down = node;
      AVLTreeNode child = up.left;

      down.right = child; // 换爹
      up.left = down;      // 上位
      updateHeight(down);
      updateHeight(up);
      return up;
  }

  /*先左旋，后右旋*/
  public AVLTreeNode leftRightRotate(AVLTreeNode node) {
      // 1. 失衡节点的左子树左旋转
      node.left = leftRotate(node.left);
      // 2. 根节点有旋转
      return rightRotate(node);
  }

  /*先右旋，再左转*/
  public AVLTreeNode rightLeftRotate(AVLTreeNode node) {
      node.right = rightRotate(node.right);
      return leftRotate(node);
  }

  /*平衡某个节点*/
  public AVLTreeNode balance(AVLTreeNode node) {
      if (node == null) {
          return null;
      }

      int balanceFactor = balanceFactor(node);
      /*不平衡的四种情况*/
      if (balanceFactor > 1 && balanceFactor(node.left) >= 0) { //LL
          return rightRotate(node);
      } else if (balanceFactor > 1 && balanceFactor(node.left) < 0) { // LR
          return leftRightRotate(node);
      } else if (balanceFactor < -1 && balanceFactor(node.right) > 0) { //RL
          return rightLeftRotate(node);
      } else if (balanceFactor < -1 && balanceFactor(node.right) <= 0) { //RR
          return leftRotate(node);
      }
      return node;
  }
```

#  红黑树

# B树

