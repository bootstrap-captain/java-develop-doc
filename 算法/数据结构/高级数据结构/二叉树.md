- æ¯ä¸ªèŠ‚ç‚¹ï¼Œæœ€å¤šåªå­˜åœ¨ä¸¤ä¸ªå­èŠ‚ç‚¹

# åŸºæœ¬æ¦‚å¿µ

```bash
# æ ¹èŠ‚ç‚¹
- äºŒå‰æ ‘çš„èµ·å§‹èŠ‚ç‚¹

# å¶å­èŠ‚ç‚¹
- æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹

# æ»¡äºŒå‰æ ‘
- æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå¶å­èŠ‚ç‚¹

# å®Œå…¨äºŒå‰æ ‘
- å…¶ä½™å±‚éƒ½å¿…é¡»å¡«æ»¡ï¼Œæœ€åä¸€å±‚å¯å¡«æ»¡å¯ä¸å¡«æ»¡
- æœ€åä¸€å±‚ï¼šå¿…é¡»ä»å·¦å‘å³å¡«å……
- å †

# å®ç°æ–¹å¼
- æ•°ç»„
- TreeNode
```

```java
package com.citi.tree;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

# å¹¿åº¦ä¼˜å…ˆ

- å±‚åºéå†
- BFS: Bredth First Search

```bash
# é˜Ÿåˆ—æ€è·¯
- æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
- å¤´å¼¹å‡ºï¼Œå¤„ç†å½“å‰èŠ‚ç‚¹ï¼Œç„¶åå°†å½“å‰èŠ‚ç‚¹çš„å·¦å³å­©å­ä¾æ¬¡å…¥é˜Ÿ
- ç›´åˆ°é˜Ÿåˆ—ä¸ºç©º
```

![image-20231014115013816](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014115013816.png)

## ğŸ˜åŸºç¡€æ‰“å°

- ä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³ï¼Œå±‚åºæ‰“å°

### è¿­ä»£ + é˜Ÿåˆ—

```java
public void printTree(TreeNode root) {
    LinkedList<TreeNode> path = new LinkedList<>();
    path.offer(root);

    while (!path.isEmpty()) {
        TreeNode pop = path.pop();
        System.out.println(pop.val);// æ‰“å°
        if (pop.left != null) {
            path.offer(pop.left);
        }
        if (pop.right != null) {
            path.offer(pop.right);
        }
    }
}
```

### é€’å½’

## ğŸ˜[637. äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

### è¿­ä»£+é˜Ÿåˆ—

```java
public List<Double> averageOfLevels(TreeNode root) {
    List<Double> result = new ArrayList<>();

    LinkedList<TreeNode> queuePaths = new LinkedList<>();
    queuePaths.offer(root);

    int currentLayerSize = 1;
    while (!queuePaths.isEmpty()) {
        double sum = 0D;
        int nextLayerSize = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode pop = queuePaths.pop();
            sum += pop.val;

            if (pop.left != null) {
                queuePaths.offer(pop.left);
                nextLayerSize++;
            }

            if (pop.right != null) {
                queuePaths.offer(pop.right);
                nextLayerSize++;
            }
        }
        result.add(sum / currentLayerSize);
        currentLayerSize = nextLayerSize;
    }

    return result;
}
```

## ğŸ˜¡[ 102/107 äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- 102é¢˜ç›®: ä»ä¸Šåˆ°ä¸‹ï¼Œæ¯å±‚æŒ‰ç…§ä»å·¦åˆ°å³å°è£…ç»“æœï¼š result.add(subResult);
- 107é¢˜ç›®: ä»å°åˆ°ä¸Šï¼Œæ¯å±‚æŒ‰ç…§ä»å·¦åˆ°å³å°è£…ç»“æœï¼š result.add(0, subResult);

### è¿­ä»£ + é˜Ÿåˆ—

```java
public List<List<Integer>> levelOrder(TreeNode root) {
  List<List<Integer>> result = new ArrayList<>();
  if (root == null) {
      return result;
  }

  LinkedList<TreeNode> path = new LinkedList<>();
  path.offer(root);
  int currentLayerSize = 1;

  while (!path.isEmpty()) {
      int nextLayerSize = 0;
      List<Integer> subResult = new ArrayList<>();
      for (int i = 0; i < currentLayerSize; i++) {
          TreeNode pop = path.pop();
          subResult.add(pop.val);
          if (pop.left != null) {
              nextLayerSize++;
              path.offer(pop.left);
          }
          if (pop.right != null) {
              nextLayerSize++;
              path.offer(pop.right);
          }
      }
      result.add(subResult);
      currentLayerSize = nextLayerSize;
  }

  return result;
}
```

## ğŸ˜¡[103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

### è¿­ä»£ + é˜Ÿåˆ—

- ä»ä¸Šåˆ°å°ï¼ŒæŒ‰ç…§ä¸€å±‚å·¦å³ï¼Œä¸€å±‚å³å·¦çš„é¡ºåº 
-  å¥‡æ•°å±‚ä»å·¦åˆ°å³ï¼Œå¶æ•°å±‚ä»å³åˆ°å·¦ï¼Œå’Œä¸Šé¢å¤„ç†ç±»ä¼¼

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    LinkedList<TreeNode> path = new LinkedList<>();
    path.offer(root);
    int currentLayerSize = 1;
    boolean flag = true;

    while (!path.isEmpty()) {
        int nextLayerSize = 0;
        List<Integer> subResult = new ArrayList<>();
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode pop = path.pop();
            if (flag) {
                subResult.add(pop.val);
            } else {
                subResult.add(0, pop.val);
            }
            if (pop.left != null) {
                nextLayerSize++;
                path.offer(pop.left);
            }
            if (pop.right != null) {
                nextLayerSize++;
                path.offer(pop.right);
            }
        }
        result.add(subResult);
        currentLayerSize = nextLayerSize;
        flag = !flag;
    }
    return result;
}
```

# æ·±åº¦ä¼˜å…ˆ

- éƒ½æ˜¯ä»å·¦å‘å³å¤„ç†çš„
- DFS: Depth First Search

## 1. éå†é¡ºåº

### å‰åºéå†

- å…ˆå¤„ç†çˆ¶èŠ‚ç‚¹ï¼Œå†å¤„ç†å­èŠ‚ç‚¹

![image-20231029161521912](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161521912.png)

### ä¸­åºéå†

- å¤„ç†å­èŠ‚ç‚¹çš„ä¸­é—´ï¼Œå¤„ç†çˆ¶èŠ‚ç‚¹

![image-20231029161415584](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161415584.png)

### ååºéå†

- å…ˆå¤„ç†å­èŠ‚ç‚¹ï¼Œå†å¤„ç†çˆ¶èŠ‚ç‚¹

![image-20231029161334384](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161334384.png)

## 2. é€’å½’

```java
package com.citi.tree;

import java.util.ArrayList;
import java.util.List;

public class Solution {

    static TreeNode root = new TreeNode(1, new TreeNode(2,
            new TreeNode(4, new TreeNode(7), new TreeNode(8)),
            null),
            new TreeNode(3, new TreeNode(5, new TreeNode(9), new TreeNode(11)),
                    new TreeNode(6, new TreeNode(12), null)));

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        pre(result, root);
        return result;
    }

    private void pre(List<Integer> result, TreeNode root) {
        if (root == null) {
            return;
        }
        result.add(root.val);
        pre(result, root.left);
        pre(result, root.right);
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        in(result, root);
        return result;
    }

    private void in(List<Integer> result, TreeNode root) {
        if (root == null) {
            return;
        }
        in(result, root.left);
        result.add(root.val);
        in(result, root.right);
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        post(result, root);
        return result;
    }

    private void post(List<Integer> result, TreeNode root) {
        if (root == null) {
            return;
        }
        post(result, root.left);
        post(result, root.right);
        result.add(root.val);
    }
}
```

## 3. è¿­ä»£ + æ ˆ

```java
package com.citi.tree;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Solution {

    static TreeNode root = new TreeNode(1, new TreeNode(2,
            new TreeNode(4, new TreeNode(7), new TreeNode(8)),
            null),
            new TreeNode(3, new TreeNode(5, new TreeNode(9), new TreeNode(11)),
                    new TreeNode(6, new TreeNode(12), null)));

    /*å‰åºéå†*/
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> paths = new LinkedList<>();

        TreeNode cur = root;
        while (cur != null || !paths.isEmpty()) {
            if (cur != null) {
                paths.push(cur);
                result.add(cur.val);
                cur = cur.left;
            } else {
                TreeNode pop = paths.pop();
                if (pop.right != null) {
                    cur = pop.right;
                }
            }
        }
        return result;
    }

    /*ä¸­åºéå†*/
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> paths = new LinkedList<>();

        TreeNode cur = root;
        while (cur != null || !paths.isEmpty()) {
            if (cur != null) {
                paths.push(cur);
                cur = cur.left;
            } else {
                TreeNode pop = paths.pop();
                result.add(pop.val);
                if (pop.right != null) {
                    cur = pop.right;
                }
            }
        }
        return result;
    }

    /*ååºéå†*/
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> paths = new LinkedList<>();
        TreeNode cur = root;

        TreeNode lastPop = null;
        while (cur != null || !paths.isEmpty()) {
            if (cur != null) {
                paths.push(cur);
                cur = cur.left;
            } else {
                TreeNode peek = paths.peek();
                if (peek.right == null || peek.right == lastPop) {
                    TreeNode pop = paths.pop();
                    lastPop = pop;
                    result.add(pop.val);
                } else {
                    cur = peek.right;
                }
            }
        }
        return result;
    }
}
```

# LeetCode

## ğŸ˜[101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree/)

### é€’å½’

```java
public boolean isSymmetric(TreeNode root) {
    return check(root.left, root.right);
}

private boolean check(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }

    if (left == null || right == null) {
        return false;
    }

    if (left.val != right.val) {
        return false;
    }

    return check(left.left, right.right) && check(left.right, right.left);
}
```

### è¿­ä»£+åŒç«¯é˜Ÿåˆ—

- å¤´ç»“ç‚¹æ’å…¥ä¸¤æ¬¡åˆ°åŒç«¯é˜Ÿåˆ—ä¸­
- å¼¹å‡ºä¸¤ä¸ªï¼Œå¹¶å°†è¿™ä¸¤ä¸ªçš„å·¦å³ç»“ç‚¹æŒ‰ç…§ç›¸åçš„é¡ºåºæ’å…¥åˆ°é˜Ÿåˆ—ä¸¤ç«¯
- ç›¸é‚»ä¸¤ä¸ªåº”è¯¥æ˜¯ä¸€æ ·çš„
- LinkedListå¯ä»¥æ·»åŠ å¤šä¸ªnullå€¼ï¼Œå› æ­¤å¦‚æœä¸€ä¸ªç»“ç‚¹ä¸ºnullæ—¶ï¼Œå°±ç›´æ¥æ·»åŠ nullå³å¯

![image-20231224160929316](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231224160929316.png)

```java
public boolean isSymmetric(TreeNode root) {
    LinkedList<TreeNode> dequeue = new LinkedList<>();
    dequeue.offer(root);
    dequeue.offer(root);

    while (!dequeue.isEmpty()) {
        TreeNode first = dequeue.pop();
        TreeNode second = dequeue.pop();
        if (first == null && second == null) {
            continue;
        }

        if (first == null || second == null) {
            return false;
        }

        if (first.val != second.val) {
            return false;
        }

        if (first == second) {
            dequeue.offerFirst(first.left);
            dequeue.offerLast(first.right);
        } else {
            dequeue.offerFirst(first.left);
            dequeue.offerFirst(second.right);

            dequeue.offerLast(second.left);
            dequeue.offerLast(first.right);
        }
    }
    return true;
}
```

## ğŸ˜[226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/)

### é€’å½’

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return root;
    }
    invert(root);
    return root;
}

private void invert(TreeNode root) {
    if (root == null) {
        return;
    }

    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
    invert(root.left);
    invert(root.right);
}
```

### è¿­ä»£

## ğŸ˜[104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

### å±‚åºéå†

- æŒ‰ç…§ä¸€å±‚æ¥åšç»“æœé›†åˆï¼Œæ€»å…±æœ‰å‡ å±‚ï¼Œå°±æ˜¯æœ€å¤§æ·±åº¦

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    List<List<Integer>> result = new ArrayList<>();
    LinkedList<TreeNode> paths = new LinkedList<>();

    paths.offer(root);
    int currentLayerSize = 1;

    while (!paths.isEmpty()) {
        int nextLayerSize = 0;
        List<Integer> subResult = new ArrayList<>();
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode pop = paths.pop();
            subResult.add(pop.val);
            if (pop.left != null) {
                paths.offer(pop.left);
                nextLayerSize++;
            }
            if (pop.right != null) {
                paths.offer(pop.right);
                nextLayerSize++;
            }
        }
        result.add(subResult);
        currentLayerSize = nextLayerSize;
    }
    return result.size();
}
```

### ååºéå†

- ååºéå†ï¼Œæ¯æ¬¡popçš„æ—¶å€™ï¼Œè®°å½•ä¸€ä¸‹popå‰çš„æœ€å¤§è·¯å¾„
- å–æœ€å¤§å€¼å³å¯

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;
    int maxDepth = 0;
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = paths.peek();
            if (peek.right == null || peek.right == lastPop) {
                maxDepth = Math.max(maxDepth,paths.size());
                TreeNode pop = paths.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return maxDepth;
}
```

### é€’å½’

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int leftDepth = maxDepth(root.left);
    int rightDepth = maxDepth(root.right);
    return Math.max(leftDepth, rightDepth) + 1;
}
```

## ğŸ˜[111. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

### å±‚åºéå†

- é‡åˆ°çš„ç¬¬ä¸€ä¸ªå¶å­ç»“ç‚¹æ‰€åœ¨çš„å±‚ï¼Œå°±æ˜¯æœ€å°æ·±åº¦

![image-20231030175543994](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231030175543994.png)

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> paths = new LinkedList<>();
    paths.offer(root);

    int currentLayerSize = 1;
    int layer = 1;
    while (!paths.isEmpty()) {
        int nextLayerSize = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode pop = paths.pop();
            if (pop.left == null && pop.right == null) {
                return layer;
            }
            if (pop.left != null) {
                paths.offer(pop.left);
                nextLayerSize++;
            }
            if (pop.right != null) {
                paths.offer(pop.right);
                nextLayerSize++;
            }
        }
        currentLayerSize = nextLayerSize;
        layer++;
    }
    return -1;
}
```

## ğŸ˜[257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](https://leetcode.cn/problems/binary-tree-paths/)

### DFS-ååº

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> result = new ArrayList<>();

    LinkedList<TreeNode> paths = new LinkedList<>();

    TreeNode cur = root;
    TreeNode lastPop = null;

    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = paths.peek();
            if (peek.left == null && peek.right == null) {
                String subResult = parse(paths);
                result.add(subResult);
            }
            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = paths.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }

    return result;
}

private String parse(LinkedList<TreeNode> paths) {
    String[] arr = new String[paths.size()];
    for (int i = 0; i < paths.size(); i++) {
        arr[arr.length - 1 - i] = String.valueOf(paths.get(i).val);
    }
    return String.join("->", arr);
}
```

## ğŸ˜[112. è·¯å¾„æ€»å’Œ](https://leetcode.cn/problems/path-sum/)

### DFS-ååº+è¿­ä»£

- å¦‚æœå¼¹å‡ºçš„æ˜¯å¶å­ç»“ç‚¹ï¼Œåˆ™è®¡ç®—ä¸€ä¸‹å½“å‰çš„sumå’Œ

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return false;
    }
    LinkedList<TreeNode> paths = new LinkedList<>();
    int sum = 0;
    TreeNode cur = root;
    TreeNode lastPop = null;
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            sum += cur.val;
            cur = cur.left;
        } else {
            TreeNode peek = paths.peek();
            if (peek.left == null && peek.right == null) { // åªæœ‰å¶å­èŠ‚ç‚¹æ—¶ï¼Œæ‰ä¼šè¿›è¡Œè®¡ç®—
                if (sum == targetSum) {
                    return true;
                }
            }

            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = paths.pop();
                sum -= pop.val;
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return false;
}
```

### BFS + è¿­ä»£

```java
  public boolean hasPathSum(TreeNode root, int targetSum) {
      if (root == null) {
          return false;
      }

      LinkedList<TreeNode> paths = new LinkedList<>();
      LinkedList<Integer> sums = new LinkedList<>();
      paths.offer(root);
      sums.offer(root.val);

      int currentLayerSize = 1;

      while (!paths.isEmpty()) {
          int nextLayerSize = 0;
          for (int i = 0; i < currentLayerSize; i++) {
              TreeNode pop = paths.pop();
              Integer value = sums.pop();

              if (pop.left == null && pop.right == null) { // æŸä¸ªèŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹äº†
                  if (value == targetSum) {
                      return true;
                  }
              }

              if (pop.left != null) {
                  paths.offer(pop.left);
                  sums.offer(value + pop.left.val);
                  nextLayerSize++;
              }

              if (pop.right != null) {
                  paths.offer(pop.right);
                  sums.offer(value + pop.right.val);
                  nextLayerSize++;
              }

          }
          currentLayerSize = nextLayerSize;
      }
      return sums.contains(targetSum);
  }
```

### é€’å½’

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return false;
    }

    if (root.left == null && root.right == null) {
        return root.val == targetSum;
    }

    boolean leftResult = hasPathSum(root.left, targetSum - root.val);
    boolean rightResult = hasPathSum(root.right, targetSum - root.val);
    return leftResult || rightResult;
}
```

## ğŸ˜¡[113. è·¯å¾„æ€»å’Œ II](https://leetcode.cn/problems/path-sum-ii/)

### DFS-ååº+è¿­ä»£

```java
  public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
      List<List<Integer>> result = new ArrayList<>();
      if (root == null) {
          return result;
      }

      LinkedList<TreeNode> paths = new LinkedList<>();
      TreeNode cur = root;
      TreeNode lastPop = null;
      int sum = 0;

      while (cur != null || !paths.isEmpty()) {
          if (cur != null) {
              paths.push(cur);
              sum += cur.val;
              cur = cur.left;
          } else {
              TreeNode peek = paths.peek();
              if (peek.left == null && peek.right == null) {// æœ€åä¸€ä¸ªèŠ‚ç‚¹äº†
                  if (sum == targetSum) {
                      List<Integer> subResult = getPath(paths);
                      result.add(subResult);
                  }
              }

              if (peek.right == null || peek.right == lastPop) {
                  TreeNode pop = paths.pop();
                  sum -= pop.val;
                  lastPop = pop;
              } else {
                  cur = peek.right;
              }
          }
      }
      return result;
  }

  private List<Integer> getPath(LinkedList<TreeNode> paths) {
      List<Integer> result = new ArrayList<>();
      for (int i = 0; i < paths.size(); i++) {
          result.add(0,paths.get(i).val);
      }
      return result;
  }
```



