# AVL树

## 1. 平衡二叉树

```bash
# 平衡
- 一个二叉树，如果一个节点的right和left，高度差超过1，则此节点失衡，需要旋转
- 一个二叉树，在增加和删除时，就会可能导致失衡
```

### 1.1 是否平衡 -- 110

![image-20231112093611479](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231112093611479.png)

#### 自顶向下

- 

## 2. ALV树

### 2.1 AVLTreeNode

- AVL树是最早的一种自平衡二叉搜索树

```java
class AVLTreeNode {
    int val;
    int height = 1;
    AVLTreeNode left;
    AVLTreeNode right;

    public AVLTreeNode(int val) {
        this.val = val;
    }

    public AVLTreeNode(int val, AVLTreeNode left, AVLTreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 2.2 AVLTree

```java
class AVLTree {
  AVLTreeNode root = null;
}
```

## 3. 常见方法

### 3.1 height

- height：在添加节点时，就会自动对相应节点进行高度赋值

```java
public int getHeight(AVLTreeNode node) {
    return node == null ? 0 : node.height;
}

public void updateHeight(AVLTreeNode node) {
    node.height = Integer.max(getHeight(node.left), getHeight(node.right)) + 1;
}
```

### 3.2 insert

- 保证每次添加元素后，都是一个合法的平衡二叉搜索树

![image-20231111130306086](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231111130306086.png)

```bash
# 1. 添加
- 1.1 添加： 找到要insert的具体元素的位置进行添加
- 1.2 高度：  根据上一步骤中的找寻的路径，对每个绿色节点，从底到顶的更新高度

# 2. 判断平衡
- 2.1 判断是否平衡，平衡则什么不做，不平衡则根据四种失衡，进行对应旋转
- 2.2.旋转时候：对对应的下潜和上位节点进行高度更新
# 每次添加元素都会进行判断平衡，因此每次只需要对root节点进行判断平衡，不需要整体扫描整棵树
```

```java
public void insert(int val) {
      if (root == null) {
          root = new AVLTreeNode(val);
          return;
      }

      LinkedList<AVLTreeNode> path = new LinkedList<>(); // 要更新的节点高度
      AVLTreeNode cur = root;
      AVLTreeNode prev = null;

      while (cur != null) {
          path.push(cur);
          prev = cur;
          if (val < cur.val) {
              cur = cur.left;
          } else if (val > cur.val) {
              cur = cur.right;
          } else {
              System.out.println("equals, ignore");
          }
      }

      /*左或右*/
      AVLTreeNode inserted = new AVLTreeNode(val);
      if (prev.val > val) {
          prev.left = inserted;
      } else {
          prev.right = inserted;
      }

      /*按照搜索路径，更新每个节点的height*/
      while (!path.isEmpty()) {
          updateHeight(path.pop());
      }
      // 重新平衡
      
  }
```

### 3.3 remove

- 删除同理
- 代码待提交

### 3.4 bf

- balance factor: 一个节点，左子树高度-右子树高度
- 平衡： 0，1，-1

```java
public int balanceFactor(AVLTreeNode node) {
    AVLTreeNode left = node.left;
    AVLTreeNode right = node.right;
    return getHeight(left) - getHeight(right);
}
```

## 4. 四种失衡

- L和R表示谁高，顺序表示失衡节点和子树
- 平衡因子：一个节点，左子树高度-右子树高度，BF

### 4.1 LL

- 失衡节点(5)的 bf >1，即左边更高
- 失衡节点的左子树(3)的bf >=0，即左孩子也是左边高或者等高

``` bash
# 向右旋转一次
- 1. 向右旋转
- 2. 失衡节点的左孩子3的右子树4，变成了下潜节点5的左子树

# 高度
- 灰色节点的都没变，换爹节点4也不变
- 先更新下潜的节点高度
- 再更新上位节点高度
```

![image-20231109144447006](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109144447006.png)

### 4.2 LR

- 失衡节点(6)的BF>1，即左边更高
- 失衡节点的左子树(2)的BF<0, 即左子树的情况是：右边更高

```bash
# 失衡节点左子树向左旋转1次
- 变成4.1的情况
# 向右边旋转一次
```

![image-20231109150223352](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109150223352.png)

### 4.3 RL

- 失衡节点(2)的BF < -1, 即右边更高
- 失衡节点的右孩子(6)的BF>0, 即右孩子这边：左边更高

![image-20231109151053257](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109151053257.png)

### 4.4 RR

- 失衡节点(2)的BF<-1，即右边更高
- 失衡节点的右孩子(6)的BF<=0，即右孩子这边，右边更高或者等高

```bash
# 向左旋一次
- 1. 向左旋转
- 2. 失衡节点的右子树的左节点3，变为下潜节点2的右子树

# 高度
# 高度
- 灰色节点的都没变，换爹节点3也不变
- 先更新下潜的节点高度
- 再更新上位节点高度
```

![image-20231109144322946](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231109144322946.png)

```java
/*右旋失衡节点*/
  public AVLTreeNode rightRotate(AVLTreeNode node) {
      AVLTreeNode up = node.left;
      AVLTreeNode down = node;
      AVLTreeNode child = up.right;

      down.right = child; // 换爹
      up.right = down;    // 上位
      updateHeight(down); // 更新高度顺序不能变
      updateHeight(up);
      return up;
  }

  /*左旋失衡节点*/
  public AVLTreeNode leftRotate(AVLTreeNode node) {
      AVLTreeNode up = node.right;
      AVLTreeNode down = node;
      AVLTreeNode child = up.left;

      down.right = child; // 换爹
      up.left = down;      // 上位
      updateHeight(down);
      updateHeight(up);
      return up;
  }

  /*先左旋，后右旋*/
  public AVLTreeNode leftRightRotate(AVLTreeNode node) {
      // 1. 失衡节点的左子树左旋转
      node.left = leftRotate(node.left);
      // 2. 根节点有旋转
      return rightRotate(node);
  }

  /*先右旋，再左转*/
  public AVLTreeNode rightLeftRotate(AVLTreeNode node) {
      node.right = rightRotate(node.right);
      return leftRotate(node);
  }

  /*平衡某个节点*/
  public AVLTreeNode balance(AVLTreeNode node) {
      if (node == null) {
          return null;
      }

      int balanceFactor = balanceFactor(node);
      /*不平衡的四种情况*/
      if (balanceFactor > 1 && balanceFactor(node.left) >= 0) { //LL
          return rightRotate(node);
      } else if (balanceFactor > 1 && balanceFactor(node.left) < 0) { // LR
          return leftRightRotate(node);
      } else if (balanceFactor < -1 && balanceFactor(node.right) > 0) { //RL
          return rightLeftRotate(node);
      } else if (balanceFactor < -1 && balanceFactor(node.right) <= 0) { //RR
          return leftRotate(node);
      }
      return node;
  }
```

# 