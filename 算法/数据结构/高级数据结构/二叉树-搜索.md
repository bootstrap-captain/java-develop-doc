# 基本方法

- 节点value不重复
- 所有节点，value比左子树的value大，同时也比右子树的value小

```java
package com.citi.tree;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java
    TreeNode root = new TreeNode(8, new TreeNode(6,
            new TreeNode(4, new TreeNode(2), new TreeNode(5)), null),
            new TreeNode(15, new TreeNode(13, new TreeNode(10), new TreeNode(14))
                    , new TreeNode(20, new TreeNode(18), null)));
```

![image-20231225154313795](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231225154313795.png)

## 1. 根据key查找

### 递归

```java
public TreeNode getByValueRecur(TreeNode root, int value) {
    if (root == null) {
        return null;
    }

    if (root.val < value) {
        return getByValueIterator(root.right, value);
    } else if (root.val > value) {
        return getByValueRecur(root.left, value);
    }else{
        return root;
    }
}
```

### 迭代

```java
public TreeNode getByValueIterator(TreeNode root, int value) {
    TreeNode cur = root;
    while (cur != null) {
        if (cur.val < value) {
            cur = cur.right;
        } else if (cur.val > value) {
            cur = cur.left;
        } else {
            return cur;
        }
    }
    return null;
}
```

## 2. 最小/大key

- 最小是找左边，最大是找右边

### 递归

```java
public TreeNode getMinRecur(TreeNode root) {
    if (root == null) {
        return null;
    }

    if (root.left == null) {
        return root;
    }

    TreeNode min = getMinRecur(root.left);
    return min;
}

public TreeNode getMaxRecur(TreeNode root) {
    if (root == null) {
        return null;
    }

    if (root.right == null) {
        return root;
    }
    TreeNode max = getMaxRecur(root.right);
    return max;
}
```

### 迭代

```java
public TreeNode getMinIterator(TreeNode root) {
    if (root == null) {
        return null;
    }

    TreeNode cur = root;
    while (cur.left != null) {
        cur = cur.left;
    }
    return cur;
}

public TreeNode getMaxIterator(TreeNode root) {
    if (root == null) {
        return null;
    }

    TreeNode cur = root;
    while (cur.right != null) {
        cur = cur.right;
    }
    return cur;
}
```

## 3. put

- key如果存在，则更新，key不存在，新增左或右节点

```java
public boolean put(TreeNode root, int value) {
    if (root == null) {
        root = new TreeNode(value); // 空树
        return true;
    }

    TreeNode cur = root;
    TreeNode prev = null;
    while (cur != null) {
        if (cur.val > value) {
            prev = cur;
            cur = cur.left;
        } else if (cur.val < value) {
            prev = cur;
            cur = cur.right;
        } else {
            return false; // 原来已经存在，替换即可
        }
    }

    /*左或右*/
    TreeNode inserted = new TreeNode(value);
    if (value < prev.val) {
        prev.left = inserted;
    } else {
        prev.right = inserted;
    }
    return true;
}
```

## 4. 前任

- 即上一个节点
- 节点 p的前任是值比p.val小的节点中键值最大的节点, 如5的前任是4

![image-20231225154313795](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231225154313795.png)

### 中序 + 迭代

```java
public TreeNode beforeNode(TreeNode root, TreeNode p) {
    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;

    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = paths.pop();
            if (pop.val == p.val) {
                return lastPop;
            }

            lastPop = pop;
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }

    return lastPop;
}
```

### 搜索树

```bash
# 前任
- 先找到目标节点
- 目标节点有左子树，前任就是左子树的最大值：                 6 的前任是 5
- 目标节点没有左子树，前任就是离它最近的，从左边来的祖先：      10 的前任是 8
```

```java
public TreeNode beforeNode(TreeNode root, TreeNode p) {
    TreeNode cur = root;
    TreeNode leftAncestor = null;

    while (cur != null) {
        if (cur.val < p.val) {
            leftAncestor = cur;
            cur = cur.right;
        } else if (cur.val > p.val) {
            cur = cur.left;
        } else {
            break; // 找到目标节点，退出
        }
    }

    if (cur.left != null) { // 找左子树的最大值
        TreeNode node = cur.left;
        while (node.right != null) {
            node = node.right;
        }
        return node;
    } else {
        return leftAncestor;
    }
}
```

## 5.😡[后继](https://leetcode.cn/problems/P5rCT8/)

- 即下一个节点
- 节点 p的后继是值比p.val大的节点中键值最小的节点, 如5的后继是6
- root节点不为空，p是root中的一个

![image-20231225154313795](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231225154313795.png)

### 中序-迭代

- 效率较低，没有充分利用二叉搜索树的特性

```java
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;

    boolean isTargetFound = false;

    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = paths.pop();
            if (isTargetFound) { // 当前pop的就是后继
                return pop;
            }
            if (pop.val == p.val) { // target找到后，打标
                isTargetFound = true;
            }
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }

    return null;
}
```

### 搜索树

```bash
# 后任
- 先找到目标节点
- 目标节点有右子树， 后任就是右子树的最小值：               15的后任是18
- 目标节点没有右子树
                  - 有右边来的祖先， 后任是最近的一个右边来的祖先：      6的后任是8， 5的后任是6
                  - 没有右边来的祖先， 则后任是null       
```

```java
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    TreeNode rightAncestor = null;
    TreeNode cur = root;

    while (cur != null) {
        if (cur.val < p.val) {
            cur = cur.right;
        } else if (cur.val > p.val) {
            rightAncestor = cur;
            cur = cur.left;
        } else {
            break;
        }
    }

    if (cur.right != null) {
        // 找右子树的最小值
        TreeNode node = cur.right;
        while (node.left != null) {
            node = node.left;
        }
        return node;
    } else {
        return rightAncestor;
    }
}
```

## 6.  删除

### 5.1 左节点或右节点为空

```bash
# 1. 删除节点没有left，将right给parent                           节点9
# 2. 删除节点没有right，将left给parent                           节点6
# 3. 删除节点没有left 和 right，直接将null给parent                节点1， 包含在1，2两种情况里面
```

![image-20231106110112165](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231106110112165.png)

![image-20231106110326081](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231106110326081.png)

### 5.2 左右节点均不为空

```java
    public void delete(int val) {
        BSTreeNode target = root;
        if (target == null) {
            return;
        }
        BSTreeNode parent = null;
        // 1. 找到待删除节点
        while (target != null) {
            if (target.val == val) {
                break;
            } else if (target.val < val) {
                parent = target;
                target = target.right;
            } else {
                parent = target;
                target = target.left;
            }
        }

        if (target == null) {
            return;
        }

        // 2.对待删除节点进行几种情况的判断
        if (target.left == null && target.right != null) { // 对右节点直接给parent作为右
            shift(parent, target, target.right);
        } else if (target.left != null && target.right == null) {// 对左节点直接给parent作为左
            shift(parent, target, target.left);
        } else { // 左右节点均不是null
            // 待处理
        }
    }

    /*托孤方法*/
    private void shift(BSTreeNode parent, BSTreeNode deleted, BSTreeNode child) {
        if (parent == null) {
            root = child;
        } else if (deleted == parent.left) {
            parent.left = child;
        } else {
            parent.right = child;
        }
    }
```

# LeetCode

## 😡[235. 最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```bash
# 思路
- 如果两个待查找节点，在一个节点的左右两侧，则该节点就是它们的公共祖先

# 10     18
- 在 15 的左右两侧，则 15 就是, 且只会有一个公共祖先

# 15     18 
- 不在 8 的左右两侧，则继续找 8 的左或右孩子(判断), 找到 15
```

![image-20231225154313795](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231225154313795.png)

### 迭代

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode ancestor = root;
    while ((ancestor.val > p.val && ancestor.val > q.val) ||
            (ancestor.val < p.val && ancestor.val < q.val)) { // 在同侧

        if (ancestor.val > p.val) {
            ancestor = ancestor.left;
        } else {
            ancestor = ancestor.right;
        }
    }

    return ancestor;
}
```

### 递归

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

    if (p.val < root.val && q.val < root.val) {
        return lowestCommonAncestor(root.left, p, q);
    }

    if (root.val < p.val && root.val < q.val) {
        return lowestCommonAncestor(root.right, p, q);
    }

    return root;
}
```

## 😡[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

### 递归 + 左右合法

- 当前结点，必须比左子树中最大的大，比如比右子树最小的小

```java
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }

    boolean leftResult = false;
    if (root.left == null) {
        leftResult = true;
    } else {
        TreeNode max = root.left;
        while (max.right != null) {
            max = max.right;
        }
        leftResult = root.val > max.val;
    }

    boolean rightResult = false;
    if (root.right == null) {
        rightResult = true;
    } else {
        TreeNode min = root.right;
        while (min.left != null) {
            min = min.left;
        }
        rightResult = root.val < min.val;
    }

    return leftResult && rightResult && isValidBST(root.left) && isValidBST(root.right);
}
```

### 递归 + 左右合法边界

```java

```



### 递归 + 中序

- 中序遍历后的结果，就应该是一个有序递增的集合，如果下一个数据比上一个数据小了，则判断不合法

```java

```



### 迭代 + 中序

- 中序遍历后的结果，就应该是一个有序递增的集合，如果下一个数据比上一个数据小了，则判断不合法

```java
public boolean isValidBST(TreeNode root) {
    LinkedList<TreeNode> paths = new LinkedList<>();

    TreeNode cur = root;
    TreeNode lastPop = null;

    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = paths.pop();
            if (lastPop != null && lastPop.val >= pop.val) {
                return false;
            }
            lastPop = pop;
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }

    return true;
}
```

## 😎[938. 范围和](https://leetcode.cn/problems/range-sum-of-bst/)

- 给定二叉搜索树的根结点root，返回值位于范围 [low, high] 之间的所有结点的值的和

### 迭代 + 中序

- 利用中序遍历及二叉搜索树的特性
- 只能从最小的开始，然后到high的时候结束，不能直接过滤点小于low的节点的过滤

```java
public int rangeSumBST(TreeNode root, int low, int high) {
    LinkedList<TreeNode> path = new LinkedList<>();

    int result = 0;
    TreeNode cur = root;
    while (cur != null || !path.isEmpty()) {
        if (cur != null) {
            path.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = path.pop();
            if (pop.val > high) { // 到高点了，直接返回
                return result;
            }

            if (pop.val >= low) {
                result += pop.val;
            }

            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }
    return result;
}
```

### 递归 + 剪枝

```java
public int rangeSumBST(TreeNode root, int low, int high) {

    if (root == null) {
        return 0;
    }

    /*本轮处理的逻辑*/
    if (root.val < low) {
        return rangeSumBST(root.right, low, high);
    }

    if (root.val > high) {
        return rangeSumBST(root.left, low, high);
    }

    int result = root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
    return result;
}
```

## 😎[653. 两数之和 IV - 输入二叉搜索树](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)

- 二叉搜索树的两数之和

### 中序 + Hash

- 中序遍历转换为排序数组，hash对数组处理

```java
public boolean findTarget(TreeNode root, int k) {
    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    ArrayList<Integer> result = new ArrayList<>();

    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = paths.pop();
            result.add(pop.val);
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }

    Set<Integer> hash = new HashSet<>();
    for (Integer el : result) {
        if (!hash.add(k - el)) {
            return true;
        }
        hash.add(el);
    }
    return false;
}
```
