# åŸºæœ¬æ¦‚å¿µ

```bash
# äºŒå‰æ ‘
- æ¯ä¸ªèŠ‚ç‚¹ï¼Œæœ€å¤šåªå­˜åœ¨ä¸¤ä¸ªå­èŠ‚ç‚¹

# æ ¹èŠ‚ç‚¹
- äºŒå‰æ ‘çš„èµ·å§‹èŠ‚ç‚¹

# å¶å­èŠ‚ç‚¹
- æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹

# æ»¡äºŒå‰æ ‘
- æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå¶å­èŠ‚ç‚¹

# å®Œå…¨äºŒå‰æ ‘
- å…¶ä½™å±‚éƒ½å¿…é¡»å¡«æ»¡ï¼Œæœ€åä¸€å±‚å¯å¡«æ»¡å¯ä¸å¡«æ»¡
- æœ€åä¸€å±‚ï¼šå¿…é¡»ä»å·¦å‘å³å¡«å……
- å †

# å®ç°æ–¹å¼
- æ•°ç»„
- TreeNode
```

```java
package com.citi.tree;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

# å¹¿åº¦ä¼˜å…ˆ

- BFS: Bredth First Search
- å¤„ç†å®Œå½“å‰å±‚çš„ç»“ç‚¹çš„å€¼çš„æ—¶å€™ï¼Œæ‰å»å¤„ç†ä¸‹ä¸€å±‚çš„ç»“æœ
- è¿­ä»£å’Œé€’å½’æ€è·¯åŸºæœ¬ä¸€è‡´ï¼Œåé¢é¢˜ç›®å…¨éƒ¨é‡‡ç”¨è¿­ä»£å†™æ³•

## 1. é˜Ÿåˆ— + è¿­ä»£

```bash
# é˜Ÿåˆ—æ€è·¯
- æ ¹èŠ‚ç‚¹å…¥é˜Ÿ
- å¤´å¼¹å‡ºï¼Œå¤„ç†å½“å‰èŠ‚ç‚¹ï¼Œç„¶åå°†å½“å‰èŠ‚ç‚¹çš„å·¦å³å­©å­ä¾æ¬¡å…¥é˜Ÿ
- ç›´åˆ°é˜Ÿåˆ—ä¸ºç©º
```

![image-20231014115013816](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014115013816.png)

```java
public void levelOrder(TreeNode root) {
    if (root == null) {
        return;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    while (!queue.isEmpty()) {
        int nextLayerSize = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();

            System.out.println(poll.val); // å¤„ç†

            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        System.out.println("====== åˆ†å‰²ç¬¦å· ======"); // å¤„ç†
        currentLayerSize = nextLayerSize;
    }
}
```

## 2. é˜Ÿåˆ— + é€’å½’

- å…¶å®å°±æ˜¯ä¸Šé¢çš„é€’å½’å†™æ³•è€Œå·²

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    bfsRecur(queue, result);
    return result;
}

/*é˜Ÿåˆ—*/
private void bfsRecur(Queue<TreeNode> queue, List<List<Integer>> result) {
    if (queue.isEmpty()) {
        return;
    }

    List<Integer> subResult = new ArrayList<>();
    Queue<TreeNode> nextQueue = new LinkedList<>();

    while (!queue.isEmpty()) {
        TreeNode poll = queue.poll();
        subResult.add(poll.val);
        if (poll.left != null) {
            nextQueue.offer(poll.left);
        }
        if (poll.right != null) {
            nextQueue.offer(poll.right);
        }
    }
    result.add(subResult);

    bfsRecur(nextQueue, result);
}
```

# æ·±åº¦ä¼˜å…ˆ

- éƒ½æ˜¯ä»å·¦å‘å³å¤„ç†çš„
- DFS: Depth First Search

## âœ… [144.å‰åºéå†](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

- å…ˆå¤„ç†çˆ¶èŠ‚ç‚¹ï¼Œå†å¤„ç†å­èŠ‚ç‚¹

![image-20231029161521912](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161521912.png)

### æ ˆ + è¿­ä»£

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            result.add(cur.val);
            stack.push(cur); // å‰åºéå†ï¼ŒåŠ è¿›å»çš„æ—¶å€™éå†
            cur = cur.left;
        } else {
            TreeNode pop = stack.pop();
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }

    return result;
}
```

### é€’å½’

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    preOrder(root, result);
    return result;
}

private void preOrder(TreeNode root, List<Integer> result) {
    if (root == null) {
        return;
    }
    result.add(root.val);
    preOrder(root.left, result);
    preOrder(root.right, result);
}
```

## âœ… [94.ä¸­åºéå†](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

- å¤„ç†å­èŠ‚ç‚¹çš„ä¸­é—´ï¼Œå¤„ç†çˆ¶èŠ‚ç‚¹

![image-20231029161415584](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161415584.png)

### æ ˆ + è¿­ä»£

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;

    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode pop = stack.pop();

            result.add(pop.val); // å¼¹å‡ºæ¥çš„æ—¶å€™åŠ 

            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }
    return result;
}
```

### é€’å½’

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    inorder(root, result);
    return result;
}

private void inorder(TreeNode root, List<Integer> result) {
    if (root == null) {
        return;
    }
    inorder(root.left, result);
    result.add(root.val);
    inorder(root.right, result);
}
```

## âœ… [145. ååºéå†](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

- å…ˆå¤„ç†å­èŠ‚ç‚¹ï¼Œå†å¤„ç†çˆ¶èŠ‚ç‚¹

![image-20231029161334384](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231029161334384.png)

### æ ˆ + è¿­ä»£

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    LinkedList<TreeNode> stack = new LinkedList<>();

    TreeNode cur = root;
    TreeNode lastPop = null;

    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = stack.peek();
            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = stack.pop();
                result.add(pop.val); // å¤„ç†ç»“æœ
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return result;
}
```

### é€’å½’

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    postorder(root, result);
    return result;
}

private void postorder(TreeNode root, List<Integer> result) {
    if (root == null) {
        return;
    }
    postorder(root.left, result);
    postorder(root.right, result);
    result.add(root.val);
}
```

# LeetCode

## å±‚åºå¤„ç†

### ğŸ˜[102. äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- æ¯å±‚ä»å·¦åˆ°å³å°è£…ï¼Œä»é¡¶åˆ°åº•

#### BFS

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    while (!queue.isEmpty()) {
        int nextLayerSize = 0;
        List<Integer> subResult = new ArrayList<>();
        // å¤„ç†å½“å‰å±‚
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            subResult.add(poll.val);
            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        result.add(subResult);
        currentLayerSize = nextLayerSize;
    }

    return result;
}
```

#### DFS - é€’å½’

- é€’å½’æ—¶ï¼ŒåŒ…è£…çš„ç»“æœï¼Œæå–æˆæˆå‘˜å˜é‡ï¼Œæ•ˆç‡æ¯”é€šè¿‡ä¼ å‚çš„æ–¹å¼å—

```java
private List<List<Integer>> result = new ArrayList<>();

public List<List<Integer>> levelOrder(TreeNode root) {
    dfsRecur(root, 1);
    return result;
}

/*ä»ç¬¬1å±‚å¼€å§‹*/
private void dfsRecur(TreeNode root, int currentLayer) {
    if (root == null) {
        return;
    }
    List<Integer> layerResult;

    if (result.size() < currentLayer) {
        layerResult = new ArrayList<>();
        result.add(layerResult);
    } else {
        layerResult = result.get(currentLayer - 1);
    }

    layerResult.add(root.val);

    currentLayer++;
    dfsRecur(root.left, currentLayer);
    dfsRecur(root.right, currentLayer);
}
```

### ğŸ˜ [107. äºŒå‰æ ‘çš„å±‚åºéå† II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

- æ¯å±‚ä»å·¦åˆ°å³ï¼Œä»åº•åˆ°é¡¶

#### BFS

- æ€è·¯åŒä¸Šï¼Œå°è£…ç»“æœçš„æ—¶å€™åˆ©ç”¨ArrayListçš„ç‰¹æ€§

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    while (!queue.isEmpty()) {
        int nextLayerSize = 0;
        List<Integer> subResult = new ArrayList<>();
        // å¤„ç†å½“å‰å±‚
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            subResult.add(poll.val);
            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        result.add(0, subResult); // åªæœ‰è¿™ä¸€è¡Œä¸åŒ
        currentLayerSize = nextLayerSize;
    }

    return result;
}
```

#### DFS - é€’å½’

```java
private List<List<Integer>> result = new ArrayList<>();

public List<List<Integer>> levelOrderBottom(TreeNode root) {
    dfsRecur(root, 1);
    return result;
}

private void dfsRecur(TreeNode root, int currentLayer) {
    if (root == null) {
        return;
    }

    List<Integer> layerResult;
    if (result.size() < currentLayer) {
        layerResult = new ArrayList<>();
        result.add(0, layerResult);
    } else {
        layerResult = result.get(result.size() - currentLayer);
    }

    layerResult.add(root.val);

    currentLayer++;
    dfsRecur(root.left, currentLayer);
    dfsRecur(root.right, currentLayer);
}
```

### ğŸ˜ [103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

#### BFS

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    boolean leftToRight = true;
    while (!queue.isEmpty()) {
        List<Integer> subResult = new ArrayList<>();
        int nextLayerSize = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            if (leftToRight) {
                subResult.add(poll.val);
            } else {
                subResult.add(0, poll.val);
            }

            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        leftToRight = !leftToRight;
        currentLayerSize = nextLayerSize;
        result.add(subResult);
    }
    return result;
}
```

#### DFS - é€’å½’

```java
private List<List<Integer>> result = new ArrayList<>();

public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    dfsRecur(root, 1, true);
    return result;
}

private void dfsRecur(TreeNode root, int currentLayer, boolean leftToRight) {
    if (root == null) {
        return;
    }
    List<Integer> layerResult;
    if (result.size() < currentLayer) {
        layerResult = new ArrayList<>();
        result.add(layerResult);
    } else {
        layerResult = result.get(currentLayer - 1);
    }

    if (leftToRight) {
        layerResult.add(root.val);
    } else {
        layerResult.add(0, root.val);
    }

    leftToRight = !leftToRight;
    currentLayer++;
    dfsRecur(root.left, currentLayer, leftToRight);
    dfsRecur(root.right, currentLayer, leftToRight);
}
```

### âœ… [637. äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

#### BFS

```java
public List<Double> averageOfLevels(TreeNode root) {
    List<Double> result = new ArrayList<>();

    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    while (!queue.isEmpty()) {
        double sum = 0;
        int nextLayerSize = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            sum += poll.val;
            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        result.add(sum / currentLayerSize);
        currentLayerSize = nextLayerSize;
    }
    return result;
}
```

#### DFS - é€’å½’

```java
private List<Integer> sizeList = new ArrayList<>();
private List<Double> sumList = new ArrayList<>();

public List<Double> averageOfLevels(TreeNode root) {
    dfsRecur(root, 1);
    List<Double> result = new ArrayList<>();
    for (int i = 0; i < sumList.size(); i++) {
        result.add(sumList.get(i) / sizeList.get(i));
    }

    return result;
}

/*currentLayerä»1å¼€å§‹*/
private void dfsRecur(TreeNode root, int currentLayer) {
    if (root == null) {
        return;
    }

    if (sumList.size() < currentLayer) {
        sumList.add((double) root.val);
        sizeList.add(1);
    } else {
        sumList.set(currentLayer - 1, sumList.get(currentLayer - 1) + root.val);
        sizeList.set(currentLayer - 1, sizeList.get(currentLayer - 1) + 1);
    }

    currentLayer++;
    dfsRecur(root.left, currentLayer);
    dfsRecur(root.right, currentLayer);
}
```

### ğŸ˜ [515. åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

#### BFS

```java
public List<Integer> largestValues(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    while (!queue.isEmpty()) {
        int nextLayerSize = 0;
        long max = Long.MIN_VALUE;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            max = Math.max(max, poll.val);
            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }
            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        result.add((int) max);
        currentLayerSize = nextLayerSize;
    }

    return result;
}
```

#### DFS - é€’å½’

```java
List<Integer> maxList = new ArrayList<>();

public List<Integer> largestValues(TreeNode root) {
    dfsRecur(root, 1);
    return maxList;
}

private void dfsRecur(TreeNode root, int currentLayer) {
    if (root == null) {
        return;
    }

    if (maxList.size() < currentLayer) {
        maxList.add(root.val);
    } else {
        maxList.set(currentLayer - 1, Math.max(maxList.get(currentLayer - 1), root.val));
    }

    currentLayer++;
    dfsRecur(root.left, currentLayer);
    dfsRecur(root.right, currentLayer);
}
```

### ğŸ˜ [199. äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode.cn/problems/binary-tree-right-side-view/)

#### BFS

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    while (!queue.isEmpty()) {
        int nextLayerSize = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            if (i == currentLayerSize - 1) {
                result.add(poll.val);
            }
            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        currentLayerSize = nextLayerSize;
    }

    return result;
}
```

#### DFS - é€’å½’

- å…ˆè®¿é—®å³å­æ ‘ï¼Œå†è®¿é—®å·¦å­æ ‘
- é€’å½’æ—¶å€™ï¼Œå¦‚æœå…ˆå³å†å·¦ï¼Œåˆ™å°±æ˜¯å·¦è§†å›¾

```java
private List<Integer> rightView = new ArrayList<>();

public List<Integer> rightSideView(TreeNode root) {
    dfsRecur(root, 1);
    return rightView;
}

private void dfsRecur(TreeNode root, int currentLayer) {
    if (root == null) {
        return;
    }

    if (rightView.size() < currentLayer) {
        rightView.add(root.val);
    }

    currentLayer++;
    // é¡ºåºæœ‰è®²ç©¶
    dfsRecur(root.right, currentLayer);
    dfsRecur(root.left, currentLayer);
}
```

### ğŸ˜ [513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼](https://leetcode.cn/problems/find-bottom-left-tree-value/)

- å’Œå·¦è§†å›¾ç±»ä¼¼

#### BFS

```java
public int findBottomLeftValue(TreeNode root) {
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    List<Integer> result = new ArrayList<>();
    while (!queue.isEmpty()) {
        int nextLayerSize = 0;
        result = new ArrayList<>();
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            result.add(poll.val);

            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        currentLayerSize = nextLayerSize;
    }

    return result.get(0);
}
```

#### DFS - é€’å½’

```java
private List<Integer> result = new ArrayList<>();

public int findBottomLeftValue(TreeNode root) {
    dfsRecur(root, 1);
    return result.get(result.size() - 1);
}

private void dfsRecur(TreeNode root, int currentLayer) {
    if (root == null) {
        return;
    }

    if (result.size() < currentLayer) {
        result.add(root.val);
    }

    currentLayer++;
    dfsRecur(root.left, currentLayer);
    dfsRecur(root.right, currentLayer);
}
```

#### DFS - ååº - è¿­ä»£

- æ ¹æ®ååºï¼Œä»å·¦åˆ°å³ï¼Œæ‰¾åˆ°æœ€æ·±çš„ä¸€ä¸ªè·¯å¾„ï¼Œè¿”å›è·¯å¾„æœ€åä¸€ä¸ªå…ƒç´ 

```java
public int findBottomLeftValue(TreeNode root) {
    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;
    int maxDepth = 0; // æœ€æ·±
    int result = 0;   // å€¼
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = paths.peek();
            if (peek.left == null && peek.right == null) { // åˆ°è¯¥è·¯å¾„çš„æœ€åº•å±‚äº†
                if (paths.size() > maxDepth) { // ç­‰äºçš„è¯ï¼Œç»“æœå°±ä¸æ˜¯æœ€å·¦çš„æ•°æ®
                    maxDepth = paths.size();
                    result = peek.val;
                }
            }
            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = paths.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }

    return result;
}
```

## è·¯å¾„

### âœ… [257. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](https://leetcode.cn/problems/binary-tree-paths/)

- æ ¹è·¯å¾„åˆ°å¶å­ç»“ç‚¹ï¼Œå¶å­ç»“ç‚¹å·¦å³å‡ä¸ºç©º

#### BFS-TODO

```java

```

#### DFS - ååº- æ ˆ

```java
public List<String> binaryTreePaths(TreeNode root) {
    List<String> result = new ArrayList<>();
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;

    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = stack.peek();
            // æ˜¯å¦åˆ°æ ¹ç»“ç‚¹äº†
            if (peek.left == null && peek.right == null) {
                result.add(parse(stack));
            }

            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = stack.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }

    return result;
}

private String parse(LinkedList<TreeNode> stack) {
    String[] paths = new String[stack.size()];
    for (int i = 0; i < stack.size(); i++) {
        paths[i] = String.valueOf(stack.get(stack.size() - i - 1).val);
    }
    return String.join("->", paths);
}
```

### âœ… [112. è·¯å¾„æ€»å’Œ](https://leetcode.cn/problems/path-sum/)

#### BFS-TODO

```java

```

#### DFS - é€’å½’

- é€’å½’çš„æ—¶å€™ï¼Œæ˜¯å…ˆèµ°åˆ°æœ€åº•çš„ï¼Œæ‰€ä»¥å±äºDFS

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return false;
    }

    if (root.left == null && root.right == null) {
        return root.val == targetSum;
    }

    boolean leftResult = hasPathSum(root.left, targetSum - root.val);
    boolean rightResult = hasPathSum(root.right, targetSum - root.val);
    return leftResult || rightResult;
}
```

#### DFS - ååº - æ ˆ

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;

    int sum = 0;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = stack.peek();
            if (peek.left == null && peek.right == null) {
                sum = parseSum(stack);
                if (sum == targetSum) {
                    return true;
                }
            }
            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = stack.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return false;
}

private int parseSum(LinkedList<TreeNode> stack) {
    int sum = 0;
    for (int i = 0; i < stack.size(); i++) {
        sum += stack.get(i).val;
    }
    return sum;
}
```

### ğŸ˜ [113. è·¯å¾„æ€»å’Œ II](https://leetcode.cn/problems/path-sum-ii/)

#### BFS

```java

```

#### DFS - ååº- æ ˆ

```java
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    List<List<Integer>> sums = new ArrayList<>();
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = root;

    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = stack.peek();
            // åˆ¤æ–­è·¯å¾„
            if (peek.left == null && peek.right == null) {
                List<Integer> path = parse(stack, targetSum);
                if (path != null) {
                    sums.add(path);
                }
            }
            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = stack.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return sums;
}

private List<Integer> parse(LinkedList<TreeNode> stack, int targetSum) {
    List<Integer> paths = new ArrayList<>();
    int sum = 0;
    for (int i = 0; i < stack.size(); i++) {
        paths.add(0, stack.get(i).val);
        sum += stack.get(i).val;
    }
    if (sum == targetSum) {
        return paths;
    } else {
        return null;
    }
}
```

#### DFS - å›æº¯ - TODO

```java

```

### ğŸ˜[129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

#### DFS - ååº - æ ˆ

```java
public int sumNumbers(TreeNode root) {
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;
    int sum = 0;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = stack.peek();
            if (peek.left == null && peek.right == null) {
                sum += parse(stack);
            }

            if (peek.right == null || peek.right == lastPop) {
                TreeNode pop = stack.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return sum;
}

private int parse(LinkedList<TreeNode> stack) {
    int sum = 0;

    for (int i = 0; i < stack.size(); i++) {
        sum = sum * 10 + stack.get(stack.size() - i - 1).val;
    }
    return sum;
}
```

#### DFS - é€’å½’ TODO

```java

```

#### BFS-TODO

```java

```

## åˆ¤æ–­

### âœ… [100. ç›¸åŒçš„æ ‘](https://leetcode.cn/problems/same-tree/)

#### DFS - é€’å½’

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }

    if (p == null || q == null) {
        return false;
    }


    boolean currentNodeResult = (p.val == q.val);
    boolean leftResult = isSameTree(p.left, q.left);
    boolean rightResult = isSameTree(p.right, q.right);
    return currentNodeResult && leftResult && rightResult;
}
```

#### BFS

- å°†æ ‘è¿›è¡Œç©ºç»“ç‚¹å¡«å……ï¼Œç„¶ååˆ¤æ–­é€å±‚éå†ç»“æœ
- é€å±‚å¤„ç†

![image-20240112154150527](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240112154150527.png)

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
        return leverOrder(p).equals(leverOrder(q));
    }

    public List<List<Integer>> leverOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int currentLayerSize = 1;
        while (!queue.isEmpty()) {
            int nextLayerSize = 0;
            List<Integer> layerResult = new ArrayList<>();
            Set<Integer> layerSet = new HashSet<>(); // ç”¨æ¥åˆ¤æ–­æœ€åä¸€è¡Œå…¨æ˜¯null
            for (int i = 0; i < currentLayerSize; i++) {
                TreeNode poll = queue.poll();
                if (poll != null) {
                    layerResult.add(poll.val);
                    layerSet.add(poll.val);
                    queue.offer(poll.left);
                    queue.offer(poll.right);
                } else {
                    layerResult.add(null);
                    layerSet.add(null);
                    queue.offer(null);
                    queue.offer(null);
                }
                nextLayerSize += 2;
            }
            currentLayerSize = nextLayerSize;

            if (layerSet.size() == 1 && layerSet.contains(null)) {
                break;
            } else {
                result.add(layerResult);
            }
        }
        return result;
    }
```



### âœ… [101. å¯¹ç§°äºŒå‰æ ‘](https://leetcode.cn/problems/symmetric-tree/)

#### DFS - é€’å½’

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return dfsRecur(root.left, root.right);
}

private boolean dfsRecur(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }

    if (left == null || right == null) {
        return false;
    }

    boolean currentNodeResult = left.val == right.val;
    boolean first = dfsRecur(left.left, right.right);
    boolean second = dfsRecur(left.right, right.left);
    return currentNodeResult && first && second;
}
```

#### BFS - åŒç«¯é˜Ÿåˆ—

- å¼¹å‡ºçš„ä¸¤ä¸ªå…ƒç´ å€¼æ¯”è¾ƒï¼Œå¹¶å¯¹å­ç»“ç‚¹åšç›¸åé€»è¾‘ï¼šå¤´æ’æˆ–è€…å°¾æ’
- LinkedListå¯ä»¥æ·»åŠ å¤šä¸ªnullå€¼ï¼Œå› æ­¤å¦‚æœä¸€ä¸ªç»“ç‚¹ä¸ºnullæ—¶ï¼Œå°±ç›´æ¥æ·»åŠ nullå³å¯

![image-20240112112043223](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20240112112043223.png)

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    Deque<TreeNode> deque = new LinkedList<>();
    deque.offerFirst(root.left);
    deque.offerLast(root.right);

    while (!deque.isEmpty()) {
        TreeNode first = deque.pollFirst();
        TreeNode second = deque.pollFirst();

        if (first == null && second == null) {
            continue;
        } else if (first == null || second == null) {
            return false;
        } else if (first.val != second.val) {
            return false;
        }

        // å¤„ç†å¼¹å‡ºçš„è¿ä¸ªç»“ç‚¹çš„å­©å­ç»“ç‚¹
        deque.offerFirst(first.left);
        deque.offerLast(first.right);
        deque.offerFirst(second.right);
        deque.offerLast(second.left);
    }
    return true;
}
```

### âœ… [572. å¦ä¸€æ£µæ ‘çš„å­æ ‘](https://leetcode.cn/problems/subtree-of-another-tree/)

#### BFS + åˆ¤æ–­

- BFSæ‰¾åˆ°rootä¸­ï¼Œæ‰¾åˆ°æ‰€æœ‰å’Œå­æ ‘æ ¹ç»“ç‚¹ç›¸åŒçš„ç»“ç‚¹
- ç”¨è¯¥ç»“ç‚¹å’ŒsubRootè¿›è¡Œç›¸åŒæ ‘åˆ¤æ–­

```java
public boolean isSubtree(TreeNode root, TreeNode subRoot) {
    List<TreeNode> targets = getTargetNodes(root, subRoot.val);

    if (targets.size() == 0) {
        return false;
    }

    for (int i = 0; i < targets.size(); i++) {
        if (isSub(targets.get(i), subRoot)) {
            return true;
        }
    }
    return false;
}

private List<TreeNode> getTargetNodes(TreeNode root, int targetVal) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    List<TreeNode> targets = new ArrayList<>();
    while (!queue.isEmpty()) {
        TreeNode poll = queue.poll();
        if (poll.val == targetVal) {
            targets.add(poll);
        }

        if (poll.left != null) {
            queue.offer(poll.left);
        }
        if (poll.right != null) {
            queue.offer(poll.right);
        }
    }
    return targets;
}

private boolean isSub(TreeNode target, TreeNode subRoot) {
    if (target == null && subRoot == null) {
        return true;
    }

    if (target == null || subRoot == null) {
        return false;
    }

    boolean curNodeResult = target.val == subRoot.val;
    boolean leftResult = isSub(target.left, subRoot.left);
    boolean rightResult = isSub(target.right, subRoot.right);
    return curNodeResult && leftResult && rightResult;
}
```

###  âœ… [104. æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

#### DFS - é€’å½’

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    if (root.left == null && root.right == null) {
        return 1;
    }

    int leftMax = maxDepth(root.left);
    int rightMax = maxDepth(root.right);
    return Math.max(leftMax, rightMax) + 1;
}
```

#### DFS - ååº - è¿­ä»£

- æ ˆå†…å…ƒç´ æ¯æ¬¡é€€å‡ºæ¥æ—¶å€™ï¼Œå‡å¦‚æ˜¯å¶å­èŠ‚ç‚¹ï¼Œåˆ™åˆ¤æ–­å½“å‰æ·±åº¦

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    TreeNode lastPop = null;
    int maxDepth = 0;
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
        } else {
            TreeNode peek = paths.peek();
            if (peek.right == null || peek.right == lastPop) {
                maxDepth = Math.max(maxDepth,paths.size());
                TreeNode pop = paths.pop();
                lastPop = pop;
            } else {
                cur = peek.right;
            }
        }
    }
    return maxDepth;
}
```

#### BFS

- è®°å½•æ—¶å€™ï¼Œè®°å½•å±‚

```java
public int maxDepth(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int currentLayerSize = 1;
    while (!queue.isEmpty()) {
        List<Integer> layerResult = new ArrayList<>();
        int nextLayerSize = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode poll = queue.poll();
            layerResult.add(poll.val);
            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerSize++;
            }

            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerSize++;
            }
        }
        currentLayerSize = nextLayerSize;
        result.add(layerResult);
    }
    return result.size();
}
```

### âœ… [111. æœ€å°æ·±åº¦](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

#### BFS

- å±‚åºéå†ï¼Œé‡åˆ°çš„ç¬¬ä¸€ä¸ªå¶å­ç»“ç‚¹æ‰€åœ¨çš„å±‚ï¼Œå°±æ˜¯æœ€å°æ·±åº¦

![image-20231030175543994](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231030175543994.png)

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    LinkedList<TreeNode> paths = new LinkedList<>();
    paths.offer(root);

    int currentLayerSize = 1;
    int layer = 1;
    while (!paths.isEmpty()) {
        int nextLayerSize = 0;
        for (int i = 0; i < currentLayerSize; i++) {
            TreeNode pop = paths.pop();
            if (pop.left == null && pop.right == null) {
                return layer;
            }
            if (pop.left != null) {
                paths.offer(pop.left);
                nextLayerSize++;
            }
            if (pop.right != null) {
                paths.offer(pop.right);
                nextLayerSize++;
            }
        }
        currentLayerSize = nextLayerSize;
        layer++;
    }
    return -1;
}
```

#### DFS - é€’å½’ TODO



## æ ‘æ“ä½œ

### âœ… [226. ç¿»è½¬äºŒå‰æ ‘](https://leetcode.cn/problems/invert-binary-tree/)

- æ”¹å˜æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³æŒ‡é’ˆ

```java
private void swap(TreeNode node) {
    TreeNode temp = node.left;
    node.left = node.right;
    node.right = temp;
}
```

#### DFS

##### é€’å½’

```java
public TreeNode invertTree(TreeNode root) {
    invert(root);
    return root;
}

private void invert(TreeNode root) {
    if (root == null) {
        return;
    }

    /*å…¶å®å°±æ˜¯å‰åºéå†çš„ä¸€ç§å¤„ç†é€»è¾‘*/
    swap(root);
    invert(root.left);
    invert(root.right);
}
```

##### è¿­ä»£

- éšä¾¿é€‰ä¸€ä¸ªéå†æ–¹å¼ï¼Œäº¤æ¢å…¶å·¦å³èŠ‚ç‚¹å³å¯

```java
public TreeNode invertTree(TreeNode root) {

    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) {
            stack.push(cur);
            // äº¤æ¢
            swap(cur);
            cur = cur.left;
        } else {
            TreeNode pop = stack.pop();
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }
    return root;
}
```

#### BFS

- å¯¹äºæ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéƒ½äº¤æ¢å…¶å·¦å³èŠ‚ç‚¹

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode poll = queue.poll();
        swap(poll);
        if (poll.left != null) {
            queue.offer(poll.left);
        }

        if (poll.right != null) {
            queue.offer(poll.right);
        }
    }
    return root;
}
```



# LeetCode

## ğŸ˜[617. åˆå¹¶äºŒå‰æ ‘](https://leetcode.cn/problems/merge-two-binary-trees/)

### é€’å½’

```java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) {
        return root2;
    }
    if (root2 == null) {
        return root1;
    }

    TreeNode root = new TreeNode(root1.val + root2.val);
    root.left = mergeTrees(root1.left, root2.left);
    root.right = mergeTrees(root1.right, root2.right);
    return root;
}
```



## ğŸ˜[404. å·¦å¶å­ä¹‹å’Œ](https://leetcode.cn/problems/sum-of-left-leaves/)

### BFS + è¿­ä»£

```java
public int sumOfLeftLeaves(TreeNode root) {
    int sum = 0;
    LinkedList<TreeNode> paths = new LinkedList<>();
    paths.offer(root);
    while (!paths.isEmpty()) {
        TreeNode pop = paths.pop();
        if (pop.left != null) {
            if (pop.left.left == null && pop.left.right == null) {
                sum += pop.left.val;
            }
            paths.offer(pop.left);
        }

        if (pop.right != null) {
            paths.offer(pop.right);
        }
    }

    return sum;
}
```

### DFS + è¿­ä»£

- å‰åºæˆ–è€…ä¸­åºï¼Œéƒ½æ— æ‰€è°“

```java
public int sumOfLeftLeaves(TreeNode root) {
    int sum = 0;
    LinkedList<TreeNode> paths = new LinkedList<>();
    TreeNode cur = root;
    while (cur != null || !paths.isEmpty()) {
        if (cur != null) {
            paths.push(cur);
            cur = cur.left;
            if (cur != null && cur.left == null && cur.right == null) {
                sum += cur.val;
            }
        } else {
            TreeNode pop = paths.pop();
            if (pop.right != null) {
                cur = pop.right;
            }
        }
    }

    return sum;
}
```

## æ ‘æ„å»º

### ğŸ˜¡[105. å‰åºä¸ä¸­åºæ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

- å‰åºéå†çš„ç»“æœï¼š[ æ ¹èŠ‚ç‚¹, [å·¦å­æ ‘çš„å‰åºéå†ç»“æœ], [å³å­æ ‘çš„å‰åºéå†ç»“æœ] ]
- ä¸­åºéå†çš„ç»“æœï¼š[ [å·¦å­æ ‘çš„ä¸­åºéå†ç»“æœ], æ ¹èŠ‚ç‚¹, [å³å­æ ‘çš„ä¸­åºéå†ç»“æœ] ]

#### é€’å½’  + æ•°ç»„æ‹·è´

![image-20231231102737796](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231231102737796.png)

```bash
# å‰åºï¼š [3,ï¼ˆ6,2ï¼‰,ï¼ˆ1,7,4ï¼‰]
# ä¸­åºï¼š[ï¼ˆ2,6ï¼‰,3,ï¼ˆ7,1,4ï¼‰]

# 1. æ ¹ç»“ç‚¹
- æ ¹ç»“ç‚¹ï¼š å‰åºçš„ç¬¬ä¸€ä¸ªï¼š3
- æ ¹æ®æ ¹ç»“ç‚¹ï¼Œåœ¨ä¸­åºä¸­æ‰¾ï¼Œå·¦è¾¹çš„æ˜¯å·¦å­æ ‘ï¼Œå³è¾¹çš„æ˜¯å³å­æ ‘

# 2. å‰åº[6,2]æ˜¯å·¦å­æ ‘ï¼Œ [1,7,4]æ˜¯å³å­æ ‘
```

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    /*ç»ˆæ­¢æ¡ä»¶*/
    if (preorder.length == 0) {
        return null;
    }

    if (preorder.length == 1) {
        return new TreeNode(preorder[0]);
    }

    TreeNode root = new TreeNode(preorder[0]);
    int length = preorder.length;
    /*å¾—åˆ°ä¸­åºçš„rootç»“ç‚¹çš„index*/
    int targetIndexInOrder = 0;
    for (int i = 0; i < inorder.length; i++) {
        if (root.val == inorder[i]) {
            targetIndexInOrder = i;
            break;
        }
    }

    /*ç´¢å¼•çš„å¼€å§‹å’Œç»“æŸä½ç½® [):*/

    // ä¸¤ä¸ªæ•°ç»„é•¿åº¦è¦ä¸€æ ·
    int[] leftNextInOrder = Arrays.copyOfRange(inorder, 0, targetIndexInOrder);
    int[] leftNextPreOrder = Arrays.copyOfRange(preorder, 1, targetIndexInOrder + 1); 
    root.left = buildTree(leftNextPreOrder, leftNextInOrder);

    //ä¸¤ä¸ªæ•°ç»„é•¿åº¦è¦ä¸€æ · 
    int[] rightNextInOrder = Arrays.copyOfRange(inorder, targetIndexInOrder + 1, length);
    int[] rightNextPreOrder = Arrays.copyOfRange(preorder, targetIndexInOrder + 1, length);
    root.right = buildTree(rightNextPreOrder, rightNextInOrder);
    return root;
}
```

