## ğŸ˜¡[105. å‰ä¸­æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)



## ğŸ˜¡[106. ä¸­åæ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

## ğŸ˜¡[1008. å‰åºéå†æ„é€ äºŒå‰æœç´¢æ ‘](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)

### ä¾æ¬¡put

- å°†æ•°ç»„ä¸­çš„æ•°æ®ä¾æ¬¡æ·»åŠ åˆ°äºŒå‰æœç´¢æ ‘ä¸­
- ä¸èƒ½æœ‰æ•ˆçš„åˆ©ç”¨å‰åºéå†çš„é¡ºåº

```java
public TreeNode bstFromPreorder(int[] preorder) {
    TreeNode root = null;
    for (int i = 0; i < preorder.length; i++) {
        root = put(root, preorder[i]);
    }
    return root;
}


private TreeNode put(TreeNode root, int value) {
    if (root == null) {
        return new TreeNode(value); // ç©ºæ ‘
    }

    TreeNode cur = root;
    TreeNode prev = null;
    while (cur != null) {
        if (cur.val > value) {
            prev = cur;
            cur = cur.left;
        } else if (cur.val < value) {
            prev = cur;
            cur = cur.right;
        } else {
            return root; // åŸæ¥å·²ç»å­˜åœ¨ï¼Œç›´æ¥è¿”å›
        }
    }

    /*å·¦æˆ–å³*/
    TreeNode inserted = new TreeNode(value);
    if (value < prev.val) {
        prev.left = inserted;
    } else {
        prev.right = inserted;
    }
    return root;
}
```



