# 二分查找

- 针对<font color=orange>有序数组</font>，提供的一种快速查找的搜索算法

## Target

- <font color=orange>有序不重复数组</font>A中，查找target值
- 查找到则返回索引，查找不到则返回-1

```java
/*基础版本实现*/
public int solution_01(int[] arr, int target) {
    int i = 0;
    int j = arr.length - 1;

    while (i <= j) {   // <=
        int m = (i + j) / 2;
        if (target < arr[m]) {
            j = m - 1;
        } else if (arr[m] < target) {
            i = m + 1;
        } else {
            return m;
        }
    }
    return -1;
}
```

## InsertPoint

- <font color=orange>有序不重复数组</font>A中，查找target值
- 查找到则返回索引，查找不到则返回插入的位置

```java
public int insertPoint(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int m = (left + right) / 2;
        if (target < nums[m]) {
            right = m - 1;
        } else if (nums[m] < target) {
            left = m + 1;
        } else {
            return m;
        }
    }

    return left;
}
```

## LeftMost

- 有序数组中，可能存在重复元素，查找最左边元素的索引

```java
/*返回匹配target的最左边元素的索引*/
public int solution_05(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    int candidate = -1;
    while (left <= right) {
        int m = (left + right) / 2;
        if (target < arr[m]) {
            right = m - 1;
        } else if (arr[m] < target) {
            left = m + 1;
        } else {
            // 匹配到之后，不着急返回结果，继续向左遍历
            candidate = m;
            right = m - 1;
        }
    }
    return candidate;
}
```

## RightMost

- 有序数组中，可能存在重复元素，查找最右边元素的索引

```java
/*返回匹配target的最右边边元素的索引*/
public int solution_06(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    int candidate = -1;
    while (left <= right) {
        int m = (left + right) / 2;
        if (target < arr[m]) {
            right = m - 1;
        } else if (arr[m] < target) {
            left = m + 1;
        } else {
            // 匹配到之后，不着急返回结果，继续向左遍历
            candidate = m;
            left = m + 1;
        }
    }
    return candidate;
}
```

# 链表

## 1. 单向链表

### 1. head--首元素

- 会有很多判空的处理

```java
class SingleLinkedList {

    /*head就是头元素*/
    private Node head;

    public void addFirst(int value) {
        head = new Node(value, head);
    }

    /*遍历*/
    public void loop() {
        Node pointer = head;
        while (pointer != null) {
            System.out.println(pointer.value);
            pointer = pointer.next;
        }
    }

    /*尾部*/
    public void addLast(int value) {
        Node last = findLast();
        if (last == null) {
            head = new Node(value, null);
            return;
        }

        last.next = new Node(value, null);
    }

    /*0---n*/
    public int get(int index) {
        Node node = getNode(index);
        if (node == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return node.value;
    }

    /*指定索引位置插入数据*/
    public void insert(int value, int index) {
        Node targetNode = getNode(index - 1);
        if (targetNode == null) {
            if (head == null) {
                addFirst(value);
                return;
            }
            throw new IllegalArgumentException("Illegal Index");
        }
        Node insertNode = new Node(value, null);
        Node nextNode = targetNode.next;
        targetNode.next = insertNode;
        if (nextNode == null) {
        } else {
            insertNode.next = nextNode;
        }
    }

    /*让head指针指向后面的元素*/
    public void removeFirst() {
        if (head == null) {
            return;
        }
        head = head.next;
    }

    private Node getNode(int index) {
        Node pointer = head;
        int currentIndex = -1;
        while (pointer != null) {
            currentIndex++;
            if (currentIndex == index) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }

    /*搜索最后一个*/
    public Node findLast() {
        Node pointer = head;
        if (head == null) {
            return null;
        }
        while (pointer.next != null) {
            pointer = pointer.next;
        }
        return pointer;
    }

    static class Node {
        private int value;
        private Node next;

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }
    }
}
```

### 1.2 head-dummy元素

- dummy元素充当首元素，避免了一些判空处理

## 2. 双向链表

- 带头和尾的哨兵版本的双向链表

```java
class DoublyLinkedList {
    private Node headDummy = new Node(-1000, null, null);
    private Node tailDummy = new Node(-1000, null, null);

}

class Node {
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

# 递归

- 取决于同类问题的更小子集
- 最终缩减到无需递归

```bash
# 1. 确定能否使用递归求解
# 2. 推到出递归关系，递归的结束条件
```



## 1. 阶乘

```java
public int gradFunc(int n) {
    /*递归结束条件*/
    if (n == 1) {
        return 1;
    }

    /*循环调用*/
    return n * gradFunc(n - 1);
}
```

## 2. 二分查找



# 队列

- 尾巴进数据，头部出数据

## 1. 链表实现

- 单向环形带哨兵的链表来实现队列

## 2. 环形数组

### 2.1 形式1

- 数组会有一个空的位置来存放数据
- 下标计算： （当前指针位置+前进步数）% length

```java
package com.citi.d04;

public class Demo01 {
    public static void main(String[] args) {
        /*存储4个数据*/
        ArrayQueue arrayQueue = new ArrayQueue(4);
        arrayQueue.add(3);
        arrayQueue.add(6);
        arrayQueue.add(12);
        arrayQueue.add(45);
        arrayQueue.add(56);
    }
}


/*下标计算： （当前指针位置+前进步数）% length
 * 判断空：头指针，尾指针：头尾指针相同
 * 判断满： 尾指针+1 = 头指针 */
class ArrayQueue implements Queue {

    private int[] array;
    private int head = 0;
    private int tail = 0;

    public ArrayQueue(int capacity) {
        array = new int[capacity + 1];
    }

    /*尾巴*/
    @Override
    public boolean add(int val) {
        if (isFull()) {
            return false;
        }
        array[tail] = val; // 赋值
        tail = (tail + 1) % array.length;        // 步长为1
        return true;
    }

    /*头：移除*/
    @Override
    public int get() {
        if (isEmpty()) {
            return -888;
        }
        int result = array[head];
        head = (head + 1) % array.length;
        return result;
    }

    /*头，尾重合时，表示为空*/
    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    /*空出来一个位置，来进行判断满： tail比head小1*/
    @Override
    public boolean isFull() {
        return (tail + 1) % array.length == head;
    }
}


interface Queue {

    /*向队列尾部添加*/
    boolean add(int val);

    /*从队列头部取出，并移除*/
    int get();

    boolean isEmpty();

    boolean isFull();
}
```

### 2.2 形式2

- 新增一个变量，来判断队列是空还是满

```java
class ArrayQueueSecond implements Queue {

    private int head;
    private int tail;

    private int[] arr;

    private int size;

    public ArrayQueueSecond(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean add(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        size++;
        return true;
    }

    @Override
    public int get() {
        if (isEmpty()) {
            return -988;
        }
        int result = arr[head];
        head = (head + 1) % arr.length;
        size--;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}
```

### 2.3 形式3

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算

```java
class ArrayQueueThird implements Queue {

    private int head = 0;
    private int tail = 0;

    private int[] arr;

    public ArrayQueueThird(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean add(int val) {
        if (isFull()) {
            return false;
        }
        int index = tail % arr.length;
        arr[index] = val;
        tail++;
        return true;
    }

    @Override
    public int get() {
        if (isFull()) {
            return -999;
        }
        int index = head % arr.length; // 具体的index，在需要用到的时候再进行计算
        int result = arr[index];
        head++;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        return (tail - head) == arr.length;
    }
}
```

### 2.4 二叉树-层序遍历

- 二叉树：一个树中，每个结点最多有两个元素
- 从上到小，一层一层遍历

# 栈

- 先进后出

## 1. 数组实现

```java
package com.citi.d04;

public class Demo02 {
    public static void main(String[] args) {
        Stack stack = new ArrayStack(4);
        stack.push(4);
        stack.push(5);
        stack.push(6);
        stack.push(6);
        stack.push(9);
    }
}

/*
 *  底          顶
 *  0   1   2   3
 *  a   b   c   d
 *
 *  top一开始为0，表示为空
 *  top增长到4(数组长度)，表示为满
 * */
class ArrayStack implements Stack {

    private int[] array;

    /*栈顶指针*/
    private int top = 0;

    public ArrayStack(int capacity){
        array = new int[capacity];
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        array[top] = val;
        top++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            return -9899;
        }
        top--;
        return array[top];
    }

    @Override
    public boolean isEmpty() {
        return top == 0;
    }

    @Override
    public boolean isFull() {
        return top == array.length;
    }
}

interface Stack {

    /*加数据*/
    boolean push(int val);

    /*弹出数据*/
    int pop();

    boolean isEmpty();

    boolean isFull();
}
```

## 3 leetcode

### 3.1 有效的括号

- 实现方法：用java自己的LinkedList类

```bash
1. 遇见左括号，则在栈中添加右括号
2. 遇见右括号，如果和栈顶元素相同，则弹出(空元素)；    如果不同，则直接返回错误结果
3. 最后栈的长度要为空
```

### 3.2 比较含退格的元素

### 3.3 逆波兰表达式

#### 后缀表达式求值

- 运算符号在数字的后面，这样就不用考虑优先级问题

```bash
# 1. 碰见符号就把前面两个数字弹出栈
# 2. 运算完成后重新入栈
```

![image-20231001112853595](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231001112853595.png)

### 3.4 两个栈模拟一个队列

### 3.5 单队列模拟一个栈

```bash
# 1. 反转队列: 队列中添加元素时候，先判断是否为空
- 为空，则直接添加
- 不会空，先添加元素，然后把其他的元素先从出队列，再重新进
```

# 双端队列

- 两端都可以删除，添加
- Deque: Double End Queue, 双端队列

## 1. 数组实现

### 1.1 形式1

- 数组会有一个空的位置来存放数据
- 下标计算： （当前指针位置+前进步数）% length

# 优先级队列



# 二叉树

- 根结点
- 每个结点，最多有两个叶子结点
- 满二叉树：每个结点都有两个叶子结点

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return String.valueOf(val);
    }
}
```

## 1. 深度优先-递归

```bash
# 前序遍历：  中左右
- 1， 2， 4， 7，8， 3， 5， 9， a， 6， b

# 中序遍历：  左中右
- 7， 4， 8， 2， 1， 9， 5， a, 3, 6, b

# 后序遍历：  左右中
- 7, 8, 4, 2, 9, a, 5, b, 6, 3
```

![image-20231001161115309](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231001161115309.png)

```java
class Solution {

  static TreeNode root = new TreeNode(1,
          new TreeNode(2, new TreeNode(4), null),
          new TreeNode(3, new TreeNode(5), new TreeNode(6)));


  /*前序遍历： 中左右*/
  public void preOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      System.out.println(root.val);
      preOrder(root.left);
      preOrder(root.right);
  }

  /*中序遍历: 左中右*/
  public void inOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      inOrder(root.left);
      System.out.println(root.val);
      inOrder(root.right);
  }

  /*后序遍历： 左右中*/
  public void postOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      postOrder(root.left);
      postOrder(root.right);
      System.out.println(root.val);
  }
}
```

```java
class Solution {

    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), null),
            new TreeNode(3, new TreeNode(5), new TreeNode(6)));

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        preOrder(root, result);
        return result;
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        inOrder(root, result);
        return result;
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postOrder(root, result);
        return result;
    }


    /*前序遍历： 中左右*/
    public void preOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        result.add(root.val);
        preOrder(root.left, result);
        preOrder(root.right, result);
    }

    /*中序遍历: 左中右*/
    public void inOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        inOrder(root.left, result);
        result.add(root.val);
        inOrder(root.right, result);
    }

    /*后序遍历： 左右中*/
    public void postOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        postOrder(root.left, result);
        postOrder(root.right, result);
        result.add(root.val);
    }
}
```

## 2. 深度优先-栈

```java
class StackSolution {
    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), null),
            new TreeNode(3, new TreeNode(5), new TreeNode(6)));


    /*前，中序遍历*/
    public void preorderTraversal(TreeNode root) {
        List<Integer> preResult = new ArrayList<>();  //  前序遍历：中左右 去时记录
        List<Integer> inResult = new ArrayList<>();   // 中序遍历：左中右 回时遍历

        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                preResult.add(cur.val); // 前序遍历
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode pop = path.pop();
                inResult.add(pop.val); // 中序遍历
                cur = pop.right;
            }
        }
    }

    /*后序遍历: 左右中*/
    public void postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        TreeNode recentPop = null;

        while (cur != null || !path.isEmpty()) {
            if (cur != null) {           // 左子树已经处理完了
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode peek = path.peek();
                if (peek.right == null || peek.right == recentPop) { // 右子树处理完了
                    recentPop = path.pop();
                    result.add(recentPop.val);
                } else { // 右子树不为null
                    cur = peek.right;
                }
            }
        }
    }
}
```

```java
class StackSolution {
    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), new TreeNode(5)),
            new TreeNode(3, new TreeNode(6), new TreeNode(7)));


    /*后序遍历: 左右中*/
    public void postorderTraversal(TreeNode root) {
        List<Integer> pre = new ArrayList<>();     // 前序遍历：中左右 去时记录
        List<Integer> in = new ArrayList<>();      // 中序遍历：左中右 回时遍历
        List<Integer> post = new ArrayList<>();    // 后序遍历：左中右 回时遍历
        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        TreeNode pop = null;

        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                path.push(cur);
                // 待处理左子树
                pre.add(cur.val);
                cur = cur.left;
            } else {
                TreeNode peek = path.peek();

                if (peek.right == null) {   // 没有右子树
                    in.add(peek.val);
                    pop = path.pop();
                    post.add(pop.val);
                } else if (peek.right == pop) {   // 右子树处理完成
                    pop = path.pop();
                    post.add(pop.val);
                } else { // 待处理右子树
                    in.add(peek.val);
                    cur = peek.right;
                }
            }
        }
    }
}
```

## 3. leetcode

### 3.1 判断对称二叉树

```bash
# 思路： 判断左右两个结点是否一样
```

```java
public boolean checkSymmetricTree(TreeNode root) {
        if (root==null){
            return true;
        }
        return check(root.left, root.right);
    }

    public boolean check(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }

        if (left == null || right == null) {
            return false;
        }

        if (left.val != right.val) {
            return false;
        }

        return check(left.left, right.right) && check(left.right, right.left);
    }
```

### 3.2 二叉树最大深度

