# 动态数组

```java
class DynamicArray {
    int capacity; // 数组最大长度
    int size;         // 当前数组非空元素的个数
    int[] arr = {};

    public DynamicArray(int capacity) {
        this.capacity = capacity;
    }

    public void addLast(int val) {
        add(size, val);
    }

    public void add(int index, int val) {
        checkAndExpand();
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("Illegal Index");
        }

        if (index < size) { // 指定位置添加
            System.arraycopy(arr, index, arr, index + 1, size - index);
        }
        arr[index] = val;           // addLast添加
        size++;
    }

    public int get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return arr[index];
    }


    public void loop(Consumer<Integer> consumer) {
        for (int i = 0; i < size; i++) {
            consumer.accept(arr[i]);
        }
    }

    public int remove(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("Illegal Index");
        }
        int removed = arr[index];
        // 数组间,数组内，拷贝, 删除后的数据，只是无法访问了，但是最后一个元素，其实不是0值
        System.arraycopy(arr, index + 1, arr, index, size - index - 1);
        size--;
        return removed;
    }
    
    private void checkAndExpand() {
        if (size == 0) {                   //  首次扩容
            arr = new int[capacity];
        } else if (size == capacity) {     //  后续扩容
            capacity += capacity / 2;
            int[] newArray = new int[capacity];
            System.arraycopy(arr, 0, newArray, 0, size); // 数组拷贝
            arr = newArray;
        }
    }
}
```

## 1. LeetCode

### 1.1 有序数组合并

- 不允许使用额外的数组空间

```bash
# 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
# 输出：[1,2,2,3,5,6]
```

```bash
# 逆序从大到小
# 谁大就放在数组1的最右边
```

![image-20231009162403078](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231009162403078.png)

```java
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m - 1;
        int index2 = n - 1;
        int index = nums1.length - 1;
        while (index1 >= 0 && index2 >= 0) {
            int v1 = nums1[index1];
            int v2 = nums2[index2];
            if (v1 > v2) {
                nums1[index] = v1;
                index1--;
            } else {
                nums1[index] = v2;
                index2--;
            }
            index--;
        }

        /*处理剩下的*/
        for (int i = 0; i < index + 1; i++) {
            nums1[i] = index1 < 0 ? nums2[i] : nums1[i];
        }
    }
```



# 链表

## 1. 单向链表

```java
class Node{
    int val;
    Node next;

    public Node(int val, Node next) {
        this.val = val;
        this.next = next;
    }
}
```

```java
interface SingleListInter {
    void addFirst(int val);

    void loop(Consumer<Integer> consumer);

    void addLast(int val);

    int get(int index);

    void removeFirst();

    void remove(int index);

    void insert(int index, int val);
}
```

### 1.1 无哨兵

- head永远指向头元素，不要变动
- 会有很多判空的处理

![image-20231004155002630](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004155002630.png)

```java
class SingledList implements SingleListInter {
    Node head;

    @Override
    public void addFirst(int val) {
        head = new Node(val, head); // head为空/不空简化后的代码
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        Node pointer = head;  // 移动pointer而不是head
        while (pointer != null) {
            consumer.accept(pointer.val);
            pointer = pointer.next;
        }
    }

    @Override
    public void addLast(int val) {
        Node last = findLast();
        if (last == null) {
            addFirst(val);
        } else {
            last.next = new Node(val, null);
        }
    }

    @Override
    public int get(int index) {
        Node node = getNode(index);
        if (node == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return node.val;
    }

    @Override
    public void removeFirst() {
        if (head == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        head = head.next; // 前面一个元素，自动被垃圾回收掉
    }

    @Override
    public void remove(int index) {
        if (index == 0) {
            removeFirst();
        }
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node removed = prev.next;
        if (removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = removed.next;
    }

    @Override
    public void insert(int index, int val) {
        if (index == 0) {
            addFirst(val);
            return;
        }

        Node prev = getNode(index - 1); // 找前一个节点
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        prev.next = new Node(val, prev.next);
    }


    private Node findLast() {
        if (head == null) {
            return null;
        }
        Node pointer = head;
        while (pointer.next != null) {
            pointer = pointer.next;
        }
        return pointer;
    }

    private Node getNode(int index) {
        Node pointer = head;
        int currentIndex = -1;
        while (pointer != null) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

### 1.2 带哨兵

- dummy元素充当首元素，避免了一些判空处理

![image-20231004182312899](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004182312899.png)

```java

class SingledDummyList implements SingleListInter {
    Node dummy = new Node(Integer.MIN_VALUE, null);
    Node head = dummy;

    @Override
    public void addFirst(int val) {
        head.next = new Node(val, head.next);
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        Node pointer = head.next;
        while (pointer != null) {
            consumer.accept(pointer.val);
            pointer = pointer.next;
        }
    }

    @Override
    public void addLast(int val) {
        Node last = findLast();
        last.next = new Node(val, null);
    }

    @Override
    public int get(int index) {
        Node node = getNode(index);
        if (node == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return node.val;
    }

    @Override
    public void removeFirst() {
        if (dummy.next == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        dummy.next = dummy.next.next;
    }

    @Override
    public void remove(int index) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node removed = prev.next;
        if (removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = removed.next;
    }

    @Override
    public void insert(int index, int val) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = new Node(val, prev.next);
    }

    private Node findLast() {
        Node pointer = head;
        while (pointer.next != null) {
            pointer = pointer.next;
        }
        return pointer;
    }

    private Node getNode(int index) {
        Node pointer = head;
        int currentIndex = -2;
        while (pointer != null) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

## 2. 双向链表

- 带头哨兵和尾哨兵的双向链表

![image-20231004191925877](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004191925877.png)

```java
class Node {
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

```java
/*主要好处：可以逆序遍历，快速找到最后的结点*/
class DoublyLinkedList {
    Node head;
    Node tail;

    public DoublyLinkedList() {
        head = new Node(Integer.MIN_VALUE, null, null);
        tail = new Node(Integer.MIN_VALUE, null, null);
        head.next = tail;
        tail.prev = head;
    }

    public void addFirst(int val) {
        insert(0, val);
    }

    public void insert(int index, int val) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = prev.next;

        /*新节点*/
        Node inserted = new Node(val, prev, next);
        prev.next = inserted;
        next.prev = inserted;
    }

    public void remove(int index) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        Node removed = prev.next;
        if (removed == tail) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    public void addLast(int val) {
        Node prev = tail.prev;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;

        inserted.next = tail;
        tail.prev = inserted;
    }

    public void removeLast() {
        Node removed = tail.prev;
        if (removed == head) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = removed.prev;
        prev.next = tail;
        tail.prev = prev;
    }

    private Node getNode(int index) {
        int currentIndex = -2; // head节点的索引是-1
        Node pointer = head;
        while (pointer != tail) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

## 3. 双向环形链表

- 只有一个头哨兵

![image-20231005150947772](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231005150947772.png)

```java
class Node{
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

```java
class CrossDoublyLinkedList {
    Node sentinel;

    /*一开始的时候，哨兵结点的prev和next都指向本身自己*/
    public CrossDoublyLinkedList() {
        sentinel = new Node(Integer.MIN_VALUE, null, null);
        sentinel.prev = sentinel;
        sentinel.next = sentinel;
    }

    public void addFirst(int val) {
        Node prev = sentinel;
        Node next = sentinel.next;
        Node inserted = new Node(val, null, null);
        prev.next = inserted;
        inserted.prev = prev;
        inserted.next = next;
        next.prev = inserted;
    }

    public void addLast(int val) {
        Node last = sentinel.prev;
        Node inserted = new Node(val, null, null);

        inserted.next = sentinel;
        sentinel.prev = inserted;
        last.next = inserted;
        inserted.prev = last;
    }

    public void removeFirst() {
        Node removed = sentinel.next;
        if (removed == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node next = removed.next;
        sentinel.next = next;
        next.prev = sentinel;
    }

    public void removeLast() {
        Node last = sentinel.prev;
        if (last == sentinel) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node prev = last.prev;
        prev.next = sentinel;
        sentinel.prev = prev;
    }

    public void removeByVal(int val) {
        Node removed = findByVal(val);
        if (removed == null) {
            throw new IllegalArgumentException("No Target Found");
        }

        Node prev = removed.prev;
        Node next = removed.next;
        prev.next = next;
        next.prev = prev;
    }

    private Node findByVal(int val) {
        Node pointer = sentinel.next;
        while (pointer != sentinel) {
            if (val == pointer.val) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }

}
```

## 4. LeetCode

- 默认每个题目中都是给一个head，可以在方法里面添加哨兵

### 4.1 反转链表

#### 新链表

```bash
# 构造一个新的链表，
# 1. 从旧链表依次拿到每个结点的值
# 2. 创建一个新的节点添加到新链表头部
```

```java
public ListNode reverseList(ListNode head) {
    ListNode newHead = null;
    ListNode pointer = head;
    while (pointer != null) {
        newHead = new ListNode(pointer.val, newHead);
        pointer = pointer.next;
    }
    return newHead;
}
```

#### 新链表

```bash
# 1. 从旧链表移除头部节点，添加到新链表头部
# 2. 不用去构建新的结点     removeFirst + addFirst

#  1，2，3，4，5 ---》   5，4，3，2，1
```

```java
public ListNode reverseList(ListNode head) {
    ListNode newHead = null;
    while (head != null) {
        ListNode first = head;  // 拿到旧链表的第一个结点
        head = head.next;

        first.next = newHead;
        newHead = first;
    }
    return newHead;
}
```

####  递归

- 遍历，改变指针指向

```java
public ListNode reverseList(ListNode head) {
    ListNode current = head;
    ListNode prev = null;
    while (current != null) {
        ListNode remain = current.next;

        current.next = prev;
        prev = current;

        current = remain;
    }
    return prev;
}
```

### 4.2 删除节点

#### ByValue

```bash
# 输入: head = [4,5,1,9], val = 5            输出: [4,1,9]
# 输入: head = [4,5,1,9], val = 1            输出: [4,5,9]
# 可能重复值

# 思路
- 前置结点和当前结点
```

```java
public ListNode deleteNode(ListNode head, int val) {
    // 添加一个头结点，后续省略很多判空处理，后续都用sentinel来处理
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head); 
    ListNode prev = sentinel;
    ListNode current = prev.next;
    while (current != null) {
        if (current.val == val) {
            prev.next = current.next;
        } else {
            prev = prev.next;
        }
        current = current.next;
    }
    return sentinel.next;
}
```

#### 倒数第N个

```bash
# 输入：head = [1,2,3,4,5], n = 2
# 输出：[1,2,3,5]
```

##### 正序遍历

```bash
# 一共需要遍历三次
- 1. 第一次遍历，得到链表总长length
- 2. 被删除索引 index = length-num
- 3. 删除指定索引的元素, sentinel的索引是-1
```

```java
 public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
        // 得到总size
        int length = getLength(sentinel);
        // 得到目标索引
        int targetIndex = length - n;
        // 前一个元素
        ListNode prev = getNode(sentinel, targetIndex - 1);
        // 后一个元素
        ListNode removed = getNode(sentinel, targetIndex);
        if (prev == null || removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        prev.next = removed.next;
        return sentinel.next;
    }

    private int getLength(ListNode sentinel) {
        ListNode pointer = sentinel.next;
        int length = 0;
        while (pointer != null) {
            length++;
            pointer = pointer.next;
        }
        return length;
    }

    private ListNode getNode(ListNode sentinel, int targetIndex) {
        int index = -2;
        ListNode pointer = sentinel;
        while (pointer != null) {
            index++;
            if (targetIndex == index) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
```

##### 快慢指针

![image-20231008115435110](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231008115435110.png)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode fast = sentinel;
    ListNode slow = sentinel;
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }

    while (fast.next != null) {
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;
    return sentinel.next;
}
```

#### 有序去重

- 重复元素保留一个

##### pre+current

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode pre = sentinel;
    ListNode current = sentinel.next;
    while (current != null) {
        if (pre.val == current.val) {
            pre.next = current.next;
        } else {
            pre = pre.next;
        }
        current = current.next;
    }
    return sentinel.next;
}
```

#### 有序去重

- 重复元素删除

##### p1+p2+p3

![image-20231009110239365](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231009110239365.png)

```java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
    ListNode p1 = sentinel;
    ListNode p2 = p1.next;
    ListNode p3 = p2.next;

    while (p3 != null) {
        if (p3.val != p2.val) {
            p1 = p2;
            p2 = p3;
            p3 = p3.next;
        } else {
            while (p3 != null && p3.val == p2.val) {
                p3 = p3.next;
            }
            p1.next = p3;
            p2 = p3;
            if (p3 != null) {
                p3 = p3.next;
            }
        }
    }
    return sentinel.next;
}
```

### 4.3 合并链表

#### 两个有序链表

##### 新链表

- 比较两个链表，谁小就把谁的值给新链表，新链表指针和小的链表指针后移

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode sentinel = new ListNode(Integer.MIN_VALUE, null);
    ListNode p = sentinel;
    ListNode p1 = list1;
    ListNode p2 = list2;

    while (p1 != null && p2 != null) {
        int v1 = p1.val;
        int v2 = p2.val;
        if (v1 > v2) {
            p.next = new ListNode(v2, null);
            p2 = p2.next;
        } else {
            p.next = new ListNode(v1, null);
            p1 = p1.next;
        }
        p = p.next;
    }

    p.next = p1 == null ? p2 : p1;
    return sentinel.next;
}
```

### 4.4 中间结点

```bash
# 输入：head = [1,2,3,4,5]，   输出：[3,4,5]
# 输入：head = [1,2,3,4,5,6]   输出：[4,5,6]
```

#### 两次遍历

```bash
# 思路：
- 1. 遍历一次，得到链表长度，得到中间索引
- 2. 第二次遍历，根据索引获取到指定索引位置
```

#### 快慢指针

- 慢指针每次移动一个，快指针每次移动2个
- 快指针指向null时，慢指针的当前位置

![image-20231009154523418](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231009154523418.png)

```java
    public ListNode middleNode(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode sentinel = new ListNode(Integer.MIN_VALUE, head);
        ListNode fast = sentinel;
        ListNode slow = sentinel;
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
            if (fast != null){
                fast = fast.next;
            }
        }
        return slow;
    }
```

# 队列

- 尾进数据，头出数据

## 1. 普通队列

![image-20231013105008033](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231013105008033.png)

```java
interface MyQueue {

    /*尾插*/
    boolean offer(int val);

    /*头弹，队列为空，队列为空，返回null*/
    int poll();

    /*获取头元素，不弹出来，队列为空，返回null*/
    int peek();

    boolean isEmpty();

    boolean isFull();
}
```

### 1.1 链表实现

- 单向环形带哨兵的链表来实现队列

![image-20231013104421976](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231013104421976.png)

```java
class LinkedListQueue implements MyQueue {

    static class Node {
        int val;
        Node next;

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    Node head;  // head会移动

    Node tail;  // tail会移动

    Node sentinel;

    int capacity = 10; // 最大容量

    int currentSize = 0; // 结点数量

    public LinkedListQueue(int capacity) {
        this.capacity = capacity;
        sentinel = new Node(Integer.MIN_VALUE, null);
        sentinel.next = sentinel;
        head = sentinel; // head永远指向哨兵节点
        tail = sentinel;
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }

        Node inserted = new Node(val, null);
        inserted.next = sentinel; // 新结点下一个指向sentinel
        tail.next = inserted;     // 上一个元素指向当前插入的
        tail = inserted;          // tail重新指向新的尾元素
        currentSize++;
        return true;
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }

        Node first = head.next;
        sentinel.next = first.next;
        if (first == tail) { // 尾指针重新指向
            tail = head;
        }
        currentSize--;
        return first.val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return head.next.val;
    }

    @Override
    public boolean isEmpty() {
        return head == tail; // head永远指向sentinel
    }

    @Override
    public boolean isFull() {
        return currentSize >= capacity;
    }
}
```

### 1.2 环形数组

- 相比普通数组，起点和终点更加自由，不用考虑数据移动
- 环形数组，就是在数组长度固定的情况下，定义一定的可用索引范围，通过覆盖写来进行
- 数组性能更佳

####  空位置

- 空位置是移动的，是head后面的一个元素
- 浪费了一个索引位置来进行判满

![image-20231014110027770](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110027770.png)

```java
class ArrayQueueFirst implements MyQueue {
    int[] arr;
    int capacity;
    /*index*/
    int head = 0;
    int tail = 0;

    public ArrayQueueFirst(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity + 1];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = Integer.MIN_VALUE; // 可以不用，就是覆盖写
        head = (head + 1) % arr.length;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        int nextIndex = (tail + 1) % arr.length;
        return nextIndex == head;
    }
}
```

#### 新增size

- 新增一个size变量，来判断队列是空还是满

![image-20231014110115755](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110115755.png)

```java
class ArrayQueueSecond implements MyQueue {
    private int head;
    private int tail;
    private int size;
    private int capacity;
    private int[] arr;

    public ArrayQueueSecond(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }

        arr[tail] = val;
        tail = (tail + 1) % capacity;
        size++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = Integer.MIN_VALUE;
        head = (head + 1) % capacity;
        size--;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size >= capacity;
    }
}
```

#### head/tail自增

![image-20231014110521963](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014110521963.png)

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算

```java
class ArrayQueueThird implements MyQueue {
    private int capacity;
    private int[] arr;
    private int head = 0;
    private int tail = 0;

    public ArrayQueueThird(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int val) {
        if (isFull()) {
            return false;
        }
        arr[(tail + 1) % capacity] = val;
        tail++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head % capacity];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head % capacity];
        head++;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        return head - tail >= capacity;
    }
}
```

## 2. 双端队列

- 两端都可以进行删除，添加
- Deque: Double Ended Queue

```java
interface Deque {
    boolean offerFirst(int val);

    boolean offerLast(int val);

    int pollFirst();

    int pollLast();

    int peekFirst();

    int peekLast();

    boolean isEmpty();

    boolean isFull();
}
```

### 2.1 链表实现-双向环形链表

![image-20231019172058116](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231019172058116.png)

```java
class LinkedListDeque implements Deque {

    static class Node {
        int val;
        Node next;
        Node prev;

        public Node(int val, Node prev, Node next) {
            this.val = val;
            this.prev = prev;
            this.next = next;
        }
    }

    private int size;     // 当前队列的大小
    private int capacity;  //容量

    private Node sentinel = new Node(Integer.MAX_VALUE, null, null);

    public LinkedListDeque(int capacity) {
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
        this.capacity = capacity;
    }

    /*head和tail自己定义*/
    @Override
    public boolean offerFirst(int val) {
        if (isFull()) {
            return false;
        }
        Node inserted = new Node(val, null, null);
        Node next = sentinel.next; // 下一个元素
        sentinel.next = inserted;
        inserted.prev = sentinel;
        inserted.next = next;
        next.prev = inserted;
        size++;
        return true;
    }

    @Override
    public boolean offerLast(int val) {
        if (isFull()) {
            return false;
        }
        Node prev = sentinel.prev;
        Node inserted = new Node(val, null, null);
        inserted.next = sentinel;
        sentinel.prev = inserted;
        prev.next = inserted;
        inserted.prev = prev;
        size++;
        return true;
    }

    @Override
    public int pollFirst() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        Node pollElement = sentinel.next;
        Node next = pollElement.next;
        sentinel.next = next;
        next.prev = sentinel;
        size--;
        return pollElement.val;
    }

    @Override
    public int pollLast() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        Node pollElement = sentinel.prev;
        Node prev = pollElement.prev;
        prev.next = sentinel;
        sentinel.prev = prev;
        size--;
        return pollElement.val;
    }

    @Override
    public int peekFirst() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.next.val;
    }

    @Override
    public int peekLast() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.prev.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

### 2.2 环形数组

- 实现思路和上面的普通队列的基本相同

## 3. 优先级队列

- 数组的对象多了一个优先级的属性

```java
class Entry {
    int val;
    int priority;
}
```

### 3.1 无序数组实现

![image-20231020120223645](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231020120223645.png)

```java
class PriorityQueue {
    private Entry[] arr;
    private int capacity;
    private int size;

    public PriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        arr[size] = entry;
        size++;
        return true;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        int index = selectMaxIndex();
        Entry result = arr[index];
        remove(index);
        return result;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        int index = selectMaxIndex();
        return arr[index];
    }

    private int selectMaxIndex() {
        int maxP = 0;
        for (int i = 1; i < size; i++) {
            if (arr[i].priority > arr[maxP].priority) {
                maxP = i;
            }
        }
        return maxP;
    }

    private void remove(int index) {
        if (index == size - 1) {
            arr[index] = null;
        } else { // 进行复制拷贝
            System.arraycopy(arr, index + 1, arr, index, size - 1 + index);
            arr[size - 1] = null;
        }
        size--;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```

### 3.2 有序数组实现

- 插入时候进行插入排序，弹出时，只需要弹出数尾部的元素

![image-20231022103506620](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231022103506620.png)

```java
class SortedArrayPriorityQueue {
    private Entry[] arr;

    private int capacity;
    private int size;

    public SortedArrayPriorityQueue(int capacity) {
        this.capacity = capacity;
        arr = new Entry[capacity];
    }

    public boolean offer(Entry entry) {
        if (isFull()) {
            return false;
        }
        insert(entry);
        return true;
    }

    /*插入排序*/
    private void insert(Entry entry) {
        int p = size - 1;
        while (p > 0 && arr[p].priority > entry.priority) {
            arr[p + 1] = arr[p];
            p--;
        }
        arr[p + 1] = entry;
    }


    public Entry poll() {
        if (isEmpty()) {
            return null;
        }
        Entry entry = arr[size - 1];
        arr[size - 1] = null;
        return entry;
    }

    public Entry peek() {
        if (isEmpty()) {
            return null;
        }
        return arr[size - 1];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}
```



```java

```

```java
class ArrayQueue implements Queue {

    private int capacity;
    private int size;

    private int[] arr;

    private int tail;

    private int head;

    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean offer(int data) {
        if (isFull()) {
            return false;
        }
        arr[tail] = data;
        tail = (tail + 1) % capacity;
        size++;
        return true;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[head];
    }

    @Override
    public int poll() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int result = arr[head];
        arr[head] = 888;
        size--;
        head = (head + 1) % capacity;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == capacity;
    }
}
```

# 堆

- 一种基于树的数据结构，通常使用完全二叉树来实现
- 可以用完全二叉树来实现，可以用数组来进行存储

## 1. 大顶堆/小顶堆

```bash
# 大顶堆： 任意节点都小于其父节点
# 小顶堆： 任意节点都大与其父节点
- 左节点和右节点关系不定

# 索引原则：索引0开始存储，i表示索引
- 节点i的父节点：       floor((i-1)/2)      当i大于0时
- 节点i的左子节点为：    2i+1                结果不能大于size
- 节点i的右子节点为：    2i+2                结果不能大于size
```

![image-20231023190718489](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023190718489.png)

## 2. MaxHeap

### 2.1 heapify(下潜)

```bash
# heapfiy(弗洛伊德算法):  对既有数组进行重排
- 找到最后一个非叶子节点
- 从后向前，对每个节点执行下潜（比较左右值）

# 非叶子节点
- 没有任何一个左孩子或者右孩子
- 最后一个元素的父节点

# 下潜： 比左右孩子最大的小
- 比较当前节点的值和左右孩子的值
- 如果当前节点的值比左右孩子最大的小，则交换
```

![image-20231023152506251](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023152506251.png)

### 2.2 poll

```bash
# poll(int index)： 删除指定索引处的元素
- 堆指定索引处的元素和最后一个元素交换
- 删除最后一个元素
- 对索引处的元素进行下潜
```

### 2.3 offer(上浮)

```bash
# 威廉姆斯算法
- 入堆新元素，加入到数组末尾
- 不断比较新加元素与其父节点的值
    - 父节点更小，则父节点向下移动，继续向上找parent
    - 直到父节点值更大
```

![image-20231023172249031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231023172249031.png)

```java
class MaxHeap {
    int[] arr;
    int size;

    public MaxHeap(int[] arr) {
        this.arr = arr;
        this.size = arr.length;
        this.heapify();
    }

    private void heapify() {
        int lastIndex = size / 2 - 1; // 最后一个非叶子结点
        for (int i = lastIndex; i >= 0; i--) {
            down(i);
        }
    }

    /*对索引处元素做下潜*/
    private void down(int parent) {
        int left = parent * 2 + 1;
        int right = parent * 2 + 2;
        int max = parent;
        if (left < size && arr[left] > arr[max]) {
            max = left;
        }
        if (right < size && arr[right] > arr[max]) {
            max = right;
        }
        if (max != parent) {// 找到了更大的孩子
            swap(parent, max); // 交换
            down(max);//递归
        }
    }

    private void swap(int first, int second) {
        int temp = arr[first];
        arr[first] = arr[second];
        arr[second] = temp;
    }

    /*删除指定索引的元素,可以是头部元素*/
    public int poll(int index) {
        int deleted = arr[index];
        swap(index, size - 1);
        size--;
        down(index);
        return deleted;
    }

    public boolean offer(int val) {
        if (size == arr.length) {
            return false;
        }

        int childIndex = size;
        int parentIndex = (childIndex - 1) / 2;
        while (arr[parentIndex] < val && childIndex > 0) {
            arr[childIndex] = arr[parentIndex];
            childIndex = parentIndex;
            parentIndex = (childIndex - 1) / 2;
        }
        arr[childIndex] = val;

        size++;
        return true;
    }
}
```

## 3. LeetCode

### 3.1 数组中的第K个最大元素 - 215

```bash
# 给定整数数组 nums 和整数 k，返回数组中第k个最大的元素

# 小顶堆(堆底元素就是第k大的)
# 方法类似大顶堆
- 1. 将前k个元素加入到数组中，并heapify成小顶堆
- 2. 后续数组元素依次入和堆顶元素比较
    - 2.1 如果比堆顶大，则替换堆顶元素，并下潜
    - 2.2 如果比堆顶小或等，则什么也不做
- 3. 返回堆顶元素 
```

![image-20231026112424150](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231026112424150.png)

### 3.2 数据流中的第K大元素

```bash
# 给定整数数组 nums 和整数 k，返回数组中第k个最大的元素
# 可以给数组不断添加新的元素，依然返回第K个最大的元素
#  数组初始可能为null
```



# 栈

- 只能从数据结构的两端进行操作，先进后出

![image-20231016113311031](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016113311031.png)

```java
interface Stack {
    /*加数据*/
    boolean push(int val);
    /*弹出数据*/
    int pop();
    /*不弹出数据*/
    int peek();
    boolean isEmpty();
    boolean isFull();
}
```

## 1. 实现方式

### 1.1 链表实现

![image-20231016115640568](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231016115640568.png)

```java
class LinkedListStack implements Stack {

    private int capacity;

    private int size;

    private Node sentinel = new Node(Integer.MIN_VALUE, null);

    public LinkedListStack(int capacity) {
        this.capacity = capacity;
    }

    static class Node {
        int val;
        Node next;

        public Node(int val, Node next) {
            this.val = val;
            this.next = next;
        }
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        sentinel.next = new Node(val, sentinel.next);
        size++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        int val = sentinel.next.val;
        sentinel.next = sentinel.next.next;
        size--;
        return val;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return sentinel.next.val;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size >= capacity;
    }
}
```

### 1.2 数组实现

```java
/*
 *  底          顶
 *  0   1   2   3
 *  a   b   c   d
 *
 *  top一开始为0，表示为空
 *  top增长到4(数组长度)，表示为满
 * */
class ArrayStack implements Stack {

    private int capacity;

    private int[] arr;

    private int top;

    public ArrayStack(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        arr[top] = val;
        top++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        top--;
        int result = arr[top];
        arr[top] = Integer.MAX_VALUE;
        return result;
    }

    @Override
    public int peek() {
        if (isEmpty()) {
            return Integer.MIN_VALUE;
        }
        return arr[top - 1];
    }

    @Override
    public boolean isEmpty() {
        return top == 0;
    }

    @Override
    public boolean isFull() {
        return top == capacity;
    }
}
```

### 1.3 JDK实现

- LinkedList

## 2. leetcode

### 2.1 有效的括号-20

```bash
# 输入： ()[]{}     输出：true
# 输入： {[}        输出：false
0. 长度为奇数，直接返回错误
1. 遇见左括号，则在栈中添加右括号
2. 遇见右括号，如果和栈顶元素相同，则弹出(空元素)；    如果不同，则直接返回错误
3. 最后栈的长度要为空
```

```java
 public boolean isValid(String s) {
        LinkedList<Character> list = new LinkedList();
        char[] charArray = s.toCharArray();
        if (charArray.length % 2 != 0) {
            return false;
        }

        for (char ch : charArray) {
            if (ch == '{') {
                list.push('}');
            } else if (ch == '[') {
                list.push(']');
            } else if (ch == '(') {
                list.push(')');
            } else if (list.isEmpty() || ch != list.pop()) {
                return false;
            }
        }
        return list.isEmpty();
    }
```

### 2.2 比较含退格的元素-844

```bash
# 比较两个字符串是否相等， # 代表回退删除一个空格
```

```java
public boolean backspaceCompare(String s, String t) {
        LinkedList<Character> first = processStr(s);
        LinkedList<Character> second = processStr(t);
        if (first.size() != second.size()) {
            return false;
        }
        while (first.size() != 0) {
            Character firstEl = first.pop();
            Character secondEl = second.pop();
            if (!firstEl.equals(secondEl)) {
                return false;
            }
        }
        return true;
    }

    private LinkedList<Character> processStr(String s) {
        LinkedList<Character> list = new LinkedList<>();
        for (char ch : s.toCharArray()) {
            if (ch == '#') {
                if (!list.isEmpty()) {
                    list.pop();
                }
            } else {
                list.push(ch);
            }
        }
        return list;
    }
```

### 2.3 逆波兰表达式

#### 后缀表达式求值-150

- 运算符号在数字的后面，这样就不用考虑优先级问题

```bash
# 1. 碰见符号就把前面两个数字弹出栈
# 2. 运算完成后重新入栈

# 输入：tokens = ["2","1","+","3","*"]， 输出：9
```

```java
public int evalRPN(String[] tokens) {
      LinkedList<Integer> list = new LinkedList();
      List<String> calToken = new ArrayList<>();
      calToken.add("+");
      calToken.add("-");
      calToken.add("*");
      calToken.add("/");
      for (String token : tokens) {
          if (calToken.contains(token)) {
              Integer second = list.pop();
              Integer first = list.pop();
              int result = calculate(first, second, token);
              list.push(result);
          } else {
              list.push(Integer.valueOf(token));
          }
      }
      return list.pop();
  }

  private int calculate(int first, int second, String token) {
      switch (token) {
          case "+":
              return first + second;
          case "-":
              return first - second;
          case "*":
              return first * second;
          case "/":
              return first / second;
          default:
              throw new IllegalArgumentException();
      }
  }
```

#### 中缀表达式转后缀

### 2.4 双栈模拟队列-232

- 出的时候，先把当前的outStack中出完，再去倒手

![image-20231018120502207](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231018120502207.png)

```java
class MyQueue {
    LinkedList<Integer> inStack = new LinkedList<>();
    LinkedList<Integer> outStack = new LinkedList<>();

    public MyQueue() {
    }

    public void push(int x) {
        inStack.push(x);
    }

    public int pop() {
        if (empty()) {
            return Integer.MIN_VALUE;
        }

        if (!outStack.isEmpty()) {
            return outStack.pop();
        }

        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
        return outStack.pop();
    }

    public int peek() {
        if (empty()) {
            return Integer.MIN_VALUE;
        }

        if (!outStack.isEmpty()) {
            return outStack.peek();
        }

        while (!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
        return outStack.peek();
    }

    public boolean empty() {
        return inStack.size() == 0 && outStack.size() == 0;
    }
}
```

### 2.5 单队列模拟栈-225

```bash
# 1. 反转队列: 队列中添加元素时候，先判断是否为空
- 为空，  offer添加
- 不会空， 先offer添加，然后把其他的元素先出队列，再重新进
```

![image-20231018123135569](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231018123135569.png)

```java
class MyStack {

    private Queue<Integer> queue = new ArrayDeque();

    public MyStack() {
    }

    public void push(int x) {
        queue.offer(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.offer(queue.poll());
        }
    }

    public int pop() {
        return queue.poll();
    }

    public int top() {
        return queue.peek();
    }

    public boolean empty() {
        return queue.size()==0;
    }
}
```

# 二叉树

- 根结点
- 每个结点，最多有两个叶子结点

```bash
# 满二叉树
- 每个节点都有两个叶子节点

# 完全二叉树
- 其余层都必须填满，最后一层可填满可不填满
- 最后一层：必须从左向右填充
```



```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return String.valueOf(val);
    }
}
```

## 1. 广度优先(层序遍历)

### 1.1 队列实现

```bash
# 思路
- 根结点入队
- 头弹出，处理当前节点，然后将当前节点的左右孩子依次入队
- 直到队列为空
```

![image-20231014115013816](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231014115013816.png)

#### 基础版

- 只是简单打印

```java
public void easy(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        TreeNode el = queue.poll();
        System.out.println(el);
        if (el.left!=null){
            queue.offer(el.left);
        }
        if (el.right!=null){
            queue.offer(el.right);
        }
    }
}
```

#### 层序遍历-102

- 按照数据所在层，进行划分处理

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root==null){
            return result;
        }
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        int currentLayer = 1; // 当前层节点数
        while (!queue.isEmpty()) {
            List<Integer> subResult = new ArrayList<>();
            int nextLayer = 0;
            for (int i = 0; i < currentLayer; i++) { // 添加几次
                TreeNode el = queue.poll();
                subResult.add(el.val);
                if (el.left != null) {
                    queue.offer(el.left);
                    nextLayer++;
                }
                if (el.right != null) {
                    queue.offer(el.right);
                    nextLayer++;
                }
            }
            result.add(subResult);
            currentLayer = nextLayer;
        }
        return result;
    }
```

#### 层序遍历-107

- 按从叶子节点所在层到根节点所在的层，逐层从左向右遍历
- 和上题思路一样，只是在最终result.add(subResult)时，变成result.add(0,subResult)

#### Z字层序遍历-103

```bash
# 思路： 奇数层从左到右，偶数层从右到左，和上面处理思路比较像
```

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.offer(root);

    int layerNodeSize = 1;
    boolean flag = true;
    while (!queue.isEmpty()) {
        List<Integer> subResult = new ArrayList<>();
        int nextLayerNodeSize = 0;
        for (int i = 0; i < layerNodeSize; i++) {
            TreeNode poll = queue.poll();
            if (poll.left != null) {
                queue.offer(poll.left);
                nextLayerNodeSize++;
            }
            if (poll.right != null) {
                queue.offer(poll.right);
                nextLayerNodeSize++;
            }
            if (flag) {
                subResult.add(poll.val);
            } else {
                subResult.add(0, poll.val);
            }
        }
        result.add(subResult);
        layerNodeSize = nextLayerNodeSize;
        flag = !flag;
    }
    return result;
}
```



## 2. 深度优先-递归

```bash
# 前序遍历：  中左右
- 1， 2， 4， 7，8， 3， 5， 9， a， 6， b

# 中序遍历：  左中右
- 7， 4， 8， 2， 1， 9， 5， a, 3, 6, b

# 后序遍历：  左右中
- 7, 8, 4, 2, 9, a, 5, b, 6, 3
```

![image-20231001161115309](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231001161115309.png)

```java
class Solution {

  static TreeNode root = new TreeNode(1,
          new TreeNode(2, new TreeNode(4), null),
          new TreeNode(3, new TreeNode(5), new TreeNode(6)));


  /*前序遍历： 中左右*/
  public void preOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      System.out.println(root.val);
      preOrder(root.left);
      preOrder(root.right);
  }

  /*中序遍历: 左中右*/
  public void inOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      inOrder(root.left);
      System.out.println(root.val);
      inOrder(root.right);
  }

  /*后序遍历： 左右中*/
  public void postOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      postOrder(root.left);
      postOrder(root.right);
      System.out.println(root.val);
  }
}
```

```java
class Solution {

    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), null),
            new TreeNode(3, new TreeNode(5), new TreeNode(6)));

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        preOrder(root, result);
        return result;
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        inOrder(root, result);
        return result;
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postOrder(root, result);
        return result;
    }


    /*前序遍历： 中左右*/
    public void preOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        result.add(root.val);
        preOrder(root.left, result);
        preOrder(root.right, result);
    }

    /*中序遍历: 左中右*/
    public void inOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        inOrder(root.left, result);
        result.add(root.val);
        inOrder(root.right, result);
    }

    /*后序遍历： 左右中*/
    public void postOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        postOrder(root.left, result);
        postOrder(root.right, result);
        result.add(root.val);
    }
}
```

## 3. 深度优先-栈

```java
class StackSolution {
    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), null),
            new TreeNode(3, new TreeNode(5), new TreeNode(6)));


    /*前，中序遍历*/
    public void preorderTraversal(TreeNode root) {
        List<Integer> preResult = new ArrayList<>();  //  前序遍历：中左右 去时记录
        List<Integer> inResult = new ArrayList<>();   // 中序遍历：左中右 回时遍历

        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                preResult.add(cur.val); // 前序遍历
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode pop = path.pop();
                inResult.add(pop.val); // 中序遍历
                cur = pop.right;
            }
        }
    }

    /*后序遍历: 左右中*/
    public void postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        TreeNode recentPop = null;

        while (cur != null || !path.isEmpty()) {
            if (cur != null) {           // 左子树已经处理完了
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode peek = path.peek();
                if (peek.right == null || peek.right == recentPop) { // 右子树处理完了
                    recentPop = path.pop();
                    result.add(recentPop.val);
                } else { // 右子树不为null
                    cur = peek.right;
                }
            }
        }
    }
}
```

```java
class StackSolution {
    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), new TreeNode(5)),
            new TreeNode(3, new TreeNode(6), new TreeNode(7)));


    /*后序遍历: 左右中*/
    public void postorderTraversal(TreeNode root) {
        List<Integer> pre = new ArrayList<>();     // 前序遍历：中左右 去时记录
        List<Integer> in = new ArrayList<>();      // 中序遍历：左中右 回时遍历
        List<Integer> post = new ArrayList<>();    // 后序遍历：左中右 回时遍历
        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        TreeNode pop = null;

        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                path.push(cur);
                // 待处理左子树
                pre.add(cur.val);
                cur = cur.left;
            } else {
                TreeNode peek = path.peek();

                if (peek.right == null) {   // 没有右子树
                    in.add(peek.val);
                    pop = path.pop();
                    post.add(pop.val);
                } else if (peek.right == pop) {   // 右子树处理完成
                    pop = path.pop();
                    post.add(pop.val);
                } else { // 待处理右子树
                    in.add(peek.val);
                    cur = peek.right;
                }
            }
        }
    }
}
```

## 4. 最大深度

- 从根节点出发，最远子结点和根节点的结点总数

### 4.1 递归

```java
public int calculateDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(calculateDepth(root.left), calculateDepth(root.right)) + 1;
}
```

## 3. leetcode

### 对称二叉树

```java
// 思路： 判断左右两个结点是否一样
public boolean checkSymmetricTree(TreeNode root) {
    if (root==null){
        return true;
    }
    return check(root.left, root.right);
}

public boolean check(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }

    if (left == null || right == null) {
        return false;
    }

    if (left.val != right.val) {
        return false;
    }

    return check(left.left, right.right) && check(left.right, right.left);
}
```

### 翻转二叉树

- 二叉树的左右孩子进行变换

```java
/*二叉树翻转*/
public TreeNode mirrorTree(TreeNode root) {
    mirror(root);
    return root;
}

private void mirror(TreeNode root) {
    if (root == null) {
        return;
    }

    // 交换当前层
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
    // 继续翻转左右子树
    mirror(root.left);
    mirror(root.right);
}
```

# 二叉搜索树

- 树节点增加key属性，用来比较谁大谁小，key不可以重复
- 对于所有树节点，它的key比左子树的key都大，同时也比右子树的key都小
- LeetCode中，只包含一个属性，既表示key，也表示value

```java
class BSTreeNode {
    Object val;
    int key;
    BSTreeNode left;
    BSTreeNode right;

    public BSTreeNode(int key) {
        this.key = key;
    }

    public BSTreeNode(Object val, int key) {
        this.val = val;
        this.key = key;
    }

    public BSTreeNode(Object val, int key, BSTreeNode left, BSTreeNode right) {
        this.val = val;
        this.key = key;
        this.left = left;
        this.right = right;
    }
}
```

## 1. 常见方法

- 类定义

```java
class BSTree {

    static BSTreeNode root; // 根结点

    /**
     *          4
     *        /    |
     *       2       6
     *      / \    /  \
     *     1   3   5   7
     */
    static {
        BSTreeNode first = new BSTreeNode("一号", 1);
        BSTreeNode third = new BSTreeNode("三号", 3);
        BSTreeNode fifth = new BSTreeNode("五号", 5);
        BSTreeNode seven = new BSTreeNode("七号", 7);

        BSTreeNode second = new BSTreeNode("二号", 2, first, third);
        BSTreeNode sixth = new BSTreeNode("六号", 6, fifth, seven);
        root = new BSTreeNode("四号", 4, second, sixth);
    }
}
```



### 1.1 根据key查找

```java
/*方式一：递归根据key来查找*/
public Object get1(int key) {
    return doGet(root, key);
}

private Object doGet(BSTreeNode node, int key) {
    if (node == null) {
        return null;
    }

    if (key < node.key) {              // 左子树
        return doGet(node.left, key);
    } else if (key > node.key) {       // 右子树
        return doGet(node.right, key);
    } else {
        return node.val;                // 中间值
    }
}

/*方式二：非递归*/
public Object get2(int key) {
    BSTreeNode node = root;
    while (node != null) {
        if (key < node.key) {
            node = node.left;
        } else if (key > node.key) {
            node = node.right;
        } else {
            return node.val;
        }
    }
    return null;
}
```

### 1.2 最小/大key对应的值

- 最小是找左边，最大是找右边

```java
/*方式一：最小key对应的值， 递归*/
public Object min01() {
    return doMin(root);
}

private Object doMin(BSTreeNode node) {
    if (node == null) {
        return null;
    }

    if (node.left == null) {
        return node.val;
    }

    return doMin(node.left);
}


/*方式二：最小key对应的值， 非递归*/
public Object min02() {
    if (root == null) {
        return null;
    }

    BSTreeNode node = root;
    while (node.left != null) {
        node = node.left;
    }

    return node.val;
}
```

### 1.3 put方法

- key如果存在，则更新，key不存在，新增

```java
/*key存在，则更新， key不存在，则插入*/
  public void put(int key, Object val) {
      if (root == null) {
          root = new BSTreeNode(val, key);
      }

      BSTreeNode node = root;
      BSTreeNode parent = null;
      while (node != null) {
          parent = node; // node为空时上一次节点

          if (key < node.key) {
              node = node.left;
          } else if (key > node.key) {
              node = node.right;
          } else { // key存在, 跟新
              node.val = val;
              return;
          }
      }

      BSTreeNode newNode = new BSTreeNode(val, key);
      if (key < parent.key) {
          parent.left = newNode;
      } else {
          parent.right = newNode;
      }
  }
```

### 1.4 前任后任

### 1.5 删除

```bash
# 1. 删除节点没有left，将right给parent
# 2. 删除节点没有right，将left给parent
# 3. 删除节点没有left 和 right，直接将null给parent
# 4. 删除节点的左右都是有元素的
```

```java
/**
     * @param key: 待删除节点的key
     * @return： 已删除节点的value
     */
    public Object delete(int key) {
        // 1. 找到目标结点
        BSTreeNode target = root;
        BSTreeNode parent = null;   // parent节点
        while (target != null) {
            if (key < target.key) {
                parent = target;
                target = target.left;
            } else if (key > target.key) {
                parent = target;
                target = target.right;
            } else {
                break;
            }
        }

        if (target == null) {
            return null; // 没找到目标结点
        }


        if (target.left == null) {      /*情况1: 节点只有right*/
            shift(parent, target, target.right);
        } else if (target.right == null) {  /*情况2: 节点只有left.      1和2可以覆盖到叶子节点*/
            shift(parent, target, target.left);
        } else { // 情况4: 左右都不为null
            // 暂时不做处理
        }
        return target.val;
    }

    /**
     * @param parent:  被删除节点的parent
     * @param deleted： 被删除结点
     * @param child：   被删除结点的子
     */
    private void shift(BSTreeNode parent, BSTreeNode deleted, BSTreeNode child) {
        if (parent == null) {
            root = child;
        } else if (deleted == parent.left) {
            parent.left = child;
        } else {
            parent.right = child;
        }
    }
```



# AVL树

- 一个二叉树，如果一个节点的right和left，高度差超过1，则此节点失衡，需要旋转
- 一个二叉树，在增加和删除时，就会可能导致失衡
- 在插入和删除时，通过旋转，始终让二叉搜索树保持平衡，就称为自平衡的二叉搜索树
- AVL是自平衡二叉搜索树的实现之一

```java
class AVLNode {
    int key;
    Object val;
    int height = 1;
    AVLNode left;
    AVLNode right;

    public AVLNode(int key, Object val) {
        this.key = key;
        this.val = val;
    }

    public AVLNode(int key) {
        this.key = key;
    }

    public AVLNode(int key, Object val, int height, AVLNode left, AVLNode right) {
        this.key = key;
        this.val = val;
        this.height = height;
        this.left = left;
        this.right = right;
    }

    public int getHeight(AVLNode node) {
        return node == null ? 0 : node.height;
    }

    public void updateHeight() {
        
    }
}
```

# 红黑树

# B树

