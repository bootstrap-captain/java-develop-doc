# 动态数组

```java
class DynamicArray {
    int capacity; // 数组最大长度
    int size;         // 当前数组非空元素的个数
    int[] arr = {};

    public DynamicArray(int capacity) {
        this.capacity = capacity;
    }

    public void addLast(int val) {
        add(size, val);
    }

    public void add(int index, int val) {
        checkAndExpand();
        if (index < 0 || index > size) {
            throw new IllegalArgumentException("Illegal Index");
        }

        if (index < size) { // 指定位置添加
            System.arraycopy(arr, index, arr, index + 1, size - index);
        }
        arr[index] = val;           // addLast添加
        size++;
    }

    public int get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return arr[index];
    }


    public void loop(Consumer<Integer> consumer) {
        for (int i = 0; i < size; i++) {
            consumer.accept(arr[i]);
        }
    }

    public int remove(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException("Illegal Index");
        }
        int removed = arr[index];
        // 数组间,数组内，拷贝, 删除后的数据，只是无法访问了，但是最后一个元素，其实不是0值
        System.arraycopy(arr, index + 1, arr, index, size - index - 1);
        size--;
        return removed;
    }
    
    private void checkAndExpand() {
        if (size == 0) {                   //  首次扩容
            arr = new int[capacity];
        } else if (size == capacity) {     //  后续扩容
            capacity += capacity / 2;
            int[] newArray = new int[capacity];
            System.arraycopy(arr, 0, newArray, 0, size); // 数组拷贝
            arr = newArray;
        }
    }
}
```

# 链表

## 1. 单向链表

```java
class Node{
    int val;
    Node next;

    public Node(int val, Node next) {
        this.val = val;
        this.next = next;
    }
}
```

```java
interface SingleListInter {
    void addFirst(int val);

    void loop(Consumer<Integer> consumer);

    void addLast(int val);

    int get(int index);

    void removeFirst();

    void remove(int index);

    void insert(int index, int val);
}
```

### 1.1 无哨兵

- head永远指向头元素，不要变动
- 会有很多判空的处理

![image-20231004155002630](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004155002630.png)

```java
class SingledList implements SingleListInter {
    Node head;

    @Override
    public void addFirst(int val) {
        head = new Node(val, head); // head为空/不空简化后的代码
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        Node pointer = head;  // 移动pointer而不是head
        while (pointer != null) {
            consumer.accept(pointer.val);
            pointer = pointer.next;
        }
    }

    @Override
    public void addLast(int val) {
        Node last = findLast();
        if (last == null) {
            addFirst(val);
        } else {
            last.next = new Node(val, null);
        }
    }

    @Override
    public int get(int index) {
        Node node = getNode(index);
        if (node == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return node.val;
    }

    @Override
    public void removeFirst() {
        if (head == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        head = head.next; // 前面一个元素，自动被垃圾回收掉
    }

    @Override
    public void remove(int index) {
        if (index == 0) {
            removeFirst();
        }
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node removed = prev.next;
        if (removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = removed.next;
    }

    @Override
    public void insert(int index, int val) {
        if (index == 0) {
            addFirst(val);
            return;
        }

        Node prev = getNode(index - 1); // 找前一个节点
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        prev.next = new Node(val, prev.next);
    }


    private Node findLast() {
        if (head == null) {
            return null;
        }
        Node pointer = head;
        while (pointer.next != null) {
            pointer = pointer.next;
        }
        return pointer;
    }

    private Node getNode(int index) {
        Node pointer = head;
        int currentIndex = -1;
        while (pointer != null) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

### 1.2 带哨兵

- dummy元素充当首元素，避免了一些判空处理

![image-20231004182312899](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004182312899.png)

```java

class SingledDummyList implements SingleListInter {
    Node dummy = new Node(Integer.MIN_VALUE, null);
    Node head = dummy;

    @Override
    public void addFirst(int val) {
        head.next = new Node(val, head.next);
    }

    @Override
    public void loop(Consumer<Integer> consumer) {
        Node pointer = head.next;
        while (pointer != null) {
            consumer.accept(pointer.val);
            pointer = pointer.next;
        }
    }

    @Override
    public void addLast(int val) {
        Node last = findLast();
        last.next = new Node(val, null);
    }

    @Override
    public int get(int index) {
        Node node = getNode(index);
        if (node == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        return node.val;
    }

    @Override
    public void removeFirst() {
        if (dummy.next == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        dummy.next = dummy.next.next;
    }

    @Override
    public void remove(int index) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }

        Node removed = prev.next;
        if (removed == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = removed.next;
    }

    @Override
    public void insert(int index, int val) {
        Node prev = getNode(index - 1);
        if (prev == null) {
            throw new IllegalArgumentException("Illegal Index");
        }
        prev.next = new Node(val, prev.next);
    }

    private Node findLast() {
        Node pointer = head;
        while (pointer.next != null) {
            pointer = pointer.next;
        }
        return pointer;
    }

    private Node getNode(int index) {
        Node pointer = head;
        int currentIndex = -2;
        while (pointer != null) {
            currentIndex++;
            if (index == currentIndex) {
                return pointer;
            }
            pointer = pointer.next;
        }
        return null;
    }
}
```

## 2. 双向链表

- 带头哨兵和尾哨兵的双向链表

![image-20231004191925877](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231004191925877.png)

```java
class Node {
    int val;
    Node prev;
    Node next;

    public Node(int val, Node prev, Node next) {
        this.val = val;
        this.prev = prev;
        this.next = next;
    }
}
```

```java

```



## 3. 环形链表



# 队列

- 尾巴进数据，头部出数据

## 1. 链表实现

- 单向环形带哨兵的链表来实现队列

## 2. 环形数组

### 2.1 形式1

- 数组会有一个空的位置来存放数据
- 下标计算： （当前指针位置+前进步数）% length

```java
package com.citi.d04;

public class Demo01 {
    public static void main(String[] args) {
        /*存储4个数据*/
        ArrayQueue arrayQueue = new ArrayQueue(4);
        arrayQueue.add(3);
        arrayQueue.add(6);
        arrayQueue.add(12);
        arrayQueue.add(45);
        arrayQueue.add(56);
    }
}


/*下标计算： （当前指针位置+前进步数）% length
 * 判断空：头指针，尾指针：头尾指针相同
 * 判断满： 尾指针+1 = 头指针 */
class ArrayQueue implements Queue {

    private int[] array;
    private int head = 0;
    private int tail = 0;

    public ArrayQueue(int capacity) {
        array = new int[capacity + 1];
    }

    /*尾巴*/
    @Override
    public boolean add(int val) {
        if (isFull()) {
            return false;
        }
        array[tail] = val; // 赋值
        tail = (tail + 1) % array.length;        // 步长为1
        return true;
    }

    /*头：移除*/
    @Override
    public int get() {
        if (isEmpty()) {
            return -888;
        }
        int result = array[head];
        head = (head + 1) % array.length;
        return result;
    }

    /*头，尾重合时，表示为空*/
    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    /*空出来一个位置，来进行判断满： tail比head小1*/
    @Override
    public boolean isFull() {
        return (tail + 1) % array.length == head;
    }
}


interface Queue {

    /*向队列尾部添加*/
    boolean add(int val);

    /*从队列头部取出，并移除*/
    int get();

    boolean isEmpty();

    boolean isFull();
}
```

### 2.2 形式2

- 新增一个变量，来判断队列是空还是满

```java
class ArrayQueueSecond implements Queue {

    private int head;
    private int tail;

    private int[] arr;

    private int size;

    public ArrayQueueSecond(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean add(int val) {
        if (isFull()) {
            return false;
        }
        arr[tail] = val;
        tail = (tail + 1) % arr.length;
        size++;
        return true;
    }

    @Override
    public int get() {
        if (isEmpty()) {
            return -988;
        }
        int result = arr[head];
        head = (head + 1) % arr.length;
        size--;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}
```

### 2.3 形式3

- head和tail不断自增，自增到正无穷
- 具体计算下一个索引的时候，再去进行运算

```java
class ArrayQueueThird implements Queue {

    private int head = 0;
    private int tail = 0;

    private int[] arr;

    public ArrayQueueThird(int capacity) {
        arr = new int[capacity];
    }

    @Override
    public boolean add(int val) {
        if (isFull()) {
            return false;
        }
        int index = tail % arr.length;
        arr[index] = val;
        tail++;
        return true;
    }

    @Override
    public int get() {
        if (isFull()) {
            return -999;
        }
        int index = head % arr.length; // 具体的index，在需要用到的时候再进行计算
        int result = arr[index];
        head++;
        return result;
    }

    @Override
    public boolean isEmpty() {
        return head == tail;
    }

    @Override
    public boolean isFull() {
        return (tail - head) == arr.length;
    }
}
```

### 2.4 二叉树-层序遍历

- 二叉树：一个树中，每个结点最多有两个元素
- 从上到小，一层一层遍历

# 栈

- 先进后出

## 1. 数组实现

```java
package com.citi.d04;

public class Demo02 {
    public static void main(String[] args) {
        Stack stack = new ArrayStack(4);
        stack.push(4);
        stack.push(5);
        stack.push(6);
        stack.push(6);
        stack.push(9);
    }
}

/*
 *  底          顶
 *  0   1   2   3
 *  a   b   c   d
 *
 *  top一开始为0，表示为空
 *  top增长到4(数组长度)，表示为满
 * */
class ArrayStack implements Stack {

    private int[] array;

    /*栈顶指针*/
    private int top = 0;

    public ArrayStack(int capacity){
        array = new int[capacity];
    }

    @Override
    public boolean push(int val) {
        if (isFull()) {
            return false;
        }
        array[top] = val;
        top++;
        return true;
    }

    @Override
    public int pop() {
        if (isEmpty()) {
            return -9899;
        }
        top--;
        return array[top];
    }

    @Override
    public boolean isEmpty() {
        return top == 0;
    }

    @Override
    public boolean isFull() {
        return top == array.length;
    }
}

interface Stack {

    /*加数据*/
    boolean push(int val);

    /*弹出数据*/
    int pop();

    boolean isEmpty();

    boolean isFull();
}
```

## 3 leetcode

### 3.1 有效的括号

- 实现方法：用java自己的LinkedList类

```bash
1. 遇见左括号，则在栈中添加右括号
2. 遇见右括号，如果和栈顶元素相同，则弹出(空元素)；    如果不同，则直接返回错误结果
3. 最后栈的长度要为空
```

### 3.2 比较含退格的元素

### 3.3 逆波兰表达式

#### 后缀表达式求值

- 运算符号在数字的后面，这样就不用考虑优先级问题

```bash
# 1. 碰见符号就把前面两个数字弹出栈
# 2. 运算完成后重新入栈
```

![image-20231001112853595](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231001112853595.png)

### 3.4 两个栈模拟一个队列

### 3.5 单队列模拟一个栈

```bash
# 1. 反转队列: 队列中添加元素时候，先判断是否为空
- 为空，则直接添加
- 不会空，先添加元素，然后把其他的元素先从出队列，再重新进
```

# 双端队列

- 两端都可以删除，添加
- Deque: Double End Queue, 双端队列

## 1. 数组实现

### 1.1 形式1

- 数组会有一个空的位置来存放数据
- 下标计算： （当前指针位置+前进步数）% length

# 优先级队列



# 二叉树

- 根结点
- 每个结点，最多有两个叶子结点
- 满二叉树：每个结点都有两个叶子结点

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
    }

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }

    @Override
    public String toString() {
        return String.valueOf(val);
    }
}
```

## 1. 深度优先-递归

```bash
# 前序遍历：  中左右
- 1， 2， 4， 7，8， 3， 5， 9， a， 6， b

# 中序遍历：  左中右
- 7， 4， 8， 2， 1， 9， 5， a, 3, 6, b

# 后序遍历：  左右中
- 7, 8, 4, 2, 9, a, 5, b, 6, 3
```

![image-20231001161115309](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20231001161115309.png)

```java
class Solution {

  static TreeNode root = new TreeNode(1,
          new TreeNode(2, new TreeNode(4), null),
          new TreeNode(3, new TreeNode(5), new TreeNode(6)));


  /*前序遍历： 中左右*/
  public void preOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      System.out.println(root.val);
      preOrder(root.left);
      preOrder(root.right);
  }

  /*中序遍历: 左中右*/
  public void inOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      inOrder(root.left);
      System.out.println(root.val);
      inOrder(root.right);
  }

  /*后序遍历： 左右中*/
  public void postOrder(TreeNode root) {
      if (root == null) {
          return;
      }
      postOrder(root.left);
      postOrder(root.right);
      System.out.println(root.val);
  }
}
```

```java
class Solution {

    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), null),
            new TreeNode(3, new TreeNode(5), new TreeNode(6)));

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        preOrder(root, result);
        return result;
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        inOrder(root, result);
        return result;
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postOrder(root, result);
        return result;
    }


    /*前序遍历： 中左右*/
    public void preOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        result.add(root.val);
        preOrder(root.left, result);
        preOrder(root.right, result);
    }

    /*中序遍历: 左中右*/
    public void inOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        inOrder(root.left, result);
        result.add(root.val);
        inOrder(root.right, result);
    }

    /*后序遍历： 左右中*/
    public void postOrder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        postOrder(root.left, result);
        postOrder(root.right, result);
        result.add(root.val);
    }
}
```

## 2. 深度优先-栈

```java
class StackSolution {
    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), null),
            new TreeNode(3, new TreeNode(5), new TreeNode(6)));


    /*前，中序遍历*/
    public void preorderTraversal(TreeNode root) {
        List<Integer> preResult = new ArrayList<>();  //  前序遍历：中左右 去时记录
        List<Integer> inResult = new ArrayList<>();   // 中序遍历：左中右 回时遍历

        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                preResult.add(cur.val); // 前序遍历
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode pop = path.pop();
                inResult.add(pop.val); // 中序遍历
                cur = pop.right;
            }
        }
    }

    /*后序遍历: 左右中*/
    public void postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        TreeNode recentPop = null;

        while (cur != null || !path.isEmpty()) {
            if (cur != null) {           // 左子树已经处理完了
                path.push(cur);
                cur = cur.left;
            } else {
                TreeNode peek = path.peek();
                if (peek.right == null || peek.right == recentPop) { // 右子树处理完了
                    recentPop = path.pop();
                    result.add(recentPop.val);
                } else { // 右子树不为null
                    cur = peek.right;
                }
            }
        }
    }
}
```

```java
class StackSolution {
    static TreeNode root = new TreeNode(1,
            new TreeNode(2, new TreeNode(4), new TreeNode(5)),
            new TreeNode(3, new TreeNode(6), new TreeNode(7)));


    /*后序遍历: 左右中*/
    public void postorderTraversal(TreeNode root) {
        List<Integer> pre = new ArrayList<>();     // 前序遍历：中左右 去时记录
        List<Integer> in = new ArrayList<>();      // 中序遍历：左中右 回时遍历
        List<Integer> post = new ArrayList<>();    // 后序遍历：左中右 回时遍历
        LinkedList<TreeNode> path = new LinkedList<>(); // 栈: 保存来去时候的路径

        TreeNode cur = root;
        TreeNode pop = null;

        while (cur != null || !path.isEmpty()) {
            if (cur != null) {
                path.push(cur);
                // 待处理左子树
                pre.add(cur.val);
                cur = cur.left;
            } else {
                TreeNode peek = path.peek();

                if (peek.right == null) {   // 没有右子树
                    in.add(peek.val);
                    pop = path.pop();
                    post.add(pop.val);
                } else if (peek.right == pop) {   // 右子树处理完成
                    pop = path.pop();
                    post.add(pop.val);
                } else { // 待处理右子树
                    in.add(peek.val);
                    cur = peek.right;
                }
            }
        }
    }
}
```

## 4. 最大深度

- 从根节点出发，最远子结点和根节点的结点总数

### 4.1 递归

```java
public int calculateDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(calculateDepth(root.left), calculateDepth(root.right)) + 1;
}
```

## 3. leetcode

### 对称二叉树

```java
// 思路： 判断左右两个结点是否一样
public boolean checkSymmetricTree(TreeNode root) {
    if (root==null){
        return true;
    }
    return check(root.left, root.right);
}

public boolean check(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }

    if (left == null || right == null) {
        return false;
    }

    if (left.val != right.val) {
        return false;
    }

    return check(left.left, right.right) && check(left.right, right.left);
}
```

### 翻转二叉树

- 二叉树的左右孩子进行变换

```java
/*二叉树翻转*/
public TreeNode mirrorTree(TreeNode root) {
    mirror(root);
    return root;
}

private void mirror(TreeNode root) {
    if (root == null) {
        return;
    }

    // 交换当前层
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
    // 继续翻转左右子树
    mirror(root.left);
    mirror(root.right);
}
```

# 二叉搜索树

- 树节点增加key属性，用来比较谁大谁小，key不可以重复
- 对于所有树节点，它的key比左子树的key都大，同时也比右子树的key都小
- LeetCode中，只包含一个属性，既表示key，也表示value

```java
class BSTreeNode {
    Object val;
    int key;
    BSTreeNode left;
    BSTreeNode right;

    public BSTreeNode(int key) {
        this.key = key;
    }

    public BSTreeNode(Object val, int key) {
        this.val = val;
        this.key = key;
    }

    public BSTreeNode(Object val, int key, BSTreeNode left, BSTreeNode right) {
        this.val = val;
        this.key = key;
        this.left = left;
        this.right = right;
    }
}
```

## 1. 常见方法

- 类定义

```java
class BSTree {

    static BSTreeNode root; // 根结点

    /**
     *          4
     *        /    |
     *       2       6
     *      / \    /  \
     *     1   3   5   7
     */
    static {
        BSTreeNode first = new BSTreeNode("一号", 1);
        BSTreeNode third = new BSTreeNode("三号", 3);
        BSTreeNode fifth = new BSTreeNode("五号", 5);
        BSTreeNode seven = new BSTreeNode("七号", 7);

        BSTreeNode second = new BSTreeNode("二号", 2, first, third);
        BSTreeNode sixth = new BSTreeNode("六号", 6, fifth, seven);
        root = new BSTreeNode("四号", 4, second, sixth);
    }
}
```



### 1.1 根据key查找

```java
/*方式一：递归根据key来查找*/
public Object get1(int key) {
    return doGet(root, key);
}

private Object doGet(BSTreeNode node, int key) {
    if (node == null) {
        return null;
    }

    if (key < node.key) {              // 左子树
        return doGet(node.left, key);
    } else if (key > node.key) {       // 右子树
        return doGet(node.right, key);
    } else {
        return node.val;                // 中间值
    }
}

/*方式二：非递归*/
public Object get2(int key) {
    BSTreeNode node = root;
    while (node != null) {
        if (key < node.key) {
            node = node.left;
        } else if (key > node.key) {
            node = node.right;
        } else {
            return node.val;
        }
    }
    return null;
}
```

### 1.2 最小/大key对应的值

- 最小是找左边，最大是找右边

```java
/*方式一：最小key对应的值， 递归*/
public Object min01() {
    return doMin(root);
}

private Object doMin(BSTreeNode node) {
    if (node == null) {
        return null;
    }

    if (node.left == null) {
        return node.val;
    }

    return doMin(node.left);
}


/*方式二：最小key对应的值， 非递归*/
public Object min02() {
    if (root == null) {
        return null;
    }

    BSTreeNode node = root;
    while (node.left != null) {
        node = node.left;
    }

    return node.val;
}
```

### 1.3 put方法

- key如果存在，则更新，key不存在，新增

```java
/*key存在，则更新， key不存在，则插入*/
  public void put(int key, Object val) {
      if (root == null) {
          root = new BSTreeNode(val, key);
      }

      BSTreeNode node = root;
      BSTreeNode parent = null;
      while (node != null) {
          parent = node; // node为空时上一次节点

          if (key < node.key) {
              node = node.left;
          } else if (key > node.key) {
              node = node.right;
          } else { // key存在, 跟新
              node.val = val;
              return;
          }
      }

      BSTreeNode newNode = new BSTreeNode(val, key);
      if (key < parent.key) {
          parent.left = newNode;
      } else {
          parent.right = newNode;
      }
  }
```

### 1.4 前任后任

### 1.5 删除

```bash
# 1. 删除节点没有left，将right给parent
# 2. 删除节点没有right，将left给parent
# 3. 删除节点没有left 和 right，直接将null给parent
# 4. 删除节点的左右都是有元素的
```

```java
/**
     * @param key: 待删除节点的key
     * @return： 已删除节点的value
     */
    public Object delete(int key) {
        // 1. 找到目标结点
        BSTreeNode target = root;
        BSTreeNode parent = null;   // parent节点
        while (target != null) {
            if (key < target.key) {
                parent = target;
                target = target.left;
            } else if (key > target.key) {
                parent = target;
                target = target.right;
            } else {
                break;
            }
        }

        if (target == null) {
            return null; // 没找到目标结点
        }


        if (target.left == null) {      /*情况1: 节点只有right*/
            shift(parent, target, target.right);
        } else if (target.right == null) {  /*情况2: 节点只有left.      1和2可以覆盖到叶子节点*/
            shift(parent, target, target.left);
        } else { // 情况4: 左右都不为null
            // 暂时不做处理
        }
        return target.val;
    }

    /**
     * @param parent:  被删除节点的parent
     * @param deleted： 被删除结点
     * @param child：   被删除结点的子
     */
    private void shift(BSTreeNode parent, BSTreeNode deleted, BSTreeNode child) {
        if (parent == null) {
            root = child;
        } else if (deleted == parent.left) {
            parent.left = child;
        } else {
            parent.right = child;
        }
    }
```

# AVL树

- 一个二叉树，如果一个节点的right和left，高度差超过1，则此节点失衡，需要旋转
- 一个二叉树，在增加和删除时，就会可能导致失衡
- 在插入和删除时，通过旋转，始终让二叉搜索树保持平衡，就称为自平衡的二叉搜索树
- AVL是自平衡二叉搜索树的实现之一

```java
class AVLNode {
    int key;
    Object val;
    int height = 1;
    AVLNode left;
    AVLNode right;

    public AVLNode(int key, Object val) {
        this.key = key;
        this.val = val;
    }

    public AVLNode(int key) {
        this.key = key;
    }

    public AVLNode(int key, Object val, int height, AVLNode left, AVLNode right) {
        this.key = key;
        this.val = val;
        this.height = height;
        this.left = left;
        this.right = right;
    }

    public int getHeight(AVLNode node) {
        return node == null ? 0 : node.height;
    }

    public void updateHeight() {
        
    }
}
```

# 红黑树

# B树

