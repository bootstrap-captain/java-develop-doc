## Symmetric Encryption

### 1. 简介

- 加密和解密，使用相同密钥
- 强大且高效，适用于处理大量数据
- 安全性高度依赖于密钥的管理，如使用密钥托管服务

```bash
# 加密方式
- 数据加密标准：DES，3DES
- 高级加密标准：AES
```

### 2. AES

- 支持不同的密钥长度，分别为128位，192位，256位
- 位数越高，加密越复杂，但性能越低

### 3. bcprov-jdk18on

[bouncycastle官网](https://www.bouncycastle.org/)

```xml
<dependency>
    <groupId>org.bouncycastle</groupId>
    <artifactId>bcprov-jdk18on</artifactId>
    <version>1.79</version>
</dependency>
```

#### create-key

- 生成的key，通过Base64编码后传输
- key可以保存在密钥管理系统中

```java
package com.erick;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.junit.jupiter.api.Test;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.security.SecureRandom;
import java.security.Security;
import java.util.Base64;

public class CreateKeyTest {

    /*加密算法*/
    private final String KEY_ALGORITHM = "AES";

    /*AES提供者*/
    private final String provider = "BC";

    /*128: 24个长度的字符串    RNc8oknQ4J+KmCXbMjO4ZQ==
      192: 32个长度的字符串    uPyysG9if9NgFHHxGdf2R0vacOaCzyFi
      256: 44个长度的字符串    8dW1PMAbbwwpj8VG/wpxVt+mVble3SZUbZEF0IltGUg=*/
    private final int keySize = 256;

    @Test
    public void generateKey() throws Exception {
        /*注册Bouncy Castle*/
        Security.addProvider(new BouncyCastleProvider());

        KeyGenerator generator = KeyGenerator.getInstance(KEY_ALGORITHM, provider);
        /*参数二：生成方式为随机源*/
        generator.init(keySize, new SecureRandom());

        /*生成key*/
        SecretKey secretKey = generator.generateKey();
        byte[] keyBytes = secretKey.getEncoded();
        /*key: 通过Base64加密字节数组，转换为字符串*/
        String keyString = Base64.getEncoder().encodeToString(keyBytes);
    }
}
```

#### encrypt-side

```java
package com.erick;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.junit.jupiter.api.Test;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.Security;
import java.util.Base64;

public class EncryptTest {

    /*要加密的数据*/
    private final String rawData = "hello erick";

    /*加密算法*/
    private final String KEY_ALGORITHM = "AES";

    /*AES提供者*/
    private final String provider = "BC";

    private final String key = "2/DLpB7EAsiUcKuDTqgNbc5dMfKJVU869bytDocSYp8=";

    @Test
    public void encrypt() throws Exception {
        Security.addProvider(new BouncyCastleProvider());

        /*将Base64加密的解密后，生成SecretKey*/
        SecretKey secretKey = new SecretKeySpec(Base64.getDecoder().decode(key), KEY_ALGORITHM);

        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding", provider);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        byte[] bytes = cipher.doFinal(rawData.getBytes());

        /*传输中使用Base64: 相同密钥，生成的数据是相同的
         * aSGwtpmnxQ1CMUjT/9XJUw==*/
        String encryptData = Base64.getEncoder().encodeToString(bytes);
        System.out.println(encryptData);
    }
}
```

#### decrypt-side

```java
package com.erick;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.junit.jupiter.api.Test;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.Security;
import java.util.Base64;

public class DecryptTest {

    /*Base64*/
    private final String encryptData = "aSGwtpmnxQ1CMUjT/9XJUw==";

    /*加密算法*/
    private final String KEY_ALGORITHM = "AES";

    /*AES提供者*/
    private final String provider = "BC";

    private final String key = "2/DLpB7EAsiUcKuDTqgNbc5dMfKJVU869bytDocSYp8=";

    @Test
    public void decrypt() throws Exception {
        Security.addProvider(new BouncyCastleProvider());
        /*将Base64加密的解密后，生成SecretKey*/
        SecretKey secretKey = new SecretKeySpec(Base64.getDecoder().decode(key), KEY_ALGORITHM);
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding", provider);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);

        byte[] decryptData = cipher.doFinal(Base64.getDecoder().decode(encryptData));
        System.out.println(new String(decryptData));
    }
}
```

