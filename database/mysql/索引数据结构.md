# 引入原因

## 1. 理念

- 索引：存储引擎快速找到数据记录的一种<font color=orange>数据结构</font>。排好序的快速查找数据结构，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现<font color=orange>高级查找算法</font>
- <font color=orange>索引是在存储引擎中实现的</font>，每种存储引擎的索引不完全相同，每种存储引擎支持的索引类型也不同。存储引擎定义的每个表的<font color=orange>最大索引数</font>和<font color=orange>最大索引长度</font>不同
- 类似书本，通过目录找到对应文章的页码，快速定位到需要的文章
- MySQL: 首先查看查询条件是否命中某个索引，符合则<font color=orange>通过索引查找</font>相关数据，否则<font color=orange>全表扫描</font>

## 2. 优点

- 提高数据检索的效率，降低数据库的<font color=orange>磁盘IO成本</font>
- 唯一索引：保证数据库表中每一行的<font color=orange>数据唯一性</font>
- 在使用分组和排序子句进行数据查询时，可以显著<font color=orange>减少查询中分组和排序的时间</font>，降低CPU消耗

## 3. 缺点

- 创建索引和维护索引<font color=orange>耗费时间</font>，并且随着数据量的增加，所耗费的时间也会增加
- 索引需要占<font color=orange>磁盘空间</font>，除了数据表占数据空间之外，每个索引还要占用一定的物理空间，<font color=orange>存储在磁盘上</font>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸
- 索引大大提高查询速度，同时却<font color=orange>降低写速度</font>。对表中数据进行写操作时，需要动态维护索引，因此写操作比较慢

```bash
# 索引可以提高查询的速度，但会影响插入记录的速度
- 最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引
```

# InnoDB索引推演

```sql
# 精确匹配的查找例子
SELECT [列名] FROM [表名] WHERE 列名=xxx;
```

## 1. 不加索引

### 1.1 一个页

- 表中记录比较少时，所有的记录都存放在一个页中
- 主键查找： 在<font color=orange>页目录</font>中使用<font color=orange>二分法</font>快速定位到对应的<font color=orange>槽</font>，然后再遍历该槽对应的分组中的记录
- 其他列查找：数据页并没有对应非主键列所谓的页目录，只能从<font color="orange">最小记录</font>开始，<font color="orange">依次遍历</font>单链表中的每条记录，然后对比每条记录是否满足搜索条件

### 1.2 多个页

- 主键列：首先定位到查找的记录所在的页然后从所在页中，根据单页的方式查找对应的记录
- 非主键列：可能需要遍历所有数据页，比如搜索条件可能对应多个行记录

## 2. 索引设计

- <font color=green><strong>record_type</strong></font>: 记录的类型。0-普通记录，2-最小记录，3-最大记录
- <font color=green><strong>next_record</strong></font>: 下一条记录的地址相对于本条记录的地址偏移量
- 各个列的值：当前表中的各个列
- 其他信息：除了上述三种信息，其他的隐藏列的值以及记录的额外信息

```sql
# 建表
CREATE TABLE girl_shoes
(
    id   int primary key,
    age  int,
    name char(1)
);
```


### 2.1 数据页

- 假设每个数据页最多能存放3条记录，实际上一个数据页非常大，能够存放多个记录
- 记录按照主键值的大小，串联称一个单向链表
- 多个页之间：双向链表，物理上不连续，逻辑上连续
- 页分裂：一个页存满时，或者根据主键来进行索引时，可能会存在记录移动

```sql
# 插入3条数据： 会按照主键大小来进行插入，并重新排序
INSERT INTO girl_shoes
values (1, 14, 'a'),
       (5, 20, 'c'),
       (3, 16, 'b');

# 再插入一条数据，会存在页分裂，伴随着记录移动
INSERT INTO girl_shoes
values (4, 32, 'd')；
```

![image-20230718165528719](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230718165528719.png)

### 2.2 页之目录项页

- 数据页的<font color=orange>可能是不连续的</font>，16kb的页在物理存储上是不连续的，如果要从这么多页根据主键值<font color=orange>快速定位某些记录所在的页</font>，需要对页做个<font color=orange>目录</font>
- 目录项页和普通页根据record_type来区分
- 每个页对应一个目录项，每个目录项包含两个部分
- <font color=orange>页的用户记录中最小的主键值</font>: key
- <font color=orange>页号</font>： page_no
- 查找数据时页目录：IO只有两次或者多次(定位目录页可能需要多次)，先从目录项页中根据key找到在哪一页，然后再去加载对应的页

![image-20230718171525721](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230718171525721.png)

### 2.3 目录项页之目录项页

- 假如顶层目录项页只有一个，查找一个数据的时候，只需要三次与磁盘之间的IO

![image-20230719102801562](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230719102801562.png)

### 2.4 B+树

- 叶子节点：存放真实的数据，页和页之间通过<font color=orange>双向链表</font>连接，页内的数据通过<font color=orange>单向链表</font>连接
- 非叶子结点：目录项构成的结点，不存放数据

![image-20230719104046875](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230719104046875.png)

- B+树通常不会超过<font color=orange>4层</font>
- 原因一：数据体量
- 原因二：<font color=orange>树的层次越低，内存和磁盘的IO次数就越少</font>，数据查找时候，每经过一层，就是一次IO，因为加载数据的时候，是把一个完整的页加载到内存中

```bash
# 数据体量，一个页的默认大小一般是16kb
假设叶子结点一个页可以存放100条用户记录，非叶子结点一个页可以存放1000条记录(因为非叶子结点数据项比较少)
- 1层：   100条
- 2层：   1000*100条
- 3层：   1000*1000*100条
```

## 3. 索引物理类型

- 索引按照物理存储实现方式，可以分为聚簇索引和非聚簇索引

### 3.1 聚簇索引

- 聚簇索引不是一种单独的索引类型，而是一种<font color=dred>数据存储方式</font>，也就是所有的用户记录存储在叶子结点
- <font color=orange>索引即数据，数据即索引</font>

![image-20230719110202647](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230719110202647.png)

**按主键值大小记录和页排序**

- 页内的记录是按照<font color=orange>主键大小顺序</font>排成一个单向链表
- 各个存放用户记录的页也是根据页中用户记录的主键大小排序称一个双向链表
- 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表

**叶子结点存储完整用户记录**

- 完整的用户记录，指该记录中存储了所有列的值(包括隐藏列)

拥有上述两种特性的B+树成为聚簇索引，该聚簇索引不需要在MySQL中显示的使用<font color=orange>INDEX</font>语句创建，<font color=orange>InnoDB</font>存储引擎会<font color=orange>自动</font>为我们创建聚簇索引，同时也是构建数据

#### 优点

- <font color=orange>数据访问更快</font>，索引和数据保存在同一个B+树中，因此比非聚簇索引更快
- 对于主键的<font color=orange>排序查找</font>和<font color=orange>范围查找</font>速度非常快
- 范围查询时，数据都是紧密相连，数据库不用从多个数据快中提取数据，<font color=orange>节省大量IO操作</font>

#### 缺点

- <font color=orange>插入速度严重依赖插入顺序</font>，按照主键的顺序插入是最快的，否则出现页分裂，严重影响性能。因此对于InnoDB表，一般会定义一个<font color=orange>自增的ID列为主键</font>
- <font color=orange>更新主键的代价很高</font>,因为将会导致更新的行移动以及伴随的页分裂。因此对于InnoDB表，一般<font color=orange>主键为不可更新</font>
- <font color=orange>二级索引访问需要两次索引查找</font>，第一次找到主键值，第二次根据主键值找到行数据

#### 限制

- InnoDB支持聚簇索引，MyISAM不支持聚簇索引
- 数据物理存储排序方式只能有一种，所以每个MySQL表<font color=orange>只能有一个聚簇索引</font>。一般情况就是该表的主键
- 如果没有定义主键，InnoDB会选择<font color=orange>非空的唯一索引</font>来代替。如果没有这样的索引，InnoDB会隐式的定义一个主键作为聚簇索引
- 为了充分利用聚簇索引的聚簇特性，InnoDB表的主键列尽可能<font color=orange>用有序的顺序ID</font>，而不建议用无序的id，比如UUID，MD5， HASH， 字符串列作为主键无法保证数据的顺序增长

### 3.2 非聚簇索引

- 也叫做辅助索引，非聚簇索引二级索引
- 聚簇索引只能是搜索条件是<font color=orange>主键值</font>时才能发挥作用，如果要以别的列作为搜索条件时，就需要建立非聚簇索引



