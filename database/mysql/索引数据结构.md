# 引入原因

## 1. 理念

- 索引：存储引擎快速找到数据记录的一种<font color=orange>数据结构</font>。排好序的快速查找数据结构，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现<font color=orange>高级查找算法</font>
- <font color=orange>索引是在存储引擎中实现的</font>，每种存储引擎的索引不完全相同，每种存储引擎支持的索引类型也不同。存储引擎定义的每个表的<font color=orange>最大索引数</font>和<font color=orange>最大索引长度</font>不同
- 类似书本，通过目录找到对应文章的页码，快速定位到需要的文章
- MySQL: 首先查看查询条件是否命中某个索引，符合则<font color=orange>通过索引查找</font>相关数据，否则<font color=orange>全表扫描</font>

## 2. 优点

- 提高数据检索的效率，降低数据库的<font color=orange>磁盘IO成本</font>
- 唯一索引：保证数据库表中每一行的<font color=orange>数据唯一性</font>
- 在使用分组和排序子句进行数据查询时，可以显著<font color=orange>减少查询中分组和排序的时间</font>，降低CPU消耗

## 3. 缺点

- 创建索引和维护索引<font color=orange>耗费时间</font>，并且随着数据量的增加，所耗费的时间也会增加
- 索引需要占<font color=orange>磁盘空间</font>，除了数据表占数据空间之外，每个索引还要占用一定的物理空间，<font color=orange>存储在磁盘上</font>，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸
- 索引大大提高查询速度，同时却<font color=orange>降低写速度</font>。对表中数据进行写操作时，需要动态维护索引，因此写操作比较慢

```bash
# 索引可以提高查询的速度，但会影响插入记录的速度
- 最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引
```

# InnoDB索引推演

```sql
# 精确匹配的查找例子
SELECT [列名] FROM [表名] WHERE 列名=xxx;
```

## 1. 不加索引

### 1.1 一个页

- 表中记录比较少时，所有的记录都存放在一个页中
- 主键查找： 在<font color=orange>页目录</font>中使用<font color=orange>二分法</font>快速定位到对应的<font color=orange>槽</font>，然后再遍历该槽对应的分组中的记录
- 其他列查找：数据页并没有对应非主键列所谓的页目录，只能从<font color="orange">最小记录</font>开始，<font color="orange">依次遍历</font>单链表中的每条记录，然后对比每条记录是否满足搜索条件

### 1.2 多个页

- 主键列：首先定位到查找的记录所在的页然后从所在页中，根据单页的方式查找对应的记录
- 非主键列：可能需要遍历所有数据页，比如搜索条件可能对应多个行记录

## 2. 索引设计

- <font color=green><strong>record_type</strong></font>: 记录的类型。0-普通记录，2-最小记录，3-最大记录
- <font color=green><strong>next_record</strong></font>: 下一条记录的地址相对于本条记录的地址偏移量
- 各个列的值：当前表中的各个列
- 其他信息：除了上述三种信息，其他的隐藏列的值以及记录的额外信息

```sql
# 建表
CREATE TABLE girl_shoes
(
    id   int primary key,
    age  int,
    name char(1)
);
```


### 2.1 数据页

- 假设每个数据页最多能存放3条记录，实际上一个数据页非常大，能够存放多个记录
- 记录按照主键值的大小，串联称一个单向链表
- 多个页之间：双向链表，物理上不连续，逻辑上连续
- 页分裂：一个页存满时，或者根据主键来进行索引时，可能会存在记录移动

```sql
# 插入3条数据： 会按照主键大小来进行插入，并重新排序
INSERT INTO girl_shoes
values (1, 14, 'a'),
       (5, 20, 'c'),
       (3, 16, 'b');

# 再插入一条数据，会存在页分裂，伴随着记录移动
INSERT INTO girl_shoes
values (4, 32, 'd')；
```

![image-20230718165528719](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230718165528719.png)

### 2.2 页之目录项页

- 数据页的<font color=orange>可能是不连续的</font>，16kb的页在物理存储上是不连续的，如果要从这么多页根据主键值<font color=orange>快速定位某些记录所在的页</font>，需要对页做个<font color=orange>目录</font>
- 目录项页和普通页根据record_type来区分
- 每个页对应一个目录项，每个目录项包含两个部分
- <font color=orange>页的用户记录中最小的主键值</font>: key
- <font color=orange>页号</font>： page_no
- 查找数据时页目录：IO只有两次或者多次(定位目录页可能需要多次)，先从目录项页中根据key找到在哪一页，然后再去加载对应的页

![image-20230718171525721](https://erick-typora-image.oss-cn-shanghai.aliyuncs.com/img/image-20230718171525721.png)

### 2.3 目录项页之目录项页

- 假如顶层目录项页只有一个，查找一个数据的时候，只需要三次与磁盘之间的IO

![image-20230719102504978](/Users/shuzhan/Library/Application Support/typora-user-images/image-20230719102504978.png)
